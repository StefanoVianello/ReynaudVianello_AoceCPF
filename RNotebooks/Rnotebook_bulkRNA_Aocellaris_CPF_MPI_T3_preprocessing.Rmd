---
title: "&nbsp;"
#authors: Stefano Vianello, Marine Eco-Evo-Devo Unit, Academia Sinica Marine Research Station
#from data from Mathieu Reynaud and Fiona Lee
#date: 2022

output:
  html_notebook: 
    css: style.css
    toc: true
    toc_float: true
  html_document:
    css: style.css
    df_print: paged
  pdf_document: default
---

![](C:\Users\Doctor\Pictures\clownfish_banner.PNG) 

## Pre-processing Notebook {.tabset}

### Introduction to the dataset and experimental design 

:::demo
This Rmarkdown notebook describes the pre-processing and quality control of bulkRNAseq data of *Amphiprion ocellaris* larvae treated with a selection of drugs from 8dph to 13dph (5 days total), i.e. until control larvae had metamorphosed. The aim of the experiment was to detect the general effects of the organophosphate pesticide Chlorpyrifos (CPF) on clownfish larvae as they undergo metamorphosis, and specifically on their thyroid hormone signalling pathway. *n=10* larvae were  collected  at the end of each of the 5 treatments (i.e. at 13dph), RNA was extracted from each larva, and RNA was sequenced (total *n=50*). **Treatments**: DMSO (control), T3+IOP (positive control, induction of metamorphosis), MPI (negative control, blockade of metamorphosis), CPF (test drug), CPF+T3+IOP. 
:::

***

```{r, eval=TRUE, include=FALSE, echo=FALSE}
## Install the following packages on your machine, if these have not been installed already 
# Note: only need to run this cell if you have never run this code on this machine

if (!requireNamespace('BiocManager', quietly = TRUE))
  install.packages('BiocManager')

BiocManager::install(c("GenomicFeatures", "dupRadar"))
install.packages(c("fastqcr", "dplyr", "formattable", "ggplot2", "grid", "gridExtra", "tidyr", "tidyverse", "zoo", "scales", "Hmisc", "RColorBrewer", "patchwork", "ggforce"))
devtools::install_github("etam4260/kneedle")
remotes::install_github("mikelove/fastqcTheoreticalGC")

```


```{r, eval=TRUE, include=FALSE, message = T, echo=FALSE}
# #Load libraries from installed packages
# Note: you need to run this cell every time you start a new R session

library(fastqcr)
library(dplyr)
library(formattable)
library(ggplot2)
library(grid)
library(gridExtra)
library(tidyr)
library(tidyverse)
library(GenomicFeatures)
library(zoo)
library(scales)
library(dupRadar)
library(Hmisc)
library(RColorBrewer)
library(patchwork)
library(ggforce)
```


### FastQC reports and flagged issues

#### **Quality control of read data**

Raw (demultiplexed) fastq files were quality-checked based on reports generated by using FastQC v0.12.0 (RRID:SCR_014583; Andrews, 2010) with default parameters, before and after adapter trimming. Adapters were trimmed using the function bbduk (RRID:SCR_016969) of BBTools v39.01 (RRID:SCR_016968; Bushnell B., http://sourceforge.net/projects/bbmap/) with ktrim=r, k=23, and trimpolyg=40 given that the initial FastQC run had identified over-representation of polyG sequences. 

```{r, message = F, include=FALSE, echo=FALSE}
#extract individual QC objects (note, this will take a long time, so the output is saved at the end and loaded later)
#data was adapter trimmed. After a first screening, it was found that partial failure of the flowcell lead to over-representation of polyG sequences (in fact, absence of signal in two-color chemistry sequencing setup), so that polyG sequences were also filtered out. This trimmed, cleaned-up data, was processed in FastQC and FastQscreen.

#import FastQC output files: folder indicated contains one subfolder for each treatment
path_to_FastQC_output <- "Z://05_OIST_data/Mathieu/02b_trimmed_polyg_FastQC_output"


QCfiles <- list.files(path = path_to_FastQC_output, 
                      pattern = "*.fastqc.zip", 
                      full.names = TRUE,
                      recursive = TRUE)

QC_objects <- list()
QC_objects <- append(QC_objects, paste0("QC_object", sprintf("%03d", seq(1:length(QCfiles)))))
QC_objects <- noquote(QC_objects)

for (i in 1:length(QCfiles)) {
  QC_objects[[i]] <- qc_read(QCfiles[i])
  
  #uncomment below if you want the basic statistics table to be plotted
  #qc_plot(QC_objects[[i]], "Basic Statistics")
}

rm(path_to_FastQC_output)
#save(QC_objects, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/QC_objects.rds")
```


```{r, message = F, include=FALSE}
#import FastQC output files: folder indicated contains one subfolder for each treatment
path_to_FastQC_output <- "Z://05_OIST_data/Mathieu/02b_trimmed_polyg_FastQC_output"
subfolders <- list.dirs(path = path_to_FastQC_output, full.names = TRUE, recursive = F)

#import all FastQC reports and combine them together
aggregated_QC_report <- list()
for (i in 1:length(subfolders)) {
  aggregated_QC_report[[i]] <- qc_aggregate(subfolders[i])
}

aggregated_QC_report <- bind_rows(aggregated_QC_report)
#save(aggregated_QC_report, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/aggregated_QC_report.rds")
```

```{r, echo= FALSE, warning=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/aggregated_QC_report.rds")
qc_stats(aggregated_QC_report)
```
<br/>
**PASS modules** <br/>

```{r, echo= FALSE, warning=FALSE}
# only show categories where all sample pass
tmp <- summary(aggregated_QC_report)[summary(aggregated_QC_report)$nb_pass == as.numeric(length(QCfiles)), c("module", "nb_fail", "nb_pass", "nb_warn")]

#present as formatted table (formattable package)
formattable(tmp,
            caption ="FastQC modules that passed for all samples",
            align =c("r","c", "c", "c"), 
            list(`module`= color_tile("palegreen3","palegreen3"),
                 `nb_fail`= color_tile("white","palegreen3"),
                 `nb_pass`= color_tile("white","palegreen3"),
                 `nb_warn`= color_tile("white","palegreen3")

                 )
            )
```


```{r, echo= FALSE, fig.width=9, fig.height=8, include=FALSE}
#load the pre-prepared QC objects 
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/QC_objects.rds")

#Plot PASS modules for e.g. the first 4 samples
for (i in QC_objects[1:4]) {
grid.arrange(top = textGrob(paste("FastQC report: sample", i[["basic_statistics"]][["Value"]][1]),gp=gpar(fontsize=16,font=3)),
              
             qc_plot(i, "Adapter Content"),
             qc_plot(i, "Per base sequence quality"),
             qc_plot(i, "Per sequence quality scores"),
             qc_plot(i, "Per sequence GC content"), 
             qc_plot(i, "Per base sequence content"),
             qc_plot(i, "Sequence duplication levels"),
             ncol = 3
             )
}

```


**WARNING/FAIL metrics** <br/>

We have failures for: **Per base sequence content**, **Per sequence GC content**, **Per tile sequence quality**, **Sequence Duplication Levels**, and **Sequence Length Distribution**. An analysis of each failure type is available in the next tabs.
<br/><br/>

```{r, echo= FALSE, warning=FALSE}
# only show problematic categories where not all sample pass
tmp <- summary(aggregated_QC_report)[summary(aggregated_QC_report)$nb_pass != as.numeric(length(QCfiles)), c("module", "nb_fail", "nb_pass", "nb_warn")]

#present as formatted table (formattable package)
formattable(tmp,
            caption ="FastQC modules with FAIL or WARN flags",
            align =c("r","c", "c", "c"), 
            list(`module`= color_tile("lightcoral","lightcoral"),
                 `nb_fail`= color_tile("white","lightcoral"),
                 `nb_pass`= color_tile("white","palegreen3"),
                 `nb_warn`= color_tile("white","goldenrod1")

                 )
            )
```
### Failed: per-base sequence content
<br/>
`r emo::ji("prohibited")` **Failed: per-base sequence content** 
<br/>
This module issues a warning if the difference between A and T, or G and C is greater than 10% in any position; and a fail if this difference is greater than 20%. <br/> <br/> As indicated by the [FastQC documentation](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/4%20Per%20Base%20Sequence%20Content.html), *"Any library which is generated based on the ligation of random hexamers or through tagmentation should theoretically have good diversity through the sequence, but experience has shown that these libraries always have a selection bias in around the first 12bp of each run. This is due to a biased selection of random primers, but doesn't represent any individually biased sequences. **Nearly all RNA-Seq libraries will fail this module because of this bias**, but this is not a problem which can be fixed by processing, and it doesn't seem to adversely affect the ablity to measure expression."*
<br/><br/>

```{r, echo=FALSE, fig.width=8, fig.height=8}
#let us replot the base content data from the QC reports

#create empty summary dataframe that will contain the data from all the samples
base_content <- data.frame()
#t=0
#loop through each object to extract information
for (i in QC_objects) {
  #print(as.character(i$basic_statistics[2][1,]))
  #t =t+1
  tmp_df <- i[["per_base_sequence_content"]] #store perbase content data as a temporary dataframe 
  tmp_df <- tmp_df %>% pivot_longer(!Base, names_to = "letter", values_to = "count")
  tmp_df$sample <- str_extract(i[["summary"]][["sample"]][1], "(?<=trimmed_polyg_LTS23_).*(?=R*_)")#add label with sample names
  tmp_df$lane <- paste0("L", str_extract_all(i[["basic_statistics"]][[1, 2]], "\\d+", simplify = TRUE)[4])
  base_content <- rbind(base_content,tmp_df) #save the temporary dataframe for this sample into the summary dataframe
    }

#Add descriptive label besides the sample code provided by the sequencing platform
#generate a conversion dictionary

#set levels of ggplot
base_content$Base <- factor(base_content$Base, levels =  QC_objects[[1]][["per_base_sequence_content"]]$Base  )

#plot the GC content data, coloured by sample
ggplot(base_content, aes(x=Base, y=count, group=letter)) +
  geom_point(aes(color=letter), alpha = 0.1) + 
  theme_classic()+ 
  #theme(legend.position="bottom")+
  theme(legend.position="none", axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))+
  ggtitle("Per-base sequence content") +
  xlab("Position in read (bp)") + 
  ylab("Nucleotide frequency (%)")+
  geom_vline(xintercept = 10, linetype="dashed", color = "gray")+
  facet_wrap(vars(letter), nrow = 4)+
  NULL
  
#remove unused variables
#rm(base_content, tmp_df, i)
```

### Failed: Per sequence GC content
<br/>
`r emo::ji("prohibited")` **Failed: Per sequence GC content**
<br/>
This module issues a warning if the sum of the deviations from the normal distribution represents more than 15% of the reads; and a fail if this sum represents more than 30% of the reads.<br/> <br/>
__Below, the GC content distribution of all reads obtained in the dataset (colored by sample) and, under it, the theoretical GC-content distribution obtained from a simulated run of 25million 150bp reads on the clownfish transcriptome__ 

<p class="comment">
As can be seen, the obtained distribution, with a peak around 53% is very similar to the simulated expected distribution. It is therefore likely that the warning from FastQC comes from the programme not having the clownfish reference as a term of comparison (and this reference not being normally distributed).
<br/>
</p>
<br/>

```{r, echo=FALSE, include=FALSE}
#unfortunately, the A ocellaris genome does not already exist as a BSgenome package
#BSgenome::available.genomes()

#we will create one
#BiocManager::install("BSgenomeForge")
library(BSgenomeForge)

#forge the package from NCBI reference
forgeBSgenomeDataPkgFromNCBI(assembly_accession="GCA_022539595.1",
                             pkg_maintainer="Stefano Vianello, <svianello22@gate.sinica.edu.tw>",
                             organism="Amphiprion ocellaris",
                             destdir="Z://05_OIST_data",
                             circ_seqs= character(0) #"NC_009065.1" #not that at the moment this does not work
                             )
#output is saved in Z://05_OIST_data/BSgenome.Aocellaris.NCBI.ASM2253959v1 
#followed up as described in https://bioconductor.org/packages/release/bioc/vignettes/BSgenomeForge/inst/doc/UsingBSgenomeForge.html#final-steps 
```

```{r, echo=FALSE, include=FALSE}
#install Aoce Bsgenome package locally (uncomment below)
#devtools::build("Z://05_OIST_data/BSgenome.Aocellaris.NCBI.ASM2253959v1")
#devtools::check_built("Z:/05_OIST_data/BSgenome.Aocellaris.NCBI.ASM2253959v1_1.0.0.tar.gz")
#devtools::install_local("Z:/05_OIST_data/BSgenome.Aocellaris.NCBI.ASM2253959v1_1.0.0.tar.gz")
library(BSgenome.Aocellaris.NCBI.ASM2253959v1)

#the first time this is run:
#as can be seen, the building function did not assign the original NCBI chromosome names
#seqnames(BSgenome.Aocellaris.NCBI.ASM2253959v1)
#obtain the conversion table
#chrom_info <- getChromInfoFromNCBI("GCA_022539595.1")
#reassign names (i.e. use NCBI codes) 
#seqnames(BSgenome.Aocellaris.NCBI.ASM2253959v1) <- chrom_info$RefSeqAccn[match(seqnames(BSgenome.Aocellaris.NCBI.ASM2253959v1), chrom_info$SequenceName)]
#check new names
#seqnames(BSgenome.Aocellaris.NCBI.ASM2253959v1)


#now we need to created the TxDb (build from the gff file, which useses NCBI chromosome codes, and this is why we had to change the chromosome names in the BSgenome object)
txdb <- makeTxDbFromGFF( file = "Y://bulkRNAseq/GCF_022539595.1/genomic.gff", format = "gff" 
                         #dbxrefTag = "GeneID" #adding this tag means that the name of the genes will be their NCBI code, rather than the symbol
                         )

#for some reason, the BSgenome does not have the MT chromosome, so need to remove this from the txdb
txdb3 <- dropSeqlevels(txdb, "NC_009065.1")
txdb3 <- exonsBy(txdb3, by="tx")
```


```{r, echo=FALSE, include=FALSE}
#we can now generate a simulated expected GC content distribution for our transcriptome
#https://github.com/mikelove/fastqcTheoreticalGC
library(fastqcTheoreticalGC)

#create the list of transcripts (the actual nucleotide sequences)
ao.txs <- extractTranscriptSeqs(x = BSgenome.Aocellaris.NCBI.ASM2253959v1 ,
                                transcripts = txdb3)

#generate the distribution from simulated sequencing of these transcripts
generateDistn(seqs=ao.txs,#a DNAStringSet of the sequences to simulate read from. I.e. the transcripts, which can be generated with extractTranscriptSeqs from the GenomicFeatures package
              bp =150,
              n = 25e+06, #number of reads per sample, in my dataset
              file="Z://05_OIST_data/fastqc_theoretical_ao_GCF_022539595.1_ASM2253959v1_txome.txt", #this will be the name of the file saved
              name="_Aoce(GCF_022539591_ASM2253959v1)" #this will be the title
              )


#we will now load the file with our modelled theoretical GC distribution, and reformat for ggplot
refGC <- read.csv("Z://05_OIST_data/fastqc_theoretical_ao_GCF_022539595.1_ASM2253959v1_txome.txt", sep = "\t", header = F)
refGC <- refGC[-1,]
colnames(refGC) <- c("GC_content", "Count")
refGC$sample <- "theoretical"
refGC$lane <- "NA"
refGC$GC_content <- as.numeric(refGC$GC_content)

refGC<- refGC %>%
  mutate(rolling_avg = rollmean(refGC$Count, k=4, fill=0, align='right'))


```


```{r, echo=FALSE, fig.width=15, fig.height=10}
#let us plot the actual GC content data stored in the FastQC reports
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/QC_objects.rds")

#create empty summary dataframe that will contain the data from all the samples
GC_content <- data.frame()

#loop through each object to extract information
for (i in QC_objects) {
  tmp_df <- i[["per_sequence_gc_content"]] #store the GC content data as a temporary dataframe 
  tmp_df$sample <- str_extract(i[["summary"]][["sample"]][1], "(?<=trimmed_polyg_LTS23_).*(?=R*_)")#add label with sample names
  tmp_df$lane <- paste0("L", str_extract_all(i[["basic_statistics"]][[1, 2]], "\\d+", simplify = TRUE)[4])
  colnames(tmp_df)[1]<- "GC_content" #change the default name of first column because it contains a space
  GC_content <- rbind(GC_content,tmp_df) #save the temporary dataframe for this sample into the summary dataframe
    }


#plot observed and theoretical distributions:

#plot the GC content data, coloured by sample
plot1 <- ggplot(GC_content, aes(x=GC_content, y=Count, group=sample)) +
  geom_line(aes(color=sample, linetype=lane)) + 
  theme_classic()+ 
  theme(legend.position="none")+
  ggtitle("Per-sequence GC content") +
  xlab("Mean GC Content (%)") + 
  ylab("Number of reads")+
  geom_vline(xintercept = 53, linetype="dashed", color = "gray")+
  geom_vline(xintercept = 47, linetype="dashed", color = "gray")+#this is the expected from modelling
  geom_vline(xintercept = 39, linetype="dashed", color = "gray")+ #from previous datasets this is the signature of artemia
  NULL

#plot the GC content data, coloured by sample
plot2 <- ggplot(refGC) +
  geom_line(aes(x=GC_content, y=rolling_avg, group = 1)) + 
  theme_classic()+ 
  theme(legend.position="none")+
  ggtitle("GC distribution of theoretical run (25e+06 * 150bp)") +
  xlab("Mean GC Content (%)") + 
  ylab("Number of reads")+
  scale_y_continuous(label=scientific_format())+
  geom_vline(xintercept = 53, linetype="dashed", color = "gray")+
  geom_vline(xintercept = 47, linetype="dashed", color = "gray")+#this is the expected from modelling
  geom_vline(xintercept = 39, linetype="dashed", color = "gray")+ #from previous datasets this is the signature of artemia
  NULL

grid.arrange(plot1, plot2, ncol=1, nrow=2)

```



### Failed: per-tile sequence quality
<br/>
`r emo::ji("prohibited")` **Failed: per-tile sequence quality**
<br/>
This module will issue a warning if any tile shows a mean Phred score more than 2 less than the mean for that base across all tiles; and a fail if this is less than 5 than the mean for that base across all tiles. <br/> <br/>
__Below, average tile quality score across the entire chip, for all samples, and then separated by sequencing lane and side of the chip__ 

<p class="comment">
As can be seen, this sequencing run suffered from two main problems. In red: one tiles that produced no data throughout the whole run, for both read directions. This was followed up with the sequencing facility and linked to a common manufacturing defect for patterned flowcells. Areas of loss of quality, especially for advanced positions of some R2 reads, were also detected. Since overall yield and quality of the run were well within Illuminaâ€™s specification ( >1000M PF fragments and Q30 bases >75%), the issue was considered non prejudicial. 
<br/>
</p>
<br/>


```{r, echo = FALSE, include=FALSE}
#tile numbers for an illumina P3 are:
tile_codes_P3<- c('1101', '1102', '1103', '1104', '1105', '1106', '1107', '1108', '1109', '1110', '1111', '1112', '1113', '1114', 
                  '1201', '1202', '1203', '1204', '1205', '1206', '1207', '1208', '1209', '1210', '1211', '1212', '1213', '1214', 
                  '1301', '1302', '1303', '1304', '1305', '1306', '1307', '1308', '1309', '1310', '1311', '1312', '1313', '1314', 
                  '1401', '1402', '1403', '1404', '1405', '1406', '1407', '1408', '1409', '1410', '1411', '1412', '1413', '1414', 
                  '1501', '1502', '1503', '1504', '1505', '1506', '1507', '1508', '1509', '1510', '1511', '1512', '1513', '1514', 
                  '1601', '1602', '1603', '1604', '1605', '1606', '1607', '1608', '1609', '1610', '1611', '1612', '1613', '1614', 
                  
                  '2101', '2102', '2103', '2104', '2105', '2106', '2107', '2108', '2109', '2110', '2111', '2112', '2113', '2114', 
                  '2201', '2202', '2203', '2204', '2205', '2206', '2207', '2208', '2209', '2210', '2211', '2212', '2213', '2214', 
                  '2301', '2302', '2303', '2304', '2305', '2306', '2307', '2308', '2309', '2310', '2311', '2312', '2313', '2314', 
                  '2401', '2402', '2403', '2404', '2405', '2406', '2407', '2408', '2409', '2410', '2411', '2412', '2413', '2414', 
                  '2501', '2502', '2503', '2504', '2505', '2506', '2507', '2508', '2509', '2510', '2511', '2512', '2513', '2514', 
                  '2601', '2602', '2603', '2604', '2605', '2606', '2607', '2608', '2609', '2610', '2611', '2612', '2613', '2614')
```


```{r, echo=FALSE, fig.width=10}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/QC_objects.rds")

tile_data_list <- list()

for (i in seq(1,length(QC_objects), by=1)) {
  tile_data <- as.data.frame(QC_objects[[i]][["per_tile_sequence_quality"]])
  #https://knowledge.illumina.com/instrumentation/nextseq-1000-2000/instrumentation-nextseq-1000-2000-reference_material-list/000002392
#the illumina 2000 P3 flow cell has two lanes, each with 2 surfaces, each with 6 swaths, each with 14tiles; meaning that each lane has 168 total tiles. In the file, they are names #Surface-#Swath-#tile
  #print(summary(tile_codes_P3 %in% tile_data$Tile))
  #for some reson (TO ASK), not all tiles are extracted/presented in the QC object
  #complete(tile_data, Tile)
  #find missing tile
    missing_tile <- tile_codes_P3[which(tile_codes_P3 %in% unique(QC_objects[[i]][["per_tile_sequence_quality"]]$Tile)==FALSE)]
  if (length(missing_tile)!=0) {
    #make a fake dataframe for this tile
  missing_data <- data.frame(Tile= rep(missing_tile, 38) , Base = tile_data$Base[1:38], Mean = NA)
  #add to the dataframe
  tile_data <- rbind(tile_data, missing_data)
  #reorder dataframe based on tile and then on position
  tile_data <- tile_data %>% arrange(Tile)
  }
#to obtain a nicer plot, we can use numbers from 1 to 168
  
  
  
  tile_data$Tile2 <- match(tile_data$Tile, unique(tile_data$Tile))
  tile_data$Tile2 <- as.numeric(tile_data$Tile2)
  
  #rename base positions 1 to 10 so they are ordered correctly with respect to the other ones
  for (k in 1:nrow(tile_data)) {
    
    if (tile_data$Base[k] %in% c("1", "2", "3", "4", "5", "6", "7", "8", "9")) {
    tile_data$Base2[k] <- c("01", "02", "03", "04", "05", "06", "07", "08", "09")[as.numeric(tile_data$Base[k])]
    }
    else
      tile_data$Base2[k] <- tile_data$Base[k]
  }
  
  tile_data_list[[i]] <- tile_data
  
    if (i == 1) {
      tile_data_combined <- tile_data
    }
    
    else
    tile_data_combined <- merge(tile_data_combined, tile_data, by = c("Tile2", "Tile", "Base", "Base2"), suffixes = c(i-1, i))
}


#create summary table 
tile_data_summary <- tile_data_combined[,c(1, 4:ncol(tile_data_combined))]
tile_data_summary$summary_mean <- rowMeans(tile_data_summary[,3:ncol(tile_data_summary)])

#set levels of ggplot
tile_data_summary$Base2 <- factor(tile_data_summary$Base2, levels =  unique(tile_data$Base2))

#plot the tile with quality scores
ggplot(tile_data_summary, aes(x = Base2, y = Tile2, fill = summary_mean)) +
  geom_tile() + theme_classic()+
  scale_fill_gradient(low = "black", high = "white", na.value = "red") +
  geom_hline(yintercept=84, col = "blue") +
  geom_hline(yintercept=seq(14, 168, 14), col = "gray60", linetype = "dashed") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="gray80"),
         plot.subtitle=element_text(color="gray60"))+
  #scale_y_cut(breaks=c(84)) +
  xlab("Base") + 
  ylab("Side1 <- Tile -> Side2")+
  ggtitle("Per-tile sequence quality score (average all samples)", subtitle = "mean quality of 50 samples (x2 lanes, PE)")+
  #coord_equal()+
   #geom_text(aes(label = Mean), color = "white", size = 1) +
  NULL

```



```{r, echo=FALSE, fig.width=16, fig.height=8}
#sometimes there may be lane specific, or (rarely) read direction specific bugs.
#Create 4 plots

tile_data_list <- list()

for (i in seq(1,length(QC_objects), by=4)) {
  tile_data <- as.data.frame(QC_objects[[i]][["per_tile_sequence_quality"]])
  #https://knowledge.illumina.com/instrumentation/nextseq-1000-2000/instrumentation-nextseq-1000-2000-reference_material-list/000002392
#the illumina 2000 P3 flow cell has two lanes, each with 2 surfaces, each with 6 swaths, each with 14tiles; meaning that each lane has 168 total tiles. In the file, they are names #Surface-#Swath-#tile
  #print(summary(tile_codes_P3 %in% tile_data$Tile))
  #for some reson (TO ASK), not all tiles are extracted/presented in the QC object
  #complete(tile_data, Tile)
   #find missing tile
  missing_tile <- tile_codes_P3[which(tile_codes_P3 %in% unique(QC_objects[[i]][["per_tile_sequence_quality"]]$Tile)==FALSE)]
  if (length(missing_tile)!=0) {
    #make a fake dataframe for this tile
  missing_data <- data.frame(Tile= rep(missing_tile, 38) , Base = tile_data$Base[1:38], Mean = NA)
  #add to the dataframe
  tile_data <- rbind(tile_data, missing_data)
  #reorder dataframe based on tile and then on position
  tile_data <- tile_data %>% arrange(Tile)
  }
  
  
#to obtain a nicer plot, we can use numbers from 1 to 168
  
  
  
  tile_data$Tile2 <- match(tile_data$Tile, unique(tile_data$Tile))
  tile_data$Tile2 <- as.numeric(tile_data$Tile2)
  
  #rename base positions 1 to 10 so they are ordered correctly with respect to the other ones
  for (k in 1:nrow(tile_data)) {
    
    if (tile_data$Base[k] %in% c("1", "2", "3", "4", "5", "6", "7", "8", "9")) {
    tile_data$Base2[k] <- c("01", "02", "03", "04", "05", "06", "07", "08", "09")[as.numeric(tile_data$Base[k])]
    }
    else
      tile_data$Base2[k] <- tile_data$Base[k]
  }
  
  tile_data_list[[i]] <- tile_data
  
    if (i == 1) {
      tile_data_combined <- tile_data
    }
    
    else
    tile_data_combined <- merge(tile_data_combined, tile_data, by = c("Tile2", "Tile", "Base", "Base2"), suffixes = c(i-1, i))
}


#create summary table 
tile_data_summary <- tile_data_combined[,c(1, 4:ncol(tile_data_combined))]
tile_data_summary$summary_mean <- rowMeans(tile_data_summary[,3:ncol(tile_data_summary)])

#set levels of ggplot
tile_data_summary$Base2 <- factor(tile_data_summary$Base2, levels =  unique(tile_data$Base2))

#plot the tile with quality scores
plot1 <- ggplot(tile_data_summary, aes(x = Base2, y = Tile2, fill = summary_mean)) +
  geom_tile() + theme_classic()+
  scale_fill_gradient(low = "black", high = "white",  na.value="red") +
  geom_hline(yintercept=84, col = "blue") +
  geom_hline(yintercept=seq(14, 168, 14), col = "gray60", linetype = "dashed") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="gray80"),
        plot.subtitle=element_text(color="gray60"))+
  #scale_y_cut(breaks=c(84)) +
  xlab("Base") + 
  ylab("Side1 <- Tile -> Side2")+
  ggtitle("Per-tile sequence quality score (Lane001, R1)", subtitle = "Mean quality of 50 samples")+
  #coord_equal()+
   #geom_text(aes(label = Mean), color = "white", size = 1) +
  NULL

rm(tile_data, tile_data_combined)
################ PLOT 2
tile_data_list <- list()

for (i in seq(2,length(QC_objects), by=4)) {
  tile_data <- as.data.frame(QC_objects[[i]][["per_tile_sequence_quality"]])
  #https://knowledge.illumina.com/instrumentation/nextseq-1000-2000/instrumentation-nextseq-1000-2000-reference_material-list/000002392
#the illumina 2000 P3 flow cell has two lanes, each with 2 surfaces, each with 6 swaths, each with 14tiles; meaning that each lane has 168 total tiles. In the file, they are names #Surface-#Swath-#tile
  #print(summary(tile_codes_P3 %in% tile_data$Tile))
  #for some reson (TO ASK), not all tiles are extracted/presented in the QC object
  #complete(tile_data, Tile)
   #find missing tile
    missing_tile <- tile_codes_P3[which(tile_codes_P3 %in% unique(QC_objects[[i]][["per_tile_sequence_quality"]]$Tile)==FALSE)]
  if (length(missing_tile)!=0) {
    #make a fake dataframe for this tile
  missing_data <- data.frame(Tile= rep(missing_tile, 38) , Base = tile_data$Base[1:38], Mean = NA)
  #add to the dataframe
  tile_data <- rbind(tile_data, missing_data)
  #reorder dataframe based on tile and then on position
  tile_data <- tile_data %>% arrange(Tile)
  }
#to obtain a nicer plot, we can use numbers from 1 to 168
  
  
  
  tile_data$Tile2 <- match(tile_data$Tile, unique(tile_data$Tile))
  tile_data$Tile2 <- as.numeric(tile_data$Tile2)
  
  #rename base positions 1 to 10 so they are ordered correctly with respect to the other ones
  for (k in 1:nrow(tile_data)) {
    
    if (tile_data$Base[k] %in% c("1", "2", "3", "4", "5", "6", "7", "8", "9")) {
    tile_data$Base2[k] <- c("01", "02", "03", "04", "05", "06", "07", "08", "09")[as.numeric(tile_data$Base[k])]
    }
    else
      tile_data$Base2[k] <- tile_data$Base[k]
  }
  
  tile_data_list[[i]] <- tile_data
  
    if (i == 2) {
      tile_data_combined <- tile_data
    }
    
    else
    tile_data_combined <- merge(tile_data_combined, tile_data, by = c("Tile2", "Tile", "Base", "Base2"), suffixes = c(i-1, i))
}


#create summary table 
tile_data_summary <- tile_data_combined[,c(1, 4:ncol(tile_data_combined))]
tile_data_summary$summary_mean <- rowMeans(tile_data_summary[,3:ncol(tile_data_summary)])

#set levels of ggplot
tile_data_summary$Base2 <- factor(tile_data_summary$Base2, levels =  unique(tile_data$Base2))

#plot the tile with quality scores
plot2 <- ggplot(tile_data_summary, aes(x = Base2, y = Tile2, fill = summary_mean)) +
  geom_tile() + theme_classic()+
  scale_fill_gradient(low = "black", high = "white",  na.value="red") +
  geom_hline(yintercept=84, col = "blue") +
  geom_hline(yintercept=seq(14, 168, 14), col = "gray60", linetype = "dashed") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="gray80"),
        plot.subtitle=element_text(color="gray60"))+
  #scale_y_cut(breaks=c(84)) +
  xlab("Base") + 
  ylab("Side1 <- Tile -> Side2")+
  ggtitle("Per-tile sequence quality score (Lane001, R2)", subtitle = "Mean quality of 50 samples")+
  #coord_equal()+
   #geom_text(aes(label = Mean), color = "white", size = 1) +
  NULL
rm(tile_data, tile_data_combined)


################ PLOT3 
tile_data_list <- list()

for (i in seq(3,length(QC_objects), by=4)) {
  tile_data <- as.data.frame(QC_objects[[i]][["per_tile_sequence_quality"]])
  #https://knowledge.illumina.com/instrumentation/nextseq-1000-2000/instrumentation-nextseq-1000-2000-reference_material-list/000002392
#the illumina 2000 P3 flow cell has two lanes, each with 2 surfaces, each with 6 swaths, each with 14tiles; meaning that each lane has 168 total tiles. In the file, they are names #Surface-#Swath-#tile
  #print(summary(tile_codes_P3 %in% tile_data$Tile))
  #for some reson (TO ASK), not all tiles are extracted/presented in the QC object
  #complete(tile_data, Tile)
   #find missing tile
    missing_tile <- tile_codes_P3[which(tile_codes_P3 %in% unique(QC_objects[[i]][["per_tile_sequence_quality"]]$Tile)==FALSE)]
  if (length(missing_tile)!=0) {
    #make a fake dataframe for this tile
  missing_data <- data.frame(Tile= rep(missing_tile, 38) , Base = tile_data$Base[1:38], Mean = NA)
  #add to the dataframe
  tile_data <- rbind(tile_data, missing_data)
  #reorder dataframe based on tile and then on position
  tile_data <- tile_data %>% arrange(Tile)
  }
#to obtain a nicer plot, we can use numbers from 1 to 168
  
  
  
  tile_data$Tile2 <- match(tile_data$Tile, unique(tile_data$Tile))
  tile_data$Tile2 <- as.numeric(tile_data$Tile2)
  
  #rename base positions 1 to 10 so they are ordered correctly with respect to the other ones
  for (k in 1:nrow(tile_data)) {
    
    if (tile_data$Base[k] %in% c("1", "2", "3", "4", "5", "6", "7", "8", "9")) {
    tile_data$Base2[k] <- c("01", "02", "03", "04", "05", "06", "07", "08", "09")[as.numeric(tile_data$Base[k])]
    }
    else
      tile_data$Base2[k] <- tile_data$Base[k]
  }
  
  tile_data_list[[i]] <- tile_data
  
    if (i == 3) {
      tile_data_combined <- tile_data
    }
    
    else
    tile_data_combined <- merge(tile_data_combined, tile_data, by = c("Tile2", "Tile", "Base", "Base2"), suffixes = c(i-1, i))
}


#create summary table 
tile_data_summary <- tile_data_combined[,c(1, 4:ncol(tile_data_combined))]
tile_data_summary$summary_mean <- rowMeans(tile_data_summary[,3:ncol(tile_data_summary)])

#set levels of ggplot
tile_data_summary$Base2 <- factor(tile_data_summary$Base2, levels =  unique(tile_data$Base2))

#plot the tile with quality scores
plot3 <- ggplot(tile_data_summary, aes(x = Base2, y = Tile2, fill = summary_mean)) +
  geom_tile() + theme_classic()+
  scale_fill_gradient(low = "black", high = "white",  na.value="red") +
  geom_hline(yintercept=84, col = "blue") +
  geom_hline(yintercept=seq(14, 168, 14), col = "gray60", linetype = "dashed") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="gray80"),
        plot.subtitle=element_text(color="gray60"))+
  #scale_y_cut(breaks=c(84)) +
  xlab("Base") + 
  ylab("Side1 <- Tile -> Side2")+
  ggtitle("Per-tile sequence quality score (Lane002, R1)", subtitle = "Mean quality of 50 samples")+
  #coord_equal()+
   #geom_text(aes(label = Mean), color = "white", size = 1) +
  NULL
rm(tile_data, tile_data_combined)


################ PLOT 4
tile_data_list <- list()

for (i in seq(4,length(QC_objects), by=4)) {
  tile_data <- as.data.frame(QC_objects[[i]][["per_tile_sequence_quality"]])
  #https://knowledge.illumina.com/instrumentation/nextseq-1000-2000/instrumentation-nextseq-1000-2000-reference_material-list/000002392
#the illumina 2000 P3 flow cell has two lanes, each with 2 surfaces, each with 6 swaths, each with 14tiles; meaning that each lane has 168 total tiles. In the file, they are names #Surface-#Swath-#tile
  #print(summary(tile_codes_P3 %in% tile_data$Tile))
  #for some reson (TO ASK), not all tiles are extracted/presented in the QC object
  #complete(tile_data, Tile)
  #find missing tile
    missing_tile <- tile_codes_P3[which(tile_codes_P3 %in% unique(QC_objects[[i]][["per_tile_sequence_quality"]]$Tile)==FALSE)]
  if (length(missing_tile)!=0) {
    #make a fake dataframe for this tile
  missing_data <- data.frame(Tile= rep(missing_tile, 38) , Base = tile_data$Base[1:38], Mean = NA)
  #add to the dataframe
  tile_data <- rbind(tile_data, missing_data)
  #reorder dataframe based on tile and then on position
  tile_data <- tile_data %>% arrange(Tile)
  }
  
#to obtain a nicer plot, we can use numbers from 1 to 168
  
  
  
  tile_data$Tile2 <- match(tile_data$Tile, unique(tile_data$Tile))
  tile_data$Tile2 <- as.numeric(tile_data$Tile2)
  
  #rename base positions 1 to 10 so they are ordered correctly with respect to the other ones
  for (k in 1:nrow(tile_data)) {
    
    if (tile_data$Base[k] %in% c("1", "2", "3", "4", "5", "6", "7", "8", "9")) {
    tile_data$Base2[k] <- c("01", "02", "03", "04", "05", "06", "07", "08", "09")[as.numeric(tile_data$Base[k])]
    }
    else
      tile_data$Base2[k] <- tile_data$Base[k]
  }
  
  tile_data_list[[i]] <- tile_data
  
    if (i == 4) {
      tile_data_combined <- tile_data
    }
    
    else
    tile_data_combined <- merge(tile_data_combined, tile_data, by = c("Tile2", "Tile", "Base", "Base2"), suffixes = c(i-1, i))
}


#create summary table 
tile_data_summary <- tile_data_combined[,c(1, 4:ncol(tile_data_combined))]
tile_data_summary$summary_mean <- rowMeans(tile_data_summary[,3:ncol(tile_data_summary)])

#set levels of ggplot
tile_data_summary$Base2 <- factor(tile_data_summary$Base2, levels =  unique(tile_data$Base2))

#plot the tile with quality scores
plot4 <- ggplot(tile_data_summary, aes(x = Base2, y = Tile2, fill = summary_mean)) +
  geom_tile() + theme_classic()+
  scale_fill_gradient(low = "black", high = "white", na.value="red") +
  geom_hline(yintercept=84, col = "blue") +
  geom_hline(yintercept=seq(14, 168, 14), col = "gray60", linetype = "dashed") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="gray80"),
        plot.subtitle=element_text(color="gray60"))+
  #scale_y_cut(breaks=c(84)) +
  xlab("Base") + 
  ylab("Side1 <- Tile -> Side2")+
  ggtitle("Per-tile sequence quality score (Lane002, R2)", subtitle = "Mean quality of 50 samples" )+
  #coord_equal()+
   #geom_text(aes(label = Mean), color = "white", size = 1) +
  NULL

grid.arrange(plot1, plot2, plot3, plot4, ncol=2)

```




### Failed: sequence duplication levels
<br/>
`r emo::ji("prohibited")` **Failed: sequence duplication levels**<br/>
<br/>
This module will issue a warning if non-unique sequences make up more than 20% of the total, and a fail if non-unique sequences make up more than 50% of the total.
<br/><br/>
Issues relating to the detection of high sequence duplication rates were diagnosed based on the output of the analyzeDuprates function of the dupRadar package (Sayols et al., 2016). To this aim, duplicate reads were marked with the function markdup from SAMtools v1.18 (RRID:SCR_002105; Danecek et al; 2021) with default parameters. To prepare the files, trimmed files were aligned to the clownfish Amphiprion ocellaris reference genome assembly ASM2253959v1, using bowtie2 v2.4.4 (RRID:SCR_016368;  Langmead, Salzberg, 2012) with default parameters. The resulting .sam files were then converted to .bam (samtools/view), sorted (samtools/sort), updated (samtools/fixmate) and re-sorted by location (samtools/sort), all with default parameters. 
<br/><br/>
__Below, an analysis of the sample with the highest sequence duplication level (*LTS23_FZ22_S22_L001*, MPI larva, replicate 2, lane 1), and that wit the lowest one (*LTS23_FZ46_S46_L002*, MPI+T3IOP larva, replicate 6, lane 2). Note that no sample passed.__
<br/><br/>
<p class="comment">
Based on dupRadar documentation, identifying a trend whereby duplication rates actually increase as a function of expression levels would be expected. Based on the plots below however, there appears to be an underlying low-sequencing-depth problem of the dataset, whereas most genes are represented by very few reads. Accordingly, and though the expecte trend is seen, there are also appear to be "step-wise" high duplication rate levels for lowly-detected genes, which may be indicative of PCR amplification artefacts. This hsould be followed up with the sequencing facility in adjusting the coverage for future runs. 
<br/>
</p>
<br/>

```{r, echo=FALSE, include=FALSE}
#find sample with worse sequence duplication level

deduplicated_values <- ls()


for (i in seq(1:length(QC_objects))) {
  deduplicated_value <- QC_objects[[i]]$total_deduplicated_percentage
  deduplicated_values[i] <- deduplicated_value
} 

#extract the filename of the sample with the lowest duplication rates, and the highest
worst_sample <- as.data.frame(QC_objects[[match(min(deduplicated_values), deduplicated_values)]]$summary)[1,3]
best_sample <- as.data.frame(QC_objects[[match(max(deduplicated_values), deduplicated_values)]]$summary)[1,3]

worst_sample
best_sample

#convert to the corresponding name of the bam file
worst_sample <- paste0(str_extract(worst_sample, ".*(?=_R\\d)"), "-markdup.bam")
best_sample <- paste0(str_extract(best_sample, ".*(?=_R\\d)"), "-markdup.bam")

worst_sample
best_sample
```


```{r, echo=FALSE, include=FALSE}
#the anallyzeDuprates function requires a .gtf annotation file. 
#Since for this new genomic version we only have a gff, we need to convert it to gtf
#genomic_gff <- import("D://GCF_022539595.1/ncbi_dataset/data\GCF_022539595.1/genomic.gff")
#export(genomic_gff,"genomic.gtf","gtf")
# OR download the .gtf from https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/022/539/595/GCF_022539595.1_ASM2253959v1/
#"Z://05_OIST_data/Mathieu/trimmed_polyg_FastQC_output/1_DMSO"

# Duplication rate analysis
## Note: this may take a long time to run
dm_highest <- analyzeDuprates(bam = paste0("Z://05_OIST_data/Mathieu/02d_markdup_bams/", worst_sample),
                      gtf = "Y://bulkRNAseq/GCF_022539595.1/GCF_022539595.1_ASM2253959v1_genomic.gtf.gz",
                      stranded = 1, # '0' (unstranded), '1' (stranded) and '2' (reversely stranded)
                      paired = TRUE, # is the library paired end?
                      threads = 8  # number of threads to be used
                      )

dm_lowest <- analyzeDuprates(bam = paste0("Z://05_OIST_data/Mathieu/02d_markdup_bams/", best_sample),
                      gtf = "Y://bulkRNAseq/GCF_022539595.1/GCF_022539595.1_ASM2253959v1_genomic.gtf.gz",
                      stranded = 1, # '0' (unstranded), '1' (stranded) and '2' (reversely stranded)
                      paired = TRUE, # is the library paired end?
                      threads = 8  # number of threads to be used
                      )

#save(dm_highest, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/DupRadar_highestdup.rds")
#save(dm_lowest, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/DupRadar_lowestdup.rds")
```

```{r, fig.width=10, fig.height=10, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/DupRadar_highestdup.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/DupRadar_lowestdup.rds")

#subset only non-zero RPKM
dm_highest <- dplyr::filter(dm_highest, RPKM > 0)
dm_lowest <- dplyr::filter(dm_lowest, RPKM > 0)
#par(mfrow=c(2,2))

#expressionHist(DupMat=dm_highest)

#duprateExpDensPlot(DupMat=dm_highest)       
#title("good experiment")

#The duprateExpBoxplot plot shows the range of the duplication rates at 5% bins (default) along the distribution of RPK gene counts. The x-axis displays the quantile of the RPK distribution, and the average RPK of the genes contained in this quantile.
#duprateExpBoxplot(DupMat=dm_highest, stepSize = 0.05)

#readcountExpBoxplot(DupMat=dm_highest)

```



```{r, echo=FALSE, warning=FALSE ,fig.width=16, fig.height=12}
#prepare the data so that there is a column grouped by RPKM tier (5% steps), as well as outliers are indicated
dm_highest2 <- dm_highest[order(dm_highest$RPK),]
dm_highest2$bin <-  as.numeric(cut2(dm_highest2$RPK, g=20))

dm_highest2 <-
  dm_highest2 %>%
  group_by(bin) %>%
  mutate(outlier.high = dupRate > quantile(dupRate, .75) + 1.50*IQR(dupRate)) %>%
  mutate(outlier.low = dupRate < quantile(dupRate, .25) - 1.50*IQR(dupRate)) %>%
  ungroup


##------------------
#plots

#raw RPKM distribution
plot1 <- ggplot(dm_highest2, aes(x=RPK)) +
  geom_histogram(stat = "bin", bins = 100, fill="dodgerblue") +
  xlab("raw RPK") +
  ylab("number of genes \n with given RPK")+
  ggtitle("distribution of raw RPK")+
  #ylim(0,100)+
  theme_bw()+
  geom_vline(xintercept=1000, color="red")+
  #theme(legend.position = "none")+
  NULL

#log10 RPKM distribution
plot2 <- ggplot(dm_highest2, aes(x=log10(RPK), fill=as.factor(bin))) +
  geom_histogram(stat = "bin", bins = 1000) +
  xlab("log10(RPK)") +
  ylab("number of genes \n with given log10(RPK)")+
  ggtitle("distribution of RPK (log)",
          subtitle = "tiered (ventiles)")+
  #ylim(0,20000)+
  geom_vline(xintercept=3, color="red")+
  geom_vline(xintercept = log10(dm_highest2[(which(dm_highest2$bin[-1] != dm_highest2$bin[-length(dm_highest2$bin)]))+1, "RPK"][[1]]), color = "gray")+
  theme_bw()+
  theme(legend.position = "none")+
  NULL

#plot1b <- ggplot(dm_highest2, aes(x=RPKM)) +
#  geom_histogram(stat = "bin", bins = round(max(dm_highest2$RPKM)), fill="dodgerblue") +
#  xlab("raw RPKM") +
#  ylab("number of genes \n with given RPKM")+
#  ggtitle("distribution of raw RPKM", subtitle = "most genes have few RPKM")+
#  theme_bw()+
#  facet_zoom(xlim = c(0, 10), ylim = c(0, 1000))+
#  #theme(legend.position = "none")+
#  NULL

#plot1c<- ggplot(dm_highest2, aes(x=RPKM)) +
#  geom_histogram(stat = "bin", bins = 50, fill="dodgerblue") +
#  xlab("raw RPKM") +
#  ylab("number of genes \n with given expression")+
#  ggtitle("distribution of raw RPKM", subtitle = "very few genes have high RPKM")+
#  theme_bw()+
#  facet_zoom(ylim = c(0, 1))+
#  #theme(legend.position = "none")+
#  NULL

plot3 <- ggplot(dm_highest2, aes(x=dupRate*100)) +
  geom_histogram(stat = "bin", bins = 100, fill="dodgerblue") +
  xlab("duplication rate (%)") +
  ylab("number of genes \n with given duplication rate")+
  ggtitle("distribution of duplication rates")+
  #ylim(0,100)+
  theme_bw()+
  #theme(legend.position = "none")+
  NULL


plot4 <- ggplot(dm_highest2, aes(x=as.factor(bin), y=allCounts, group=bin, fill=as.factor(bin))) + 
  geom_bar(stat="identity") +
  xlab("RPK ventile") +
  ylab("number of genes \n with given allCounts")+
  ggtitle("distribution of allCounts by expression")+
  #ylim(0,100)+
  theme_bw()+
  scale_x_discrete(labels = paste0(((unique(dm_highest2$bin)-1)*5), "-", ((unique(dm_highest2$bin)-1)*5)+5, "%")) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))+
  NULL 

plot5 <- ggplot(dm_highest2, aes(x = factor(bin), y = dupRate*100)) +
  geom_boxplot(outlier.colour=NA, fill=NA, colour="black") +
  
  geom_point(data = function(x) dplyr::filter_(x, ~ outlier.high ==F & outlier.low == F),
             alpha=0.1,
             color= rep(hue_pal()(20), times =unname(table(dm_highest2[dm_highest2$outlier.high == F & dm_highest2$outlier.low == F ,"bin"]))),
             position=position_jitter(width=0.2, height=0.1)
             ) +
  geom_point(data = function(x) dplyr::filter_(x, ~ outlier.high ==T | outlier.low == T),
             alpha=0.1,
             color= "gray",
             position=position_jitter(width=0.2, height=0.1)
             ) +
  scale_x_discrete(labels = paste0(((unique(dm_highest2$bin)-1)*5), "-", ((unique(dm_highest2$bin)-1)*5)+5, "%")) +
  labs(x = "RPK ventile", y= "Percentage of duplicated reads")+
  ggtitle("Duplication-RPK releationship", subtitle = worst_sample)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))+
  NULL


cols  <- colorRampPalette(rev(brewer.pal(11,"RdYlBu")))
dcols <- densCols(x=log10(dm_highest2$RPK),y=(dm_highest2$dupRate)*100,colramp=cols,nbin=500)

#calculate dupradar fit
fit <- duprateExpFit(dm_highest2)

plot6 <- ggplot(dm_highest2) +
  #geom_vline(xintercept = log10(dm_highest2[(which(dm_highest2$bin[-1] != dm_highest2$bin[-length(dm_highest2$bin)]))+1, "RPK"][[1]]), color = "gray")+
  geom_point(aes(x=log10(RPK), y=dupRate*100 
                 #colour = as.factor(bin),
                 ), alpha=0.1, 
             colour =dcols
             ) + 
  geom_line(aes(x=log10(RPK), y=100*predict(fit$glm,data.frame(x=log10(RPK)),type="response")), color="lightcoral", size=1, lty="dashed") + #this is the dupradar formula
  xlab("log10(RPK)") +
  ylab("Percentage of duplicated reads")+
  ggtitle("Duplication-RPK releationship", 
          subtitle = paste0(worst_sample, "\n Intercept: ", round(fit$intercept,2), "; Slope: ", round(fit$slope,2)))+
  #scale_y_log10() +
  #scale_x_log10()+
  geom_vline(xintercept=3, color="red", size=0.5)+
  geom_vline(xintercept=log10(dm_highest2$RPK[min(which(dm_highest2[order(dm_highest2$RPKM), "RPKM"] >= 0.5))]), #this shows the RPK value corresponding to RPKM 0.5
             color="dodgerblue")+
  theme_bw()+
  theme(legend.position = "none")+
  #geom_vline(xintercept = log10(dm_highest2[(which(dm_highest2$bin[-1] != dm_highest2$bin[-length(dm_highest2$bin)]))+1, "RPK"][[1]]), color = "gray")+
  NULL  

#(plot1 + plot2 + plot3) / (plot1b + plot1c+ plot6) / (plot7 + plot8)

(plot1 + plot2 + plot3 + plot4) / (plot5 + plot6)+
plot_annotation(title = "Duplication rate analysis (dupRadar)",
                subtitle = paste0(worst_sample, "\n \n")) &  theme(plot.title = element_text(hjust = 0.5, size=20),
                                                                   plot.subtitle = element_text(hjust = 0.5, size=16, color = "gray40"))

```






```{r, echo=FALSE, warning=FALSE ,fig.width=16, fig.height=12}
#prepare the data so that there is a column grouped by RPKM tier (5% steps), as well as outliers are indicated
library(Hmisc)
dm_lowest2 <- dm_lowest[order(dm_lowest$RPK),]
dm_lowest2$bin <-  as.numeric(cut2(dm_lowest2$RPK, g=20))

dm_lowest2 <-
  dm_lowest2 %>%
  group_by(bin) %>%
  mutate(outlier.high = dupRate > quantile(dupRate, .75) + 1.50*IQR(dupRate)) %>%
  mutate(outlier.low = dupRate < quantile(dupRate, .25) - 1.50*IQR(dupRate)) %>%
  ungroup


##------------------
#plots

#raw RPKM distribution
plot1 <- ggplot(dm_lowest2, aes(x=RPK)) +
  geom_histogram(stat = "bin", bins = 100, fill="dodgerblue") +
  xlab("raw RPK") +
  ylab("number of genes \n with given RPK")+
  ggtitle("distribution of raw RPK")+
  #ylim(0,100)+
  theme_bw()+
  geom_vline(xintercept=1000, color="red")+
  #theme(legend.position = "none")+
  NULL

#log10 RPKM distribution
plot2 <- ggplot(dm_lowest2, aes(x=log10(RPK), fill=as.factor(bin))) +
  geom_histogram(stat = "bin", bins = 1000) +
  xlab("log10(RPK)") +
  ylab("number of genes \n with given log10(RPK)")+
  ggtitle("distribution of RPK (log)",
          subtitle = "tiered (ventiles)")+
  #ylim(0,20000)+
  geom_vline(xintercept=3, color="red")+
  geom_vline(xintercept = log10(dm_lowest2[(which(dm_lowest2$bin[-1] != dm_lowest2$bin[-length(dm_lowest2$bin)]))+1, "RPK"][[1]]), color = "gray")+
  theme_bw()+
  theme(legend.position = "none")+
  NULL


plot3 <- ggplot(dm_lowest2, aes(x=dupRate*100)) +
  geom_histogram(stat = "bin", bins = 100, fill="dodgerblue") +
  xlab("duplication rate (%)") +
  ylab("number of genes \n with given duplication rate")+
  ggtitle("distribution of duplication rates")+
  #ylim(0,100)+
  theme_bw()+
  #theme(legend.position = "none")+
  NULL


plot4 <- ggplot(dm_lowest2, aes(x=as.factor(bin), y=allCounts, group=bin, fill=as.factor(bin))) + 
  geom_bar(stat="identity") +
  xlab("RPK ventile") +
  ylab("number of genes \n with given allCounts")+
  ggtitle("distribution of allCounts by expression")+
  #ylim(0,100)+
  theme_bw()+
  scale_x_discrete(labels = paste0(((unique(dm_lowest2$bin)-1)*5), "-", ((unique(dm_lowest2$bin)-1)*5)+5, "%")) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))+
  NULL 

plot5 <- ggplot(dm_lowest2, aes(x = factor(bin), y = dupRate*100)) +
  geom_boxplot(outlier.colour=NA, fill=NA, colour="black") +
  
  geom_point(data = function(x) dplyr::filter_(x, ~ outlier.high ==F & outlier.low == F),
             alpha=0.1,
             color= rep(hue_pal()(20), times =unname(table(dm_lowest2[dm_lowest2$outlier.high == F & dm_lowest2$outlier.low == F ,"bin"]))),
             position=position_jitter(width=0.2, height=0.1)
             ) +
  geom_point(data = function(x) dplyr::filter_(x, ~ outlier.high ==T | outlier.low == T),
             alpha=0.1,
             color= "gray",
             position=position_jitter(width=0.2, height=0.1)
             ) +
  scale_x_discrete(labels = paste0(((unique(dm_lowest2$bin)-1)*5), "-", ((unique(dm_lowest2$bin)-1)*5)+5, "%")) +
  labs(x = "RPK ventile", y= "Percentage of duplicated reads")+
  ggtitle("Duplication-RPK releationship", subtitle = best_sample)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))+
  NULL


cols  <- colorRampPalette(rev(brewer.pal(11,"RdYlBu")))
dcols <- densCols(x=log10(dm_lowest2$RPK),y=(dm_lowest2$dupRate)*100,colramp=cols,nbin=500)

#calculate dupradar fit
fit <- duprateExpFit(dm_lowest2)

plot6 <- ggplot(dm_lowest2) +
  #geom_vline(xintercept = log10(dm_lowest2[(which(dm_lowest2$bin[-1] != dm_lowest2$bin[-length(dm_lowest2$bin)]))+1, "RPK"][[1]]), color = "gray")+
  geom_point(aes(x=log10(RPK), y=dupRate*100 
                 #colour = as.factor(bin),
                 ), alpha=0.1, 
             colour =dcols
             ) + 
  geom_line(aes(x=log10(RPK), y=100*predict(fit$glm,data.frame(x=log10(RPK)),type="response")), color="lightcoral", size=1, lty="dashed") + #this is the dupradar formula
  xlab("log10(RPK)") +
  ylab("Percentage of duplicated reads")+
  ggtitle("Duplication-RPK releationship", 
          subtitle = paste0(best_sample, "\n Intercept: ", round(fit$intercept,2), "; Slope: ", round(fit$slope,2)))+
  #scale_y_log10() +
  #scale_x_log10()+
  geom_vline(xintercept=3, color="red", size=0.5)+
  geom_vline(xintercept=log10(dm_lowest2$RPK[min(which(dm_lowest2[order(dm_lowest2$RPKM), "RPKM"] >= 0.5))]), #this shows the RPK value corresponding to RPKM 0.5
             color="dodgerblue")+
  theme_bw()+
  theme(legend.position = "none")+
  #geom_vline(xintercept = log10(dm_lowest2[(which(dm_lowest2$bin[-1] != dm_lowest2$bin[-length(dm_lowest2$bin)]))+1, "RPK"][[1]]), color = "gray")+
  NULL  

#(plot1 + plot2 + plot3) / (plot1b + plot1c+ plot6) / (plot7 + plot8)

(plot1 + plot2 + plot3 + plot4) / (plot5 + plot6)+
plot_annotation(title = "Duplication rate analysis (dupRadar)",
                subtitle = paste0(best_sample, "\n \n")) &  theme(plot.title = element_text(hjust = 0.5, size=20),
                                                  plot.subtitle = element_text(hjust = 0.5, size=16, color = "gray40"))

```



### Warning: sequence length distribution
<br/>
`r emo::ji("prohibited")` **Warning: sequence length distribution** <br/>
This module raises a warning if all sequences are not the same length.
<br/>

<p class="comment">
Note that this is expected given that FastQC was run on reads that underwent trimming beforehand. 
<br/>
</p>
<br/>

```{r, echo=FALSE, fig.width=6, fig.height=3}
#let us replot the length distribution from the QC reports

#create empty summary dataframe that will contain the data from all the samples
length_distribution <- data.frame()

#loop through each object to extract information
for (i in QC_objects) {
    tmp_df <- i[["sequence_length_distribution"]]
    tmp_df$sample <- str_extract(i[["summary"]][["sample"]][1], "(?<=trimmed_LTS22_).*(?=R*_)")#add label with sample names
    tmp_df$lane <- paste0("L", str_extract_all(i[["basic_statistics"]][[1, 2]], "\\d+", simplify = TRUE)[4])
    length_distribution <- rbind(length_distribution,tmp_df) #save the temporary dataframe for this sample into the summary dataframe
    }

#Add descriptive label besides the sample code provided by the sequencing platform
#generate a conversion dictionary

#set levels of ggplot
length_distribution$Length <- factor(length_distribution$Length, levels =  QC_objects[[1]][["sequence_length_distribution"]]$Length  )

#plot the GC content data, coloured by sample
ggplot(length_distribution, aes(x=Length, y=Count)) +
  geom_point(alpha=0.04) + 
  theme_classic()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="gray80"))+
  theme(legend.position="none")+
  ggtitle("Per-sequence length distribution") +
  xlab("Sequence length (bp)") + 
  ylab("Counts")+
  #geom_vline(xintercept = 55, linetype="dashed", color = "gray")+
  #geom_vline(xintercept = 39, linetype="dashed", color = "gray")+
  NULL
  
#remove unused variables
#rm(GC_content, tmp_df)
```



### Sample contamination (FastQScreen)

<br/>
**Sample contamination (FastQScreen)**
<br/>

As a further quality control step to detect sample contamination, trimmed reads were also run through FastQ Screen v0.15.2  (RRID:SCR_000141; Wingett, Andrews, 2018) with default parameters, against a manually curated set of genomes including â€” in addition to default ones â€” those of other fish species used by neighbouring laboratories (goldfish  Carassius auratus: ASM336829v1, carp  Cyprinus carpio: ASM1834038v1, zebrafish Danio rerio: GRCz11), the three main live foods fed to our fish (Artemia franciscana: AFR02, Brachionus rotundiformis: ASM1680229v1, Chlorella vulgaris: cvul), and additional possible contaminating species (ant Formica exsecta: ASM365146v1). All FastQ Screen genomes were indexed with bowtie2 as per FastQ Screen recommendation. <br/>

__Below â€” and for each treatment â€” an overview of the percentage of reads belonging to each species, in each of the samples.__ 

<p class="comment">
As can be seen for most samples there is mimimal sample contamination (non-clownfish reads), and contaminating reads (usually less than 2% of all reads) can be accounted for and belong to the _Artemia franciscana_ nauplii we feed the larvae with (red). While we do note that one specific larva in the CPF+T3IOP condition has relatively high percentage of non-clownfish (artemia) reads (10%), overall we consider our dataset to not require further intervention. 
<br/>
</p>
<br/>

```{r, echo=FALSE, include=FALSE}
#locate all FastQScreen files
path_to_FastQscreen_output <- "Z://05_OIST_data/Mathieu/02c_trimmed_polyg_FastQscreen_reports"
FastQscreen_files <- list.files(path = path_to_FastQscreen_output, pattern = "*screen.txt", full.names = TRUE, recursive = TRUE)

#extract the file labels
file_labels <- str_extract(basename(FastQscreen_files), "(?<=trimmed_polyg_LTS23_).*(?=R*_)")

#prepare summary table that will be populated with all FastQScreen values of interest
summary_table <- data.frame("Genome" =NA, "Percentage_One_hit_one_genome"=NA, "Sample" = NA)
summary_table <- na.omit(summary_table)


for (i in 1:length(FastQscreen_files)) {
  lines <- read_lines(FastQscreen_files[i], skip=2, n_max = 12) #in our case, FastQScreen was run against a total of 18 possible contaminant genomes, but we will here load only the data from the first 12
  table <- read.table(text=lines)
  colnames(table) <- c("Genome", "Reads_processed",	"#Unmapped",	"%Unmapped",	"#One_hit_one_genome",	"Percentage_One_hit_one_genome",	"#Multiple_hits_one_genome",	"%Multiple_hits_one_genome",	"#One_hit_multiple_genomes",	"%One_hit_multiple_genomes",	"Multiple_hits_multiple_genomes",	"%Multiple_hits_multiple_genomes"	)
  
  table$Sample <- toString(file_labels[i])
  table <- table[c("Genome","Percentage_One_hit_one_genome","Sample")]
  table$Percentage_One_hit_one_genome <- (table$Percentage_One_hit_one_genome/max(table$Percentage_One_hit_one_genome))*100
  
  table <- table[order(table$Percentage_One_hit_one_genome),]
  table$Var <- c(table$Percentage_One_hit_one_genome[1],diff(table$Percentage_One_hit_one_genome))
  table$Genome <- factor(table$Genome, levels =c("Clownfish","Artemia", "Brachionus", "Chlorella", "Goldfish", "Carp","Zebrafish","Ant", "Human", "Mouse", "Rat", "Drosophila"))
  table <- table[order(table$Genome),]
  
  summary_table <- rbind(summary_table, table)
}


summary_table$Genome <- factor(table$Genome, levels =c("Clownfish","Goldfish", "Carp", "Zebrafish", "Artemia", "Brachionus","Chlorella","Human", "Mouse", "Rat", "Ant", "Drosophila"))

#save(summary_table, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/FastQScreen_summary_table.rds")
```


```{r, fig.width=20, fig.height=20, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/FastQScreen_summary_table.rds")
#Plot the FastQscreen data:

#select the colors to use for each species:
mycolors_fastQ <- c("gray50", "dodgerblue", "dodgerblue", "dodgerblue",
                    "indianred1", "sandybrown", "mediumseagreen",
                    "dodgerblue", "dodgerblue", "dodgerblue", "dodgerblue", "dodgerblue")

# Stacked barplot with multiple groups (DMSO)
plot1 <- ggplot(data=summary_table[summary_table$Sample %in% file_labels[1:40],], aes(x=fct_inorder(Sample), y=Var, fill=Genome)) + #fct_inorder so libraries are in sequence as mentioned
  geom_bar(stat="identity", position=position_dodge())+
  theme_light()+theme(panel.border = element_rect(color="gray70", fill=NA, linewidth= 2))+
  #scale_fill_manual(values=c('#f80000','#f8f8f8'))+
  #scale_fill_brewer(palette="Spectral")+
  xlab("Library") + 
  ylab("Percentage of one hit / one genome")+
  ggtitle("DMSO samples: \n Mapping of reads vs different genomes")+
  scale_fill_manual(values = mycolors_fastQ)+
  facet_zoom(ylim = c(0, 3))+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="gray30", size=6))+
  NULL


# Stacked barplot with multiple groups (T3IOP)
plot2 <- ggplot(data=summary_table[summary_table$Sample %in% file_labels[41:80],], aes(x=fct_inorder(Sample), y=Var, fill=Genome)) + #fct_inorder so libraries are in sequence as mentioned
  geom_bar(stat="identity", position=position_dodge())+
  theme_light()+theme(panel.border = element_rect(color="palegreen3", fill=NA, linewidth= 2))+
  #scale_fill_manual(values=c('#f80000','#f8f8f8'))+
  #scale_fill_brewer(palette="Spectral")+
  xlab("Library") + 
  ylab("Percentage of one hit / one genome")+
  ggtitle("T3IOP samples: \n Mapping of reads vs different genomes")+
  scale_fill_manual(values = mycolors_fastQ)+
  facet_zoom(ylim = c(0, 3))+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="gray30", size=6))+
  NULL


# Stacked barplot with multiple groups (MPI)
plot3 <- ggplot(data=summary_table[summary_table$Sample %in% file_labels[81:120],], aes(x=fct_inorder(Sample), y=Var, fill=Genome)) + #fct_inorder so libraries are in sequence as mentioned
  geom_bar(stat="identity", position=position_dodge())+
  theme_light()+theme(panel.border = element_rect(color="lightcoral", fill=NA, linewidth= 2))+
  #scale_fill_manual(values=c('#f80000','#f8f8f8'))+
  #scale_fill_brewer(palette="Spectral")+
  xlab("Library") + 
  ylab("Percentage of one hit / one genome")+
  ggtitle("MPI samples: \n Mapping of reads vs different genomes")+
  scale_fill_manual(values = mycolors_fastQ)+
  facet_zoom(ylim = c(0, 3))+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="gray30", size=6))+
  NULL

# Stacked barplot with multiple groups (MPI)
plot4 <- ggplot(data=summary_table[summary_table$Sample %in% file_labels[121:160],], aes(x=fct_inorder(Sample), y=Var, fill=Genome)) + #fct_inorder so libraries are in sequence as mentioned
  geom_bar(stat="identity", position=position_dodge())+
  theme_light()+theme(panel.border = element_rect(color="lightskyblue", fill=NA, linewidth= 2))+
  #scale_fill_manual(values=c('#f80000','#f8f8f8'))+
  #scale_fill_brewer(palette="Spectral")+
  xlab("Library") + 
  ylab("Percentage of one hit / one genome")+
  ggtitle("CPF samples: \n Mapping of reads vs different genomes")+
  scale_fill_manual(values = mycolors_fastQ)+
  facet_zoom(ylim = c(0, 3))+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="gray30", size=6))+
  NULL

# Stacked barplot with multiple groups (MPI)
plot5 <- ggplot(data=summary_table[summary_table$Sample %in% file_labels[161:200],], aes(x=fct_inorder(Sample), y=Var, fill=Genome)) + #fct_inorder so libraries are in sequence as mentioned
  geom_bar(stat="identity", position=position_dodge())+
  theme_light()+theme(panel.border = element_rect(color="orchid2", fill=NA, linewidth= 2))+
  #scale_fill_manual(values=c('#f80000','#f8f8f8'))+
  #scale_fill_brewer(palette="Spectral")+
  xlab("Library") + 
  ylab("Percentage of one hit / one genome")+
  ggtitle("CPF+T3IOP samples: \n Mapping of reads vs different genomes")+
  scale_fill_manual(values = mycolors_fastQ)+
  facet_zoom(ylim = c(0, 15))+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, color="gray30", size=6))+
  NULL

grid.arrange(plot1, plot2, plot3, plot4, plot5, ncol=1, nrow=5)

```


### Packages used

```{r, echo=FALSE}
sessionInfo()
```



## {-}

***
__Analysis Notebook__<br />
_Reynaud, Vianello, et al. "The multi-level effect of chlorpyrifos during clownfish metamorphosis"_<br /><br />
_RNotebook by Stefano Vianello, Marine Eco-Evo-Devo unit, Academia Sinica Marine Research Station_ <br />
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a> with the additional reservation of the rights to non-human text and data mining, AI training, and similar technologies, which are not granted. <br/><br />
<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a> <br />


