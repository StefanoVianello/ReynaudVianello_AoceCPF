---
title: "&nbsp;"
#authors: Stefano Vianello, Marine Eco-Evo-Devo Unit, Academia Sinica Marine Research Station
#from data from Mathieu Reynaud and Fiona Lee
#date: 2022

output:
  html_notebook: 
    css: style.css
    toc: true
    toc_float: true
  html_document:
    css: style.css
    df_print: paged
  pdf_document: default
---

![](C:\Users\Doctor\Pictures\clownfish_banner.PNG) 

## Analysis Notebook {.tabset}

### Introduction to the dataset and experimental design 
<br/>
<br/>

:::demo
This Rmarkdown notebook describes the analysis of bulkRNAseq data of *Amphiprion ocellaris* larvae treated with a selection of drugs from 8dph to 13dph (5 days total), i.e. until control larvae had metamorphosed. The aim of the experiment was to detect the general effects of the organophosphate pesticide Chlorpyrifos (CPF) on clownfish larvae as they undergo metamorphosis, and specifically on their thyroid hormone signalling pathway. *n=10* larvae were  collected  at the end of each of the 5 treatments (i.e. at 13dph), RNA was extracted from each larva, and RNA was sequenced (total *n=50*). **Treatments**: DMSO (control), T3+IOP (positive control, induction of metamorphosis), MPI (negative control, blockade of metamorphosis), CPF (test drug), CPF+T3+IOP. 
:::

<br/>
<br/>
![](C:\Users\Doctor\Pictures\CPF_experimental_design.PNG)


```{r, eval=TRUE, include=FALSE, echo=FALSE}
## Install the following packages on your machine, if these have not been installed already
# Note: only need to run this cell if you have never run this code on this machine

if (!requireNamespace("BiocManager"))
    install.packages("BiocManager")

BiocManager::install(c("limma", "edgeR", "GenomicFeatures", "tximport", "DESeq2", "ComplexHeatmap", "clusterProfiler", "mgsa"))
install.packages(c("jsonlite", "formattable", "magrittr", "tidyverse", "ggforce", "grid", "gridExtra", "gridBase", "kneedle", "knitr", "RColorBrewer", "dendextend", "ggrepel", "ggalt", "factoextra", "cowplot", "ggpubr", "ggVennDiagram", "venneuler"))
```


```{r, eval=TRUE, include=FALSE, message = T, echo=FALSE}
# #Load libraries from installed packages
# Note: you need to run this cell every time you start a new R session
library(jsonlite)
library(formattable)
library(GenomicFeatures)
library(tximport)
library(edgeR)
library(magrittr)
library(tidyverse)
library(ggforce)
library(grid)
library(gridExtra)
library(DESeq2)
library(RColorBrewer)
library(gridBase)
library(kneedle)
library(knitr)
library(ComplexHeatmap)
library(dendextend)
library(ggrepel)
library(ggalt)
library(factoextra)
library(cowplot)
library(ggpubr)
library(clusterProfiler)
library(ggVennDiagram)
library(mgsa)
library(venneuler)
```


### Gene level read quantification

#### {.tabset}
##### Importing counts and sample metadata 
<br/>
__Step 1:__ We start by creating a data-table summarising sample metadata

```{r, echo=FALSE}
samples <- data.frame(matrix(ncol = 6, nrow = 100)) 
# assign titles to the columns
column_titles <- c("filename", "lib_id","lane", "treatment", "original_larval_id", "label")
colnames(samples) <- column_titles
# clean up unused variables
rm(column_titles)

#note: "filename" must be the name of the salmon quantification folder
samples$filename <- c("LTS23_FZ01_S1_L001","LTS23_FZ01_S1_L002",
                      "LTS23_FZ02_S2_L001","LTS23_FZ02_S2_L002",
                      "LTS23_FZ03_S3_L001","LTS23_FZ03_S3_L002",
                      "LTS23_FZ04_S4_L001","LTS23_FZ04_S4_L002",
                      "LTS23_FZ05_S5_L001","LTS23_FZ05_S5_L002",
                      "LTS23_FZ06_S6_L001","LTS23_FZ06_S6_L002",
                      "LTS23_FZ07_S7_L001","LTS23_FZ07_S7_L002",
                      "LTS23_FZ08_S8_L001","LTS23_FZ08_S8_L002",
                      "LTS23_FZ09_S9_L001","LTS23_FZ09_S9_L002",
                      "LTS23_FZ10_S10_L001","LTS23_FZ10_S10_L002",
                      "LTS23_FZ11_S11_L001","LTS23_FZ11_S11_L002",
                      "LTS23_FZ12_S12_L001","LTS23_FZ12_S12_L002",
                      "LTS23_FZ13_S13_L001","LTS23_FZ13_S13_L002",
                      "LTS23_FZ14_S14_L001","LTS23_FZ14_S14_L002",
                      "LTS23_FZ15_S15_L001","LTS23_FZ15_S15_L002",
                      "LTS23_FZ16_S16_L001","LTS23_FZ16_S16_L002",
                      "LTS23_FZ17_S17_L001","LTS23_FZ17_S17_L002",
                      "LTS23_FZ18_S18_L001","LTS23_FZ18_S18_L002",
                      "LTS23_FZ19_S19_L001","LTS23_FZ19_S19_L002",
                      "LTS23_FZ20_S20_L001","LTS23_FZ20_S20_L002",
                      "LTS23_FZ21_S21_L001","LTS23_FZ21_S21_L002",
                      "LTS23_FZ22_S22_L001","LTS23_FZ22_S22_L002",
                      "LTS23_FZ23_S23_L001","LTS23_FZ23_S23_L002",
                      "LTS23_FZ24_S24_L001","LTS23_FZ24_S24_L002",
                      "LTS23_FZ25_S25_L001","LTS23_FZ25_S25_L002",
                      "LTS23_FZ26_S26_L001","LTS23_FZ26_S26_L002",
                      "LTS23_FZ27_S27_L001","LTS23_FZ27_S27_L002",
                      "LTS23_FZ28_S28_L001","LTS23_FZ28_S28_L002",
                      "LTS23_FZ29_S29_L001","LTS23_FZ29_S29_L002",
                      "LTS23_FZ30_S30_L001","LTS23_FZ30_S30_L002",
                      "LTS23_FZ31_S31_L001","LTS23_FZ31_S31_L002",
                      "LTS23_FZ32_S32_L001","LTS23_FZ32_S32_L002",
                      "LTS23_FZ33_S33_L001","LTS23_FZ33_S33_L002",
                      "LTS23_FZ34_S34_L001","LTS23_FZ34_S34_L002",
                      "LTS23_FZ35_S35_L001","LTS23_FZ35_S35_L002",
                      "LTS23_FZ36_S36_L001","LTS23_FZ36_S36_L002",
                      "LTS23_FZ37_S37_L001","LTS23_FZ37_S37_L002",
                      "LTS23_FZ38_S38_L001","LTS23_FZ38_S38_L002",
                      "LTS23_FZ39_S39_L001","LTS23_FZ39_S39_L002",
                      "LTS23_FZ40_S40_L001","LTS23_FZ40_S40_L002",
                      "LTS23_FZ41_S41_L001","LTS23_FZ41_S41_L002",
                      "LTS23_FZ42_S42_L001","LTS23_FZ42_S42_L002",
                      "LTS23_FZ43_S43_L001","LTS23_FZ43_S43_L002",
                      "LTS23_FZ44_S44_L001","LTS23_FZ44_S44_L002",
                      "LTS23_FZ45_S45_L001","LTS23_FZ45_S45_L002",
                      "LTS23_FZ46_S46_L001","LTS23_FZ46_S46_L002",
                      "LTS23_FZ47_S47_L001","LTS23_FZ47_S47_L002",
                      "LTS23_FZ48_S48_L001","LTS23_FZ48_S48_L002",
                      "LTS23_FZ49_S49_L001","LTS23_FZ49_S49_L002",
                      "LTS23_FZ50_S50_L001","LTS23_FZ50_S50_L002")
samples$lib_id <- substr(samples$filename, 1, 10)
samples$lane <- rep(c("1","2"), 25)

#create the column with the treatment information and set the levels
samples$treatment <- c(rep("DMSO", 20), rep("T3IOP", 20), rep("MPI", 20), rep("CPF", 20), rep("CPF.T3IOP", 20))
samples$treatment <- as.factor(samples$treatment)
samples$treatmen <- factor(samples$treatmen, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP"))

samples$larva <- rep(seq(1:10), 5, each=2)

samples$label <- paste(samples$treatment, samples$larva, sep = "_")
samples$label <- paste(samples$label, samples$lane,sep = "_L00")

#add the column with the original id from the larvae, to be able to link to exact picture
samples$original_larval_id <- rep(c(1, 2, 3, 6, 7, 8, 9, 10, 11, 12,
                                    1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                                    1, 2, 3, 4, 8, 9, 10, 11, 13, 14,
                                    1, 2, 3, 4, 5, 6, 7, 10, 11, 12,
                                    1, 3, 4, 8, 9, 10, 11, 13, 14, 15), each=2)
samples$original_larval_id <- as.character(samples$original_larval_id)
#remove the column "larva"
samples <- samples[, c(1:6)]

samples
```

```{r, echo=FALSE}
ordered_levels <- samples$label
```

```{r, echo=FALSE, include=FALSE}
files <- file.path("Z://05_OIST_data/Mathieu/03_salmon_quantification_GCF022539595",
                   paste0(samples$filename, "_transcriptsQuantification"), "quant.sf")
names(files) <- samples$label

#check that all the folders have a quant file inside
all(file.exists(files))
#print list of files
as.data.frame(files)
```


<br/>
__Step 2:__ we will take the chance here to create another quality control step: the number or reads processed and the number + percentage of those reads that could be mapped by salmon. 

```{r, echo=FALSE}
#This information is stored in the /aux_info folder of each salmon quant folder, file "meta_info.json"

files_meta <- file.path("Z://05_OIST_data/Mathieu/03_salmon_quantification_GCF022539595",
                   paste0(samples$filename, "_transcriptsQuantification"), "aux_info/meta_info.json")
names(files_meta) <- samples$label

#check that all the folders have a quant file inside
#all(file.exists(files_meta))
#print list of files
#as.data.frame(files_meta)


## after having made sure that all json files exist, load them into Rstudio

total_reads <- ls()
mapped_reads <- ls()
for (i in seq(1:length(files_meta))) {
  total_reads[i] <- fromJSON(files_meta[i], flatten=TRUE)[["num_processed"]]
  mapped_reads[i] <- fromJSON(files_meta[i], flatten=TRUE)[["num_mapped"]]
}

summary_table <- data.frame("total_reads" = as.numeric(total_reads), "mapped_reads" = as.numeric(mapped_reads))
summary_table$percentage_mapped <- round((summary_table$mapped_reads / summary_table$total_reads)*100, digits = 2)
summary_table$sample <- samples$label
summary_table <- summary_table[, c("sample", "total_reads", "mapped_reads", "percentage_mapped")]

#kable(summary_table, caption = "Summary statistics for the mapping of each sample (Aoce genome: ASM2253959v1)")

customRange = c(0, 100) # custom min / max values
colors      = csscolor(gradient(as.numeric(c(customRange, summary_table$percentage_mapped)), "orange", "#71CA97"))
colors      = colors[-(1:2)] ## remove colors for min/max

fmt    = formatter("span", 
                   style = function(x){
                     style(display            = "block",
                           padding            = "0 4px",
                           `border-radius`    = "4px",
                           `background-color` = colors
                           )})


formattable(summary_table, 
             caption ="Summary statistics for the mapping of each sample (Aoce genome: ASM2253959v1)",
            align =c("l","c", "c", "c"), 
            list(`sample` = formatter("span", 
                                      style = x ~ style(
                                        #color =  ifelse(x == summary_table[summary_table$percentage_mapped == max(summary_table$percentage_mapped),"sample"], "#71CA97", ifelse(x == summary_table[summary_table$percentage_mapped == min(summary_table$percentage_mapped),"sample"], "lightcoral", "gray")),
                                        color = rep(c("#A9A9A9","#7CCD7C","lightcoral", "lightskyblue", "#EE7AE9"),
                  each=20),
                                                        font.weight = "bold"),
                                      x ~ icontext(ifelse(x == summary_table[summary_table$mapped_reads == max(summary_table$mapped_reads),"sample"], "star", ifelse(x == summary_table[summary_table$mapped_reads == min(summary_table$mapped_reads),"sample"], "star-empty", "")), x)
                                      ), 
                 `total_reads`= color_tile("orange", "#71CA97"),
                 #`mapped_reads`= color_tile("orange", "#71CA97"),
                 `mapped_reads`= fmt,
                 #`percentage_mapped`= color_tile(NA, "#71CA97")
                 `percentage_mapped`= fmt

                 )
            )

```


```{r, echo=FALSE}
paste("Expected number of total reads/lane (P3cell): ", 1400/nrow(summary_table), "millions")
paste("Median number of total reads/lane: ", round(median(summary_table$total_reads)/1000000, digits = 2) , "millions")
paste("Median number of mapped reads/lane: ", round(median(summary_table$mapped_reads)/1000000, digits = 2), "millions")
paste("Average mapping percentage/lane: ", round(mean(summary_table$percentage_mapped), digits=2), "%")
```

<br/>
__Step 3:__ Transcripts need to be associated with gene IDs for gene-level summarization. For Salmon, Sailfish, and kallisto the files only provide the transcript ID. We first make a data.frame called tx2gene with two columns: 1) transcript ID and 2) gene ID. The column names do not matter but this column order must be used. The transcript ID must be the same one used in the abundance files.

```{r, echo=FALSE}
#I am using a NCBI genome

txdb <- makeTxDbFromGFF( file = "Y://bulkRNAseq/GCF_022539595.1/genomic.gff", format = "gff" , 
                         dbxrefTag = "GeneID" #adding this tag means that the name of the genes will be their NCBI code, rather than the symbol
                         )
columns(txdb)

k <- biomaRt::keys(txdb, keytype = "TXNAME" )
tx2gene <- biomaRt::select( txdb, k, "GENEID", "TXNAME" )

#the first row is NA for some reason
tx2gene <- tx2gene[-1,]
#I also need to remove the transcript version number
tx2gene$TXNAME <- gsub("\\..*","",tx2gene$TXNAME)
#we also need to remove the "GeneID:" before every NCBI code in the gene name
tx2gene$GENEID <- gsub(".*:","",tx2gene$GENEID)

head(tx2gene)
```

Salmon output transcript-based quantification files (quant.sf) are imported in RStudio and summarised at the gene level using the tximport function from the tximport package (RRID:SCR_016752; Soneson et al., 2015), referencing the gene models of Amphiprion ocellaris reference genome assembly ASM2253959v1. The counts matrix is obtained by re-calculating counts through the flag countsFromAbundance = "lengthScaledTPM".

```{r, echo=FALSE}
txi <- tximport(files, type = "salmon", 
                tx2gene = tx2gene, 
                ignoreTxVersion = TRUE,  
                countsFromAbundance = "lengthScaledTPM")
```
Giving the following count matrix (first rows only, shown here)

```{r, echo=FALSE}
head(txi$counts)
```

##### Asembling the DGE object

<br/>
__Step 1:__ We first collect the file with the sample metadata (as created earlier)

```{r, include=TRUE, eval=TRUE, echo=FALSE}
## create a new file called "sample info"
sample_info <- samples

#show our final "sample info" file
sample_info
```

<br/>
__Step 2:__ We then collect the counts matrix as imported from Salmon with tximport

```{r, include=TRUE, echo=FALSE}
## Let’s create a new data object, "counts", that contains only the counts for the 9 samples.
# From the original raw counts file, remove columns 2 to 9 
# (this will create a table with only the emsembleID and the count columns of each sample)
counts <- as.data.frame(txi$counts)

#show our final "counts" file
head(counts)

#remove unused variables
rm(samples, tx2gene, txi, files)
```

<br/>
__Step 3:__ Now, we can create a DGEList object. This is an object used by edgeR to store count data. It has a number of slots for storing various parameters about the data.

```{r, echo=FALSE, results='hide'}
## create the new DGE object
DGE_object <- DGEList(counts, #load the raw counts matrix
                      samples=sample_info #keep sample as last column #load the complementary info (make sure you are including all the possible sources of technical variation that could cluster samples instead of the genes)
                      )
# The data has been imported, and the objects calculated library size info. 
# Show the information stored in the "samples" DGEobject slot
DGE_object$samples #also accessible through y[["samples"]]

##remove unused variables
rm(sample_info)
```


```{r, echo=FALSE}
## Do some rearrangement and cleanup of the information we have loaded in the DGE object "samples" slot
# To facilitate working on the "samples" slot, we will extract it and work on it as a separate dataframe
temporary_samples_slot <- DGE_object[["samples"]]

# creating the DGEobject added a "group" column by default
# replace the #group" values with the sample information (i.e. we will group as C01, C02, etc..)
# convert the "group" column to numeric datatype 
temporary_samples_slot$group <- as.numeric(as.character(temporary_samples_slot$group))
#lets replace the default values with what we want (C01, C02, etc.. : the sample names)
for (i in 1:length(rownames(temporary_samples_slot))) {
  temporary_samples_slot[i,"group"] <- # the "group" value at each row is...
      temporary_samples_slot[i,"label"] # the value of the "sample column"
}  
# restore the "group" column to a factor datatype
temporary_samples_slot$group <- as.factor(temporary_samples_slot$group)
# cleanup columns (we do not need the "sample" column anymore)
temporary_samples_slot <- temporary_samples_slot[,-length(temporary_samples_slot)] #i.e. remove last column
# reorder columns
temporary_samples_slot <- dplyr::select(temporary_samples_slot, "group", "treatment", "lane", "original_larval_id", "lib_id","lib.size", "norm.factors")

## Put back updated sample slot into DGE object
DGE_object[["samples"]] <- temporary_samples_slot

# removed unused variables
rm(temporary_samples_slot, i)

#show the final "samples" slot of our DGEobject
DGE_object[["samples"]]

#save this updated sample metadata for later
sample_metadata <- DGE_object[["samples"]]
```

```{r, echo=FALSE}
#save this object, for later subsetting
#save(DGE_object, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/DGE_object.rds")
```

<br/>
__Step 4:__ We then collect the last missing piece of information, the gene metadata info (in this case, it is loaded from a custom-curated reference file based on the integration of Ensembl (still based on assembly AmpOce1.0) and NCBI annotations )

```{r, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/DGE_object.rds")
```


```{r, echo=FALSE}
#the table with the annotation information of each gene (with manual curation of the description), was made in a separate notebook (cfr "Aocellaris_annotationinfo_maker.Rmd) and saved as a R object which we will load here. #annotation_info_NCBIEnsembl
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated.rds") 

#rename the dataframe as "annotation_info"
annotation_info <- annotation_info_NCBIEnsembl
#remove the column with the original description
#annotation_info <- subset(annotation_info, select = -c(original_description))

#remove unused variables
rm(annotation_info_NCBIEnsembl)
```


```{r, echo=FALSE, results='hide'}
#are there any NA values in entrez IDs?
summary(is.na(annotation_info$entrez_ID)) #29130

#check that there are no duplicated entrez ID
summary(duplicated(annotation_info$entrez_ID)) # no 29130
```

<br/> we loaded this information too into the DGE_list object, after manual annotation of some genes, and filling in of missing values.

```{r, echo=FALSE}
#we can find genes that are present in our dataset, but are not in the annotation file
missing_genes <- rownames(DGE_object$counts)[(rownames(DGE_object$counts) %in% annotation_info$entrez_ID) == FALSE]
#missing_genes
# there are no genes with missing annotation

#check the reverse: how many genes in the annotation are present in the counts quantification
# how many genes in the object?
length(rownames(counts)) #26889 out of 29130
summary(annotation_info$entrez_ID %in% rownames(counts)) #yes 26889 (same number); proving that there are no errors in the metadata file
#check that the order of these genes with the order of the rownames of the count object
#test <- annotation_info[annotation_info$entrez_ID %in% rownames(counts),]
#counts

# just as we did for the cleaned raw counts matrix data, we can insert this annotation data into the DGE object
#DGE_object$genes <- annotation_info #this create a new slot ("genes") in the dataobject
DGE_object$genes <- annotation_info[annotation_info$entrez_ID %in% rownames(counts),] # only consider genes in counts

# show this new slot "genes" of the annotation info
DGE_object$genes
```

#### {-} 

### Quality Control and Filtering of lowly expressed genes

```{r, echo=FALSE}
#ordered by segment and then by stage
color_list <- rep(c("gray70","palegreen3","lightcoral", "lightskyblue", "orchid2"),
                  each=20)

color_categorical_treatment<-c("gray70","palegreen3","lightcoral", "lightskyblue", "orchid2")
color_categorical_lane<- c("gray", "lightcoral")

ordered_levels <- DGE_object[["samples"]]$group
```

##### __Quality Control of imported data__
How is count data distributed? not normally, as shown by the plot below. Moreover, the variance is bigger than the mean, meaning that a negative binomial, rather than a poisson, describes count data.

```{r, echo=FALSE, warning=FALSE ,fig.width=12, fig.height=8}
#https://hbctraining.github.io/DGE_workshop/lessons/01_DGE_setup_and_overview.html#rna-seq-count-distribution


#get the raw counts
counts_raw  <- DGE_object$counts #this is the same as doing cpm(counts) and log2 of it

#prepare for ggplot
#make gene codes as columns
counts_raw <- as.data.frame(counts_raw)
counts_raw <- cbind(ensembl_id = rownames(counts_raw), counts_raw)

counts_raw <- counts_raw %>% 
  pivot_longer(
    cols = !ensembl_id, 
    names_to = "sample", 
    values_to = "count"
  )

#plot
plot1 <- ggplot(counts_raw, aes(x=count)) +
  geom_histogram(stat = "bin", bins = 1000, fill="dodgerblue") +
  xlab("raw counts") +
  ylab("number of genes \n with given expression")+
  ggtitle("distribution of raw counts")+
  #ylim(0,20000)+
  theme_bw()+
  #theme(legend.position = "none")+
  NULL

plot3 <- ggplot(counts_raw, aes(x=count)) +
  geom_histogram(stat = "bin", bins = 5000, fill="dodgerblue") +
  xlab("raw counts") +
  ylab("number of genes \n with given expression")+
  ggtitle("distribution of raw counts", subtitle = "most genes have few counts")+
  theme_bw()+
  facet_zoom(xlim = c(0, 10000), ylim = c(0, 1000))+
  #theme(legend.position = "none")+
  NULL

plot4<- ggplot(counts_raw, aes(x=count)) +
  geom_histogram(stat = "bin", bins = 5000, fill="dodgerblue") +
  xlab("raw counts") +
  ylab("number of genes \n with given expression")+
  ggtitle("distribution of raw counts", subtitle = "very few genes have high counts")+
  theme_bw()+
  facet_zoom(ylim = c(0, 5))+
  #theme(legend.position = "none")+
  NULL

## a poisson distribution should approximate rna expression data, however, variation between samples (even within the same condition), i.e. biological variability, means that variance is often not == mean (which is what Poisson is based one). In fact, the variance is increased, and is not even constant (it is the higher in highly expressed genes). Hence why possion-based modelling can only be used when analysing single replicates. Negative binomial represents the best choice for data with more than one replicate. This is what edgeR and Deseq use.  
#get the raw counts
counts_raw  <- DGE_object$counts #this is the same as doing cpm(counts) and log2 of it

#prepare for ggplot
#make gene codes as columns
counts_raw <- as.data.frame(counts_raw)

mean_counts <- apply(counts_raw[, 1:10], 1, mean)
variance_counts <- apply(counts_raw[, 1:10], 1, var)
df <- data.frame(mean_counts, variance_counts)

plot2 <- ggplot(df) +
  geom_point(aes(x=mean_counts, y=variance_counts), alpha=0.2) + 
  geom_line(aes(x=mean_counts, y=mean_counts), color="dodgerblue") +
  xlab("mean raw counts") +
  ylab("variance")+
  ggtitle("Mean-Variance relearionship (raw counts, DMSO)", subtitle = "the variance of each gene is generally higher than its mean")+
  scale_y_log10() +
  scale_x_log10()+
  theme_bw()+
  NULL  
    
grid.arrange(plot1, plot2, plot3, plot4, ncol=2, nrow=2)

rm(plot1, plot2, plot3, plot4, counts_raw, df, mean_counts, variance_counts)
```

##### __CPM__

Count data is not normally distributed, so if we want to examine the distributions of the raw counts we need to log the counts. Next we’ll use box plots to check the distribution of the read counts on the log2 scale. We can use the cpm function to get log2 counts per million, which are corrected for the different library sizes. The cpm function also adds a small offset (0.25) to avoid taking log of zero.

Below, a comparison between gene counts before and after log transformation and Counts per Million (to account for different library sizes). The distribution of the counts is shown as a density plot bottom right. <span style="color:#b3b3b3">Control</span>, <span style="color:#7ccd7c">T3</span> , <span style="color:#f08080">MPI</span> , <span style="color:#87cefa">CPF</span> , <span style="color:#ee7ae9">CPF+T3</span>. <br/>
```{r, fig.width=15, fig.height=10, echo=FALSE}
#set space for three plots
par(mfrow=c(2,2))

# get the data as (log2) counts per million
counts_CPMlog2  <- cpm(DGE_object,log=TRUE) #this is the same as doing cpm(counts) and log2 of it

# Just for reference, plot the distribution of previous raw data counts (here on log scale)
boxplot(log2(as.matrix(DGE_object)+0.25), #this will use the "counts" slot = doing it on "counts"
        xlab="", 
        ylab="Log2 counts (raw data + 0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median value
abline(h=log2(median(DGE_object$counts)+0.25),col="blue")
title("Boxplots of logcounts (raw data, unnormalised)")


# Plot the distributions of the(log2) counts per million
boxplot(counts_CPMlog2,                                    #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million +0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2),col="blue")
title("Boxplots of logCPMs (unnormalised)")

#From the boxplots we see that overall the density distributions of raw log-intensities are not very different. If a sample is really far above or below the blue horizontal line we may need to investigate that sample further. Another kind of QC plot that is helpful in checking for dodgy samples is a relative log expression (RLE) plot, which can be generated with plotRLE from the EDASeq package.



# The DGEobject already calculated library sizes automatically, and stores that value in the "samples" slot
# Since CPM adjusts for library size differemces, show these library sizes
# plot the library sizes of all the samples
#check for big discrepancies between samples
barplot(DGE_object$samples$lib.size /1e06,           # divide by millions to just plot in millions
        names=colnames(DGE_object),                  # use sample names as labels
        las=2,                                       # The "las" argument rotates the axis names
        ann=FALSE,
        cex.names=0.75,
        col = color_list,
        border = NA,
        ylim = c(0,15))
mtext(side = 1, text = "", line = 4)
mtext(side = 2, text = "Library size (millions)", line = 3)
title("Library sizes (raw data)")


## Check distributions of measured expression values using lineplots

# Check distributions of measured expression values using lineplots
plot(density(counts_CPMlog2[, 1]), 
     main="",
     xlab="log2(CPM + 0.25)",
     ylab="Density",
     col = color_list[1],
     ylim=range(pretty(c(0, 0.2))))

for (i in 2:dim(counts_CPMlog2)[2]) {
  lines(density(counts_CPMlog2[, i]), 
        col= color_list[i]
        )
  title(main = NULL)
}

title("Density distribution of log2 CPM counts")

## remove unused variables
rm(i)
```

```{r, fig.width=25, fig.height=4, warning=FALSE, echo=FALSE}
## Plot RLE (relative expression level) to check effectiveness of normalisation
# a RLE plot is, on log counts, the deviation of each gene recording, to its average across all samples

RLE_counts_forggplot <- sweep(log2(as.data.frame(DGE_object$counts)+0.25), MARGIN=1, STATS= rowMeans(log2(as.data.frame(DGE_object$counts)+0.25)))
RLE_counts_forggplot$genes <- row.names(RLE_counts_forggplot)
RLE_counts_forggplot  <- RLE_counts_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_counts_forggplot$Condition <- factor(RLE_counts_forggplot$Condition, levels =  ordered_levels)

plot1 <- ggplot(RLE_counts_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: rawcounts")+
  NULL

tmp <-as.data.frame(2^(counts_CPMlog2-0.25))
RLE_logCPM_forggplot <- sweep(log2(tmp), MARGIN=1, STATS= rowMeans(log2(tmp))) 
RLE_logCPM_forggplot$genes <- row.names(as.data.frame(RLE_logCPM_forggplot))
RLE_logCPM_forggplot <- RLE_logCPM_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_logCPM_forggplot$Condition <- factor(RLE_logCPM_forggplot$Condition, levels =  ordered_levels)

plot2 <- ggplot(RLE_logCPM_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: logCPMs")+
  NULL

grid.arrange(plot1, plot2, ncol=2, nrow=1)

#remove unused variables
rm(tmp, RLE_counts_forggplot, RLE_logCPM_forggplot, plot1, plot2)
```

<br/>

##### __Determine filtering threshold__

 You should filter with CPMs rather than filtering on the counts directly, as the latter does not account for differences in library sizes between samples.

```{r, echo=FALSE}
# We filter on the counts per million, but not logged so the calculations are more intuitive
# we can either use 2^counts_CPMlog2 (i.e. undoing the log2 that had been applied)
# or create a new object
counts_CPMraw  <- cpm(DGE_object,log=FALSE) #notice how now we are not taking the log
```

Set a CPM threshold that corresponds to a count of 10-15 for the library sizes in your data set (e.g. 0.5 for a library of around 20million). 0.5 COUNTS PER MILLION * 20millions = 10 COUNTS. If the count is any smaller, it is considered to be very low, indicating that the associated gene is not expressed in that sample. 

A requirement for expression in 10 or more libraries is used as each group contains 10 replicates. This ensures that a gene will be retained if it is only expressed in one group. Smaller CPM thresholds are usually appropriate for larger libraries. As a general rule, **a good threshold can be chosen by identifying the CPM that corresponds to a count of 10**.

What counts as "lowly expressed" depends on library size. We will now find library sizes of each sample.
First, we can check how many reads we have for each sample in the DGE object (this is automatic calculated by the DGE object).

```{r, fig.width=10, fig.height=5, echo=FALSE}
# The DGEobject already calculated library sizes automatically, and stores that value in the "samples" slot
# show the library sizes of each sample
DGE_object$samples[,c("group","lib.size")] 

# plot the library sizes of all the samples
#check for big discrepancies between samples
barplot(DGE_object$samples$lib.size /1e06,           # divide by millions to just plot in millions
        names=colnames(DGE_object),                  # use sample names as labels
        las=2,                                       # The "las" argument rotates the axis names
        ann=FALSE, 
        cex.names=0.75,
        col = color_list,
        border = NA,
        ylim = c(0, 15))
mtext(side = 1, text = "Samples", line = 4)
mtext(side = 2, text = "Library size (millions)", line = 3)
title("Library sizes (raw data)")


# Show max, min, and mean library size
cat("The max library size is", max(DGE_object$samples$lib.size) , ": sample", match(max(DGE_object$samples$lib.size), DGE_object$samples$lib.size), ":", rownames(DGE_object$samples)[DGE_object$samples$lib.size == max(DGE_object$samples$lib.size)], "\n")

cat("The mean library size is", mean(DGE_object$samples$lib.size), "\n")

cat("The min library size is", min(DGE_object$samples$lib.size) , ": sample", match(min(DGE_object$samples$lib.size), DGE_object$samples$lib.size), ":", rownames(DGE_object$samples)[DGE_object$samples$lib.size == min(DGE_object$samples$lib.size)], "\n")
```
```{r, echo=FALSE}
## calculate CPM filtering threshold which will correspond to at least 10 CPM in the smallest library (hence in all of them)
filtering_threshold <- 10*10^6/min(DGE_object$samples$lib.size)


cat("The filtering threshold of", filtering_threshold , "has been chosen \n")
```
```{r, fig.width=10, fig.height=5, echo=FALSE}
#set space for two plots
par(mfrow=c(1,2))

# Let's have a look and see whether our filtering threshold does indeed correspond to a count of about 10
# We will look at the sample with the lowest library size (sample C03 in our case)

plot(counts_CPMraw[,match(min(DGE_object$samples$lib.size), DGE_object$samples$lib.size)],
     counts[,match(min(DGE_object$samples$lib.size), DGE_object$samples$lib.size)],          #could just write [,21]
    #counts_CPMraw[,23],
     #counts[,28], 
     ylim=c(0,20),
     xlim=c(0,1.5),
     col = alpha("black", 0.05),
     pch=16,
     ann=FALSE)
mtext(side = 1, text = "Counts per million (raw) in sample with smallest library size", line = 4)
mtext(side = 2, text = "Raw counts in sample with smallest library size", line = 3)
# Add a vertical line at 0.512 CPM
abline(v=filtering_threshold, col="dodgerblue")
# Add a reference line at counts = 10
abline(h=10, col="dodgerblue")


#let's also replot the library sizes
# plot the library sizes of all the samples
barplot(DGE_object$samples$lib.size /1e06,           # divide by millions to just plot in millions
        names=colnames(DGE_object),                  # use sample names as labels
        las=2,                                       # The "las" argument rotates the axis names
        ann=FALSE, 
        cex.names=0.75,
        col = color_list,
        border = NA,
        ylim = c(0,15))
mtext(side = 1, text = "", line = 4)
mtext(side = 2, text = "Library size (millions)", line = 3)
title("Library sizes (raw data)")
```

<br/>

##### __Filter the counts__

```{r}
## Now that we are satisfied with CPM threshold, we can filter the data
# Find CPM values that are greater than the threshold established above
above_threshold <- counts_CPMraw > filtering_threshold
# This produces a logical matrix with TRUEs and FALSEs

# we would like to keep genes that have at least 2 TRUES in each row of "above_threshold"
keep <- rowSums(above_threshold) >= 10 # 10 because we have 10 biological replicates per condition (each with 2 lanes)
summary(keep)
```
```{r, echo=FALSE}
#We can now effectively filter our original DGE object
DGE_object_filtered <- DGE_object[keep, keep.lib.sizes=FALSE]

#Note: Alternatively, the edgeR function filterByExpr can be used to perform this method of filtering automatically, as demonstrated in the limma, Glimma and edgeR workflow article (Charity W. Law et al. 2018).
```

<br/>

##### __Replot after filtering__

```{r, fig.width=20, fig.height=10, echo=FALSE}
#set space for six plots
par(mfrow=c(2,3))

# Get log2 counts per million
counts_CPMlog2_filtered <- cpm(DGE_object_filtered,log=TRUE)

# Just for reference, plot the distribution of previous raw data counts (here on log scale)
boxplot(log2(as.matrix(DGE_object)+0.25), #this will use the "counts" slot = doing it on "counts"
        xlab="", 
        ylab="Log2 counts (raw data + 0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median value
abline(h=log2(median(DGE_object$counts) + 0.25),col="blue")
title("Boxplots of logcounts (raw data, unnormalised)")


# Plot the distributions of the unfiltered (log2) counts per million
boxplot(counts_CPMlog2,                        #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million +0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2),col="blue")
# Let's add a blue horizontal line that corresponds to the filtering threshold
abline(h=filtering_threshold,col="firebrick1")
title("Boxplots of logCPMs (unnormalised)")


# Plot the distributions of the FILTERED (log2) counts per million
boxplot(counts_CPMlog2_filtered,                 #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million + 0.25)",
        las=2,
        col =color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2_filtered),col="blue")
title("Boxplots of FILTERED logCPMs (unnormalised)")

#From the boxplots we see that overall the density distributions of raw log-intensities are not very different. If a sample is really far above or below the blue horizontal line we may need to investigate that sample further. Another kind of QC plot that is helpful in checking for dodgy samples is a relative log expression (RLE) plot, which can be generated with plotRLE from the EDASeq package.


## Check distributions of measured expression values using lineplots

# Get some nice colours for plotting
# define a colour palette
#mypalette <- brewer.pal(9,"Blues") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
# define a custom function "morecols" that converts a palette in a continuous series
#morecols <- colorRampPalette(mypalette)

## Check distributions of measured expression values using lineplots
#Plot distribution of unfiltered CPM counts
plot(density(counts_CPMlog2[, 1]), 
     main="",
     xlab="log2(CPM + 0.25)",
     ylab="Density",
     col = color_list[1],
     ylim=range(pretty(c(0, 0.25))))

for (i in 2:ncol(counts_CPMlog2)) {
  lines(density(counts_CPMlog2[, i]), 
        col= color_list[i]
        )
  title(main = NULL)
}
# Let's add a blue vertical line that corresponds to the median logCPM
abline(v=median(counts_CPMlog2),col="blue")
# Let's add a red vertical line that corresponds to the filtering threshold
abline(v=log2(filtering_threshold),col="firebrick1")
title("Density distribution of log2 CPM counts")

#Plot the distribution of the FILTERED CPM counts
plot(density(counts_CPMlog2_filtered[, dim(counts_CPMlog2_filtered)[2]]), 
     main="",
     xlab="log2(CPM + 0.25)",
     ylab="Density",
     col = color_list[1],
     ylim=range(pretty(c(0, 0.25))),
     xlim=range(-5,15)
     )

for (i in 2:ncol(counts_CPMlog2_filtered)) {
  lines(density(counts_CPMlog2_filtered[, i]), 
        col= color_list[i]
        )
  title(main = NULL)
}
# Let's add a blue vertical line that corresponds to the median logCPM
abline(v=median(counts_CPMlog2_filtered),col="blue")
# Let's add a red vertical line that corresponds to the filtering threshold
abline(v=log2(filtering_threshold),col="firebrick1")
title("Density distribution of FILTERED log2 CPM counts")

#let's also replot the library sizes but now before and after filtering
# plot the library sizes of all the samples
barplot(((DGE_object$samples$lib.size-DGE_object_filtered$samples$lib.size)/DGE_object$samples$lib.size)*100,           # divide by millions to just plot in millions
        names=colnames(DGE_object),                  # use sample names as labels
        las=2,                                       # The "las" argument rotates the axis names
        ann=FALSE, 
        cex.names=0.75,
        col =color_list,
        border = NA,
        ylim = c(0, 0.15))
mtext(side = 1, text = "", line = 4)
mtext(side = 2, text = "Percentage of counts filtered out", line = 3)
title("Percentage of counts filtered out")

## remove unused variables
#rm(mypalette, i, morecols, keep, above_threshold, counts_CPMraw)
```



### Normalisation for composition bias

##### __TMM normalisation__
TMM normalization is performed to eliminate composition biases between libraries (Mark D. Robinson and Oshlack 2010). This generates a set of normalization factors, where the product of these factors and the library sizes defines the effective library size. The calcNormFactors function calculates the normalization factors between libraries. TMM normalisation (and most scaling normalisation methods) scale relative to one sample.

```{r, echo=FALSE}
# Apply normalisation to DGEList object
DGE_object_filterednormed <- calcNormFactors(DGE_object_filtered, 
                                       refColumn=match(min(DGE_object_filtered$samples$lib.size), DGE_object_filtered$samples$lib.size)) #ref to the smallest library size

# This will update the normalisation factors in the DGEList object (their default values are 1). Take a look at the normalisation factors for these samples (in y[["samples"]][["norm.factors"]]).
DGE_object_filterednormed [["samples"]]
```

The normalization factors multiply to unity across all libraries. A normalization factor below one indicates that the library size will be scaled down, as there is more suppression (i.e., composition bias) in that library relative to the other libraries. This is also equivalent to scaling the counts upwards in that sample. Conversely, a factor above one scales up the library size and is equivalent to downscaling the counts.

Plotting mean-difference plots of the samples with biggest and with smallest normalisation factors, we should be able to see the composition bias problem. We will use the logcounts, which have been normalised for library size, but not for composition bias.

The mean-difference plots show average expression (mean: x-axis) against log-fold-changes (difference: y-axis). If we redo these plots using the TMM-normalised counts (normalisation factors are stored in the DGE object), we should see the composition bias problem has been solved.

```{r, echo=FALSE}
#the median of expression ratios should be closer to 1 (log closer to 0) after compositional correction


##for sample with BIGGEST correction factor
#create a table with  

tmp <- as.data.frame(DGE_object_filtered[["counts"]][,match(max(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)])
colnames(tmp) <- "referencesample"
tmp$average_othersamples <- rowMeans(DGE_object_filtered[["counts"]][,-match(max(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)])

tmp$ratio <- tmp$referencesample / tmp$average_othersamples

#calculate the median of all the gene expressions
tmp_before_1 <- tmp
median_before_1 <- log2(median(tmp$ratio))



#After correction
#manually apply the norm.factors to the counts
counts_normalised <- cpm(DGE_object_filterednormed)

tmp <- as.data.frame(counts_normalised[,match(max(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)])
colnames(tmp) <- "referencesample"
tmp$average_othersamples <- rowMeans(counts_normalised[,-match(max(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)])

tmp$ratio <- tmp$referencesample / tmp$average_othersamples

#calculate the median of all the gene expressions
tmp_after_1 <- tmp
median_after_1 <- log2(median(tmp$ratio))


##################
###for sample with SMALLEST correction factor
#create a table with  

tmp <- as.data.frame(DGE_object_filtered[["counts"]][,match(min(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)])
colnames(tmp) <- "referencesample"
tmp$average_othersamples <- rowMeans(DGE_object_filtered[["counts"]][,-match(min(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)])

tmp$ratio <- tmp$referencesample / tmp$average_othersamples

#calculate the median of all the gene expressions
tmp_before_2 <- tmp
median_before_2 <- log2(median(tmp$ratio))



#After correction
#manually apply the norm.factors to the counts
counts_normalised <- cpm(DGE_object_filterednormed)


#counts_normalised <- as.data.frame(DGE_object_filterednormed[["counts"]])
#for (i in 1:dim(counts_normalised)[2]) {
#  counts_normalised[,i] <- counts_normalised[,i]/DGE_object_filterednormed$samples$norm.factors[i]
#}
tmp <- as.data.frame(counts_normalised[,match(min(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)])
colnames(tmp) <- "referencesample"
tmp$average_othersamples <- rowMeans(counts_normalised[,-match(min(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)])

tmp$ratio <- tmp$referencesample / tmp$average_othersamples

#calculate the median of all the gene expressions
tmp_after_2 <- tmp
median_after_2 <- log2(median(tmp$ratio))



cat("In the sample with biggest norm.factor (",
    colnames(DGE_object_filterednormed)[match(max(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)],
    ") the median expression ratio compared to other samples went from",
    2^median_before_1,
    "to",
    2^median_after_1,
    "after TMM normalisation \n \n")

cat("In the sample with smallest norm.factor (",
    colnames(DGE_object_filterednormed)[match(min(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)],
    ") the median expression ratio compared to other samples went from",
    2^median_before_2,
    "to",
    2^median_after_2,
    "after TMM normalisation \n")
```
```{r, fig.width=12, fig.height=8, warning=F, echo=FALSE}
#set space for four plots
par(mfrow=c(2,3))

## Plot the MD plot for the sample with biggest normalisation factor
# ... before normalisation
plotMD(DGE_object_filtered,
       column = match(max(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors),
       main = paste0("Sample with biggest norm.factor (",colnames(DGE_object_filtered)[match(max(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)], ")\n before TMM normalisation"),
       bg.col=alpha("gray20", 0.1),
        ylim=range(pretty(c(-8, 8)))
       ) # without composition normalisation 
abline(h=log2(1),col="gray20")
abline(h=median_before_1,col="lightcoral")

# ... after normalisation
plotMD(DGE_object_filterednormed ,
       column = match(max(DGE_object_filterednormed$samples$norm.factors), DGE_object_filterednormed$samples$norm.factors),
       main = paste0("Sample with biggest norm.factor (",colnames(DGE_object_filterednormed)[match(max(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)], ")\n after TMM normalisation"),
       bg.col=alpha("gray20", 0.1),
        ylim=range(pretty(c(-8, 8)))
       ) # normalised
abline(h=log2(1),col="gray20")
abline(h=median_after_1,col="dodgerblue")

plot(density(tmp_before_1$ratio), col= "gray", ylim = c(0,2), main="")
lines(density(tmp_after_1$ratio), col="dodgerblue")
abline(v=1,col="gray20")
abline(v=2^median_before_1,col="lightcoral")
abline(v=2^median_after_1,col="dodgerblue")
title("Distribution of ratios \n (this sample vs others)")
#-------------

## Plot the MD plot for the sample with lowest normalisation factor
# ... before normalisation
plotMD(DGE_object_filtered,
       column = match(min(DGE_object_filterednormed$samples$norm.factors), DGE_object_filterednormed$samples$norm.factors),
       main = paste0("Sample with smallest norm.factor (",colnames(DGE_object_filtered)[match(min(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)], ")\n before TMM normalisation"),
       bg.col=alpha("gray20", 0.1),
        ylim=range(pretty(c(-8, 8)))
       ) # without composition normalisation 
abline(h=log2(1),col="gray20")
abline(h=median_before_2,col="lightcoral")


# ... after normalisation
plotMD(DGE_object_filterednormed,
       column = match(min(DGE_object_filterednormed$samples$norm.factors), DGE_object_filterednormed$samples$norm.factors),
       main = paste0("Sample with smallest norm.factor (",colnames(DGE_object_filterednormed)[match(min(DGE_object_filterednormed$samples$norm.factors),DGE_object_filterednormed$samples$norm.factors)], ")\n after TMM normalisation"),
       bg.col=alpha("gray20", 0.1),
        ylim=range(pretty(c(-8, 8)))
       ) #normalised
abline(h=log2(1),col="gray20")
abline(h=median_after_2,col="dodgerblue")

plot(density(tmp_before_2$ratio), col= "gray", ylim = c(0,2), main="")
lines(density(tmp_after_2$ratio), col="dodgerblue")
abline(v=1,col="gray20")
abline(v=2^median_before_2,col="lightcoral")
abline(v=2^median_after_2,col="dodgerblue")
title("Distribution of ratios \n (this sample vs others)")

#remove unused variables
rm(tmp_after_1, tmp_after_2, tmp_before_1, tmp_before_2, i, median_after_1, median_after_2, median_before_1, median_before_2, counts_normalised)
```

```{r, echo=FALSE, fig.width=20, fig.height=5}
#set space for two plots
par(mfrow=c(1,2))

# Plot library sizes just before normalisation (relative to smallest one)
barplot(DGE_object_filtered$samples$lib.size/DGE_object$samples$lib.size[match(min(DGE_object$samples$lib.size), DGE_object$samples$lib.size)],  # this will find the sample with the smallest library size
        names=colnames(DGE_object_filtered),                  # use sample names
        las=2,                                       # The las argument rotates the axis names
        ann=FALSE, 
        cex.names=0.75,
        col = color_list,
        border = NA,
        ylim=range(pretty(c(0, 1.75)))
        )
mtext(side = 1, text = "", line = 4)
mtext(side = 2, text = "Library size (millions)", line = 3)
title("Relative library size")
abline(h=1,col="dodgerblue")


#Plot library sizes AFTER normalisation (relative to smallest one)
# notice that even the normalised DGE object does not store the converted lib.sizes (lib.size * norm factor)
# you need to calculate it explicitely with effectiveLibSizes() (now getNormLibSizes)
barplot(getNormLibSizes(DGE_object_filterednormed, log = F)/getNormLibSizes(DGE_object_filterednormed, log = F)[match(min(DGE_object$samples$lib.size), DGE_object$samples$lib.size)], #i.e. reference to sample with the smallest library size
        names=colnames(DGE_object_filterednormed),                  # use sample names
        las=2,                                       # The las argument rotates the axis names
        ann=FALSE, 
        cex.names=0.75,
        col = color_list,
        border = NA,
        ylim=range(pretty(c(0, 1.75))) #otherwise y axis too short
        )
mtext(side = 1, text = "", line = 4)
mtext(side = 2, text = "Library size (millions)", line = 3)
title("Relative effective library size")
abline(h=1,col="dodgerblue")


#our DGE object now has a way of calculating effective library sizes
```



```{r, fig.width=20, fig.height=5, echo=FALSE}
# we can now plot CPM counts (i.e. counts correcting for library size) and normalisation (i.e. use norm factors)
#set space for five plots
par(mfrow=c(1,4))

  
# Get log2 counts per million
counts_CPMlog2_filterednormed <- cpm(DGE_object_filterednormed,log=TRUE, normalized.lib.sizes=TRUE)

# Just for reference, plot the distribution of previous raw data counts (here on log scale)
boxplot(log2(as.matrix(DGE_object)+0.25), #this will use the "counts" slot = doing it on "counts"
        xlab="", 
        ylab="Log2 counts (raw data + 0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median value
abline(h=log2(median(DGE_object$counts)+0.25),col="blue")
title("Boxplots of logcounts (raw data, unnormalised)")


# Plot the distributions of the unfiltered (log2) counts per million
boxplot(counts_CPMlog2,                        #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million + 0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2),col="blue")
title("Boxplots of logCPMs (unnormalised)")


# Plot the distributions of the FILTERED (log2) counts per million
boxplot(counts_CPMlog2_filtered,                 #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million + 0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2_filtered),col="blue")
title("Boxplots of FILTERED logCPMs (unnormalised)")

# Plot the distributions of the filtered, NORMALISED (log2) counts per million
boxplot(counts_CPMlog2_filterednormed,                 #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million + 0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2_filterednormed),col="blue")
title("Boxplots of filtered logCPMs (normalised)")
```

```{r, fig.width=20, fig.height=5, warning=FALSE, echo=FALSE}
## Plot RLE (relative expression level) to check effectiveness of normalisation
# a RLE plot is, on log counts, the deviation of each gene recording, to its average across all samples

## RAW COUNTS
RLE_counts_forggplot <- sweep(log2(counts+0.25), MARGIN=1, STATS= rowMeans(log2(counts+0.25)))
RLE_counts_forggplot$genes <- row.names(RLE_counts_forggplot)
RLE_counts_forggplot  <- RLE_counts_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_counts_forggplot$Condition <- factor(RLE_counts_forggplot$Condition, levels = ordered_levels)

plot1 <- ggplot(RLE_counts_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: rawcounts")+
  NULL

## CPM

tmp <-as.data.frame(2^(counts_CPMlog2-0.25))
RLE_logCPM_forggplot <- sweep(log2(tmp), MARGIN=1, STATS= rowMeans(log2(tmp))) 
RLE_logCPM_forggplot$genes <- row.names(as.data.frame(RLE_logCPM_forggplot))
RLE_logCPM_forggplot <- RLE_logCPM_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_logCPM_forggplot$Condition <- factor(RLE_logCPM_forggplot$Condition, levels =  ordered_levels)

plot2 <- ggplot(RLE_logCPM_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: logCPMs")+
  NULL

## FILTERED CPM

tmp <-as.data.frame(2^(counts_CPMlog2_filtered-0.25))
RLE_logCPMfiltered_forggplot <- sweep(log2(tmp), MARGIN=1, STATS= rowMeans(log2(tmp))) 
RLE_logCPMfiltered_forggplot$genes <- row.names(as.data.frame(RLE_logCPMfiltered_forggplot))
RLE_logCPMfiltered_forggplot <- RLE_logCPMfiltered_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_logCPMfiltered_forggplot$Condition <- factor(RLE_logCPMfiltered_forggplot$Condition, levels =  ordered_levels)

plot3 <- ggplot(RLE_logCPMfiltered_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: filtered logCPMs")+
  NULL

## FILTERED, TMM NORMALISED, CPM
tmp <-as.data.frame(2^(counts_CPMlog2_filterednormed-0.25))
RLE_logCPMfilterednormed_forggplot <- sweep(log2(tmp), MARGIN=1, STATS= rowMeans(log2(tmp))) 
RLE_logCPMfilterednormed_forggplot$genes <- row.names(as.data.frame(RLE_logCPMfilterednormed_forggplot))
RLE_logCPMfilterednormed_forggplot <- RLE_logCPMfilterednormed_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_logCPMfilterednormed_forggplot$Condition <- factor(RLE_logCPMfilterednormed_forggplot$Condition, levels = ordered_levels)

plot4 <- ggplot(RLE_logCPMfilterednormed_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: filtered logCPMs, TMM-normalised")+
  NULL

grid.arrange(plot1, plot2, plot3, plot4, ncol=4, nrow=1)

#remove unused variables
rm(tmp, RLE_counts_forggplot, RLE_logCPM_forggplot, RLE_logCPMfiltered_forggplot, RLE_logCPMfilterednormed_forggplot, plot1, plot2, plot3, plot4)
```


##### __Deseq2__
DESeq2 internally corrects counts for sequencing depth (i.e. what we did by using CPM) and RNA compositional bias (norm) using Median of ratios method. To run this method, we create a DESeq2 object using the count data and metadata.

```{r, fig.width=20, fig.height=5, warning=FALSE, echo=FALSE}
#convert lavel data slot to factor (if not already)
#DGE_object[["samples"]][["stage"]] <- factor(DGE_object[["samples"]][["stage"]])

## create a DeSeq2 object. We can use the original count data (unfiltered, un-normalised) because this is done automatically by the function. Starting with the filtered object will help though. 
DeSeq2_object <- DESeqDataSetFromMatrix(countData=round(DGE_object_filtered[["counts"]]),
                                        colData=DGE_object_filtered[["samples"]],
                                        design=~treatment)
# calculate the size factors of each sample (these are stored in DeSeq2_object@colData@listData[["sizeFactor"]])
DeSeq2_object <- DESeq2::estimateSizeFactors(DeSeq2_object,type="ratio") #size factors in DeSeq2 are not relative to one sample 
# apply the normalisation to your counts
counts_DeSeq2 <- counts(DeSeq2_object,normalized=TRUE) #the normalisation performed here includes the correction for library size that we were doing with CPM transform, as well as the proper "normalisation" against compositional bias based on Median of Rations methods

####### plotting
#set space for 5 plots
par(mfrow=c(1,5))

# Just for reference, plot the distribution of previous raw data counts (here on log scale)
boxplot(log2(as.matrix(DGE_object)+0.25), #this will use the "counts" slot = doing it on "counts"
        xlab="", 
        ylab="Log2 counts (raw data + 0.25 )",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median value
abline(h=log2(median(DGE_object$counts)+0.25),col="blue")
title("Boxplots of logcounts (raw data, unnormalised)")


# Plot the distributions of the unfiltered (log2) counts per million
boxplot(counts_CPMlog2,                        #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million + 0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2),col="blue")
title("Boxplots of logCPMs (unnormalised)")


# Plot the distributions of the filtered (log2) counts per million
boxplot(counts_CPMlog2_filtered,                 #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million + 0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2_filtered),col="blue")
title("Boxplots of FILTERED logCPMs (unnormalised)")

# Plot the distributions of the filtered, NORMALISED (log2) counts per million
boxplot(counts_CPMlog2_filterednormed,                 #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million + 0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2_filterednormed),col="blue")
title("Boxplots of filtered logCPMs (normalised)")

# Plot the distributions of the filtered, DeSeq2 normalised counts
boxplot(log2(as.matrix(counts_DeSeq2)+0.25), 
        xlab="", 
        ylab="Log2 (normalised counts + 0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=log2(median(as.matrix(counts_DeSeq2))+0.25),col="blue")
title("Boxplots of DeSeq2 counts (filtered)")
```

```{r, fig.width=20, fig.height=4, warning=FALSE, echo=FALSE}
## Plot RLE (relative expression level) to check effectiveness of normalisation
# a RLE plot is, on log counts, the deviation of each gene recording, to its average across all samples

## RAW COUNTS
RLE_counts_forggplot <- sweep(log2(counts+0.25), MARGIN=1, STATS= rowMeans(log2(counts+0.25)))
RLE_counts_forggplot$genes <- row.names(RLE_counts_forggplot)
RLE_counts_forggplot  <- RLE_counts_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_counts_forggplot$Condition <- factor(RLE_counts_forggplot$Condition, levels =  ordered_levels)

plot1 <- ggplot(RLE_counts_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: rawcounts")+
  NULL

## CPM

tmp <-as.data.frame(2^(counts_CPMlog2-0.25))
RLE_logCPM_forggplot <- sweep(log2(tmp), MARGIN=1, STATS= rowMeans(log2(tmp))) 
RLE_logCPM_forggplot$genes <- row.names(as.data.frame(RLE_logCPM_forggplot))
RLE_logCPM_forggplot <- RLE_logCPM_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_logCPM_forggplot$Condition <- factor(RLE_logCPM_forggplot$Condition, levels =  ordered_levels)

plot2 <- ggplot(RLE_logCPM_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: logCPMs")+
  NULL

## FILTERED CPM

tmp <-as.data.frame(2^(counts_CPMlog2_filtered-0.25))
RLE_logCPMfiltered_forggplot <- sweep(log2(tmp), MARGIN=1, STATS= rowMeans(log2(tmp))) 
RLE_logCPMfiltered_forggplot$genes <- row.names(as.data.frame(RLE_logCPMfiltered_forggplot))
RLE_logCPMfiltered_forggplot <- RLE_logCPMfiltered_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_logCPMfiltered_forggplot$Condition <- factor(RLE_logCPMfiltered_forggplot$Condition, levels = ordered_levels)

plot3 <- ggplot(RLE_logCPMfiltered_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: filtered logCPMs")+
  NULL

## FILTERED, TMM NORMALISED, CPM
tmp <-as.data.frame(2^(counts_CPMlog2_filterednormed-0.25))
RLE_logCPMfilterednormed_forggplot <- sweep(log2(tmp), MARGIN=1, STATS= rowMeans(log2(tmp))) 
RLE_logCPMfilterednormed_forggplot$genes <- row.names(as.data.frame(RLE_logCPMfilterednormed_forggplot))
RLE_logCPMfilterednormed_forggplot <- RLE_logCPMfilterednormed_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_logCPMfilterednormed_forggplot$Condition <- factor(RLE_logCPMfilterednormed_forggplot$Condition, levels =  ordered_levels)

plot4 <- ggplot(RLE_logCPMfilterednormed_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: filtered logCPMs, TMM-normalised")+
  NULL

## DESEQ2 object (normalised for both library size and compositional bias)
tmp <-as.data.frame(counts_DeSeq2)
RLE_countsDeSeq2_forggplot <- sweep(log2(tmp+0.25), MARGIN=1, STATS= rowMeans(log2(tmp+0.25)))
RLE_countsDeSeq2_forggplot$genes <- row.names(RLE_countsDeSeq2_forggplot)
RLE_countsDeSeq2_forggplot  <- RLE_countsDeSeq2_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_countsDeSeq2_forggplot$Condition <- factor(RLE_countsDeSeq2_forggplot$Condition, levels =  ordered_levels)

plot5 <- ggplot(RLE_countsDeSeq2_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: DeSeq2")+
  NULL

grid.arrange(plot1, plot2, plot3, plot4, plot5, ncol=5, nrow=1)

#remove unused variables
rm(tmp, RLE_counts_forggplot, RLE_logCPM_forggplot, RLE_logCPMfiltered_forggplot, RLE_logCPMfilterednormed_forggplot, RLE_countsDeSeq2_forggplot, plot1, plot2, plot3, plot4, plot5)
```


##### __VST__
For the purpose of exploratory analysis such as MDS, PCA, clustering etc, VST (variance-stabilizing-transformation) is recommended. VST is also run using DESeq2. As in the previous step, a DESeq2 object is created.
Variance stabilizing transformation (VST) aims at generating a matrix of values for which variance is constant across the range of mean values, especially for low mean.The vst function computes the fitted dispersion-mean relation, derives the transformation to apply and accounts for library size.

For RNA-seq data, as the mean count value increases, the variance increases. There is a strong almost linear relationship as seen in the figures. The statistical methods such as PCA expects similar variance across the range of mean values. If not, the higher variance genes will contribute more than the lower variance genes. Such data is said to be heteroscedastic and needs to be corrected. Correction using log transformation (with pseudocount) gives inflates the contribution of the low variance genes. To obtain similar variance across the whole range of mean values, DESeq2 offers two methods VST (variance stabilising transformation) and RLOG (regularised log transformation).

As the name suggests, VST transformation stabilizes variance across the whole range of count values. VST is recommended for clustering or visualisation. It is not intended for differential gene expression. If the size factors vary dramatically between samples, then RLOG transformation is recommended.

<br/>
__Below, an overview of the main dataset properties across objects__
<br/>
```{r, fig.width=30, fig.height=6, echo=FALSE}
# calculate fitted dispersion-mean relation and update our Deseq2 object
DeSeq2_object <- DESeq2::estimateDispersions(DeSeq2_object)
# apply the transformation to your counts
counts_VST <- as.data.frame(assay(varianceStabilizingTransformation(DeSeq2_object,blind=T)),check.names=F)


####### plotting
#set space for 6 plots
par(mfrow=c(1,6))

# Just for reference, plot the distribution of previous raw data counts (here on log scale)
boxplot(log2(as.matrix(DGE_object)+0.25), #this will use the "counts" slot = doing it on "counts"
        xlab="", 
        ylab="Log10 counts (raw data + 0.25)",
        ylim=c(0,20),
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median value
abline(h=log2(median(DGE_object$counts)+0.25),col="blue")
title("Boxplots of logcounts (raw data, unnormalised)")


# Plot the distributions of the unfiltered (log2) counts per million
boxplot(counts_CPMlog2,                        #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million + 0.25)",
        ylim=c(-5,20),
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2),col="blue")
title("Boxplots of logCPMs (unnormalised)")


# Plot the distributions of the filtered (log2) counts per million
boxplot(counts_CPMlog2_filtered,                 #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million + 0.25)",
        ylim=c(-5,20),
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2_filtered),col="blue")
title("Boxplots of FILTERED logCPMs (unnormalised)")

# Plot the distributions of the filtered, NORMALISED (log2) counts per million
boxplot(counts_CPMlog2_filterednormed,                 #function cpm() adds already a small value to avoid log(0)
        xlab="", 
        ylab="Log2 (counts per million + 0.25)",
        ylim=c(-5,20),
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(counts_CPMlog2_filterednormed),col="blue")
title("Boxplots of filtered logCPMs (normalised)")

# Plot the distributions of the filtered, DeSeq2 normalised counts
boxplot(log2(as.matrix(counts_DeSeq2)+0.25), 
        xlab="", 
        ylab="Log2 (normalised counts + 0.25)",
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=log2(median(as.matrix(counts_DeSeq2))+0.25),col="blue")
title("Boxplots of DeSeq2 counts (filtered)")

# Plot the distributions of the filtered, VST normalised counts
boxplot(as.matrix(counts_VST), 
        xlab="", 
        ylab="log2 (vst-transformed counts)",
        ylim=c(0,20),
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(as.matrix(counts_VST)),col="blue")
title("Boxplots of VST counts (filtered)")
```

```{r, fig.width=30, fig.height=5, warning=FALSE, echo=FALSE}
## Plot RLE (relative expression level) to check effectiveness of normalisation
# a RLE plot is, on log counts, the deviation of each gene recording, to its average across all samples

## RAW COUNTS
RLE_counts_forggplot <- sweep(log2(counts+0.25), MARGIN=1, STATS= rowMeans(log2(counts+0.25)))
RLE_counts_forggplot$genes <- row.names(RLE_counts_forggplot)
RLE_counts_forggplot  <- RLE_counts_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_counts_forggplot$Condition <- factor(RLE_counts_forggplot$Condition, levels =  ordered_levels)

plot1 <- ggplot(RLE_counts_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: rawcounts")+
  NULL

## CPM

tmp <-as.data.frame(2^(counts_CPMlog2-0.25))
RLE_logCPM_forggplot <- sweep(log2(tmp), MARGIN=1, STATS= rowMeans(log2(tmp))) 
RLE_logCPM_forggplot$genes <- row.names(as.data.frame(RLE_logCPM_forggplot))
RLE_logCPM_forggplot <- RLE_logCPM_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_logCPM_forggplot$Condition <- factor(RLE_logCPM_forggplot$Condition, levels =  ordered_levels)

plot2 <- ggplot(RLE_logCPM_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: logCPMs")+
  NULL

## FILTERED CPM

tmp <-as.data.frame(2^(counts_CPMlog2_filtered-0.25))
RLE_logCPMfiltered_forggplot <- sweep(log2(tmp), MARGIN=1, STATS= rowMeans(log2(tmp))) 
RLE_logCPMfiltered_forggplot$genes <- row.names(as.data.frame(RLE_logCPMfiltered_forggplot))
RLE_logCPMfiltered_forggplot <- RLE_logCPMfiltered_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_logCPMfiltered_forggplot$Condition <- factor(RLE_logCPMfiltered_forggplot$Condition, levels =  ordered_levels)

plot3 <- ggplot(RLE_logCPMfiltered_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: filtered logCPMs")+
  NULL

## FILTERED, TMM NORMALISED, CPM
tmp <-as.data.frame(2^(counts_CPMlog2_filterednormed-0.25))
RLE_logCPMfilterednormed_forggplot <- sweep(log2(tmp), MARGIN=1, STATS= rowMeans(log2(tmp))) 
RLE_logCPMfilterednormed_forggplot$genes <- row.names(as.data.frame(RLE_logCPMfilterednormed_forggplot))
RLE_logCPMfilterednormed_forggplot <- RLE_logCPMfilterednormed_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_logCPMfilterednormed_forggplot$Condition <- factor(RLE_logCPMfilterednormed_forggplot$Condition, levels =  ordered_levels)

plot4 <- ggplot(RLE_logCPMfilterednormed_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: filtered logCPMs, TMM-normalised")+
  NULL

## DESEQ2 object (normalised for both library size and compositional bias)
tmp <-as.data.frame(counts_DeSeq2)
RLE_countsDeSeq2_forggplot <- sweep(log2(tmp+0.25), MARGIN=1, STATS= rowMeans(log2(tmp+0.25)))
RLE_countsDeSeq2_forggplot$genes <- row.names(RLE_countsDeSeq2_forggplot)
RLE_countsDeSeq2_forggplot  <- RLE_countsDeSeq2_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_countsDeSeq2_forggplot$Condition <- factor(RLE_countsDeSeq2_forggplot$Condition, levels =  ordered_levels)

plot5 <- ggplot(RLE_countsDeSeq2_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: DeSeq2")+
  NULL

## DESEQ2-VST object (normalised for both library size and compositional bias, VST'd)

RLE_countsVST_forggplot <- sweep(log2(counts_VST+0.25), MARGIN=1, STATS= rowMeans(log2(counts_VST+0.25)))
RLE_countsVST_forggplot$genes <- row.names(RLE_countsVST_forggplot)
RLE_countsVST_forggplot  <- RLE_countsVST_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_countsVST_forggplot$Condition <- factor(RLE_countsVST_forggplot$Condition, levels =  ordered_levels)

plot6 <- ggplot(RLE_countsVST_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-10,10))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: DeSeq2-VST")+
  NULL


grid.arrange(plot1, plot2, plot3, plot4, plot5, plot6, ncol=6, nrow=1)

#remove unused variables
rm(tmp, RLE_counts_forggplot, RLE_logCPM_forggplot, RLE_logCPMfiltered_forggplot, RLE_logCPMfilterednormed_forggplot, RLE_countsDeSeq2_forggplot, RLE_countsVST_forggplot, plot1, plot2, plot3, plot4, plot5, plot6)
```

```{r, fig.width=30, fig.height=5, echo=FALSE}
#https://nbisweden.github.io/workshop-RNAseq/1906/lab_dge.html
# but see also https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#effects-of-transformations-on-the-variance
# define a function that calculates variance
rowVar <- function(x) apply(x,1,var)

## Mean vs Variance plots to see effect of VST
# set space for 8 plots
par(mfrow=c(1,6))

plot(log2(rowMeans(as.matrix(DGE_object))),log2(rowVar(as.matrix(DGE_object))),
     xlab=expression('Log'[2]~'Mean count'),
     ylab=expression('Log'[2]~'Variance'),
     col = alpha("black", 0.5),
     main="Unfiltered raw data (not normalised)")

plot(rowMeans(counts_CPMlog2),rowVar(counts_CPMlog2),
     xlab=expression('Log'[2]~'Mean count'),
     ylab=expression('Log'[2]~'Variance'),
     col = alpha("black", 0.5),
     main="Unfiltered log2CPM (not normalised)")

plot(rowMeans(counts_CPMlog2_filtered),rowVar(counts_CPMlog2_filtered),
     xlab=expression('Log'[2]~'Mean count'),
     ylab=expression('Log'[2]~'Variance'),
     col = alpha("black", 0.5),
     main="FILTERED log2CPM (not normalised)")

plot(rowMeans(counts_CPMlog2_filterednormed), rowVar(counts_CPMlog2_filterednormed),
     xlab=expression('Log'[2]~'Mean count'),
     ylab=expression('Log'[2]~'Variance'),
     col = alpha("black", 0.5),
     main="FILTERED log2CPM (normalised)")

plot(log2(rowMeans(counts_DeSeq2)),log2(rowVar(counts_DeSeq2)),
     xlab=expression('Log'[2]~'Mean count'),
     ylab=expression('Log'[2]~'Variance'),
     col = alpha("black", 0.5),
     main="DESeq2")

plot(rowMeans(counts_VST),rowVar(counts_VST),
     xlab='Mean count',
     ylab='Variance',
     col = alpha("black", 0.5),
     main="VST")

##remove unused variables and functions
rm(rowVar)

```

```{r, fig.width=30, fig.height=5, echo=FALSE}
#set space for six plots
par(mfrow=c(1,6))
 
#plot the count distribution under all transformations

# Get some nice colours for plotting
# define a colour palette
mypalette <- brewer.pal(9,"Blues") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
# define a custom function "morecols" that converts a palette in a continuous series
morecols <- colorRampPalette(mypalette)


## Check distributions of measured expression values using lineplots

#RAW COUNTS
plot(density(log2(counts[, 1]+0.25)), 
     main="",
     col = color_list[1],
     xlab="log2(rawcounts + 0.25)",
     ylab="Density",
     ylim=range(pretty(c(0, 0.25))))

for (i in 2:ncol(counts)) {
  lines(density(log2(counts[, i]+0.25)), 
        col= color_list[i]
        )
  title(main = NULL)
}
# Let's add a blue vertical line that corresponds to the median logCPM
abline(v=median(log2(as.matrix(counts)+0.25)),col="blue")
title("Density distribution of raw counts")



#UNFILTERED log2CPM
plot(density(counts_CPMlog2[, 1]), 
     main="",
     col = color_list[1],
     xlab="log2(CPM + 0.25)",
     ylab="Density",
     ylim=range(pretty(c(0, 0.25))))

for (i in 2:ncol(counts_CPMlog2)) {
  lines(density(counts_CPMlog2[, i]), 
        col= color_list[i]
        )
  title(main = NULL)
}
# Let's add a blue vertical line that corresponds to the median logCPM
abline(v=median(counts_CPMlog2),col="blue")
title("Density distribution of log2 CPM counts")

#FILTERED log2CPM
plot(density(counts_CPMlog2_filtered[, 1]), 
     main="",
     col = color_list[1],
     xlab="log2(CPM + 0.25)",
     ylab="Density",
     ylim=range(pretty(c(0, 0.25))),
     xlim=range(-5,15)
     )

for (i in 2:ncol(counts_CPMlog2_filtered)) {
  lines(density(counts_CPMlog2_filtered[, i]), 
        col= color_list[i]
        )
  title(main = NULL)
}
# Let's add a blue vertical line that corresponds to the median logCPM
abline(v=median(counts_CPMlog2_filtered),col="blue")
title("Density distribution of FILTERED log2 CPM counts")

#FILTERED log2CPM, NORMED
plot(density(counts_CPMlog2_filterednormed[, 1]), 
     main="",
     col = color_list[1],
     xlab="log2(CPM + 0.25)",
     ylab="Density",
     ylim=range(pretty(c(0, 0.25))),
     xlim=range(-5,15)
     )

for (i in 2:ncol(counts_CPMlog2_filterednormed)) {
  lines(density(counts_CPMlog2_filterednormed[, i]), 
        col= color_list[i]
        )
  title(main = NULL)
}
# Let's add a blue vertical line that corresponds to the median logCPM
abline(v=median(counts_CPMlog2_filterednormed),col="blue")
title("Density distribution of filtered, normed log2 CPM counts")

#DESEQ2
plot(density(log2(counts_DeSeq2[, 1]+0.25)), 
     main="",
     col = color_list[1],
     xlab="log2(CPM + 0.25)",
     ylab="Density",
     ylim=range(pretty(c(0, 0.25))),
     xlim=range(-5,15)
     )

for (i in 2:ncol(counts_DeSeq2)) {
  lines(density(log2(counts_DeSeq2[, i]+0.25)), 
        col= color_list[i]
        )
  title(main = NULL)
}
# Let's add a blue vertical line that corresponds to the median logCPM
abline(v=median(log2(counts_DeSeq2+0.25)),col="blue")
title("Density distribution of DeSeq2-normalised counts")

#DeSeq2-VST
plot(density(counts_VST[, 1]), 
     main="",
     col = color_list[1],
     xlab="~ log2(scaled counts)",
     ylab="Density",
     ylim=range(pretty(c(0, 0.25))))

for (i in 2:ncol(counts_VST)) {
  lines(density(counts_VST[, i]), 
        col= color_list[i]
        )
  title(main = NULL)
}
# Let's add a blue vertical line that corresponds to the median logCPM
abline(v=median(as.matrix(counts_VST)),col="blue")
title("Density distribution of VST counts")


#remove unused variables
rm(i, mypalette, morecols)
```

```{r, echo=FALSE}
##we can now save the three main objects created, and load them in each section as needed
#original counts, filtered, and with TMM normalisation applied
#save(DGE_object_filterednormed, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/DGE_object_filterednormed.rds")

#filtered counts corrected for library size through CPM, values are log2, and they are normalised
#save(counts_CPMlog2_filterednormed, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_CPMlog2_filterednormed.rds")

#counts normalised fofr library size and compositional bias through DeSeq2 Median of Ratios, with VST applied
#save(counts_VST, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")

#save sample metadata
#save(sample_metadata, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/sample_metadata.rds")


#clean up the workspace
rm(counts, counts_CPMlog2, counts_CPMlog2_filtered, counts_CPMlog2_filterednormed, counts_DeSeq2, counts_VST, DeSeq2_object, DGE_object, DGE_object_filtered, DGE_object_filterednormed)
```


### Overview analysis of the dataset  

__Overview analysis of the dataset (top variable genes)__

`r emo::ji("magnifying glass tilted right")` To get a first impression of the dataset, we will calculate exploratory PCAs on all most variable genes in the dataset, regardless of the biological processes in which they are involved. __What genes separate _A. ocellaris_ larvae across the dataset?__

<br />
* __Step 1:__ For PCA and visualisation, we will use the VST transformed object (DeSeq2 object with  Variance Stabilising Transformation applied, see previous section):
  Below, an overview of the main count features of this starting object


```{r, fig.width=15, fig.height=10, warning= FALSE, echo=FALSE}
#For PCA and visualisation, we will use the VST transformed object. 
#Load the object "counts_VST" and plot summary plots as reminder

load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")

# set space for 5 plots
par(mfrow=c(2,3))


plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, "Summary parameters \n of loaded VST object", cex=1.2)

#LIBRARY SIZES

barplot(colSums(counts_VST)/1000, 
        names=colnames(counts_VST),                  # use sample names
        las=2,                                       # The las argument rotates the axis names
        ann=FALSE, 
        cex.names=0.75,
        col = color_list,
        border = NA,
        ylim=range(pretty(c(0, max(colSums(counts_VST)/1000)+50)))
        )
mtext(side = 1, text = "", line = 4)
mtext(side = 2, text = "Library size (thousands)", line = 3)
title("Effective Library size")

#BOXPLOT COUNTS

boxplot(as.matrix(counts_VST), 
        xlab="", 
        ylab="log2 (vst-transformed counts)",
        ylim=c(0,20),
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(as.matrix(counts_VST)),col="blue")
title("Boxplots of VST counts")


#COUNT DENSITY DISTRIBUTION
# Get some nice colours for plotting
# define a colour palette
mypalette <- brewer.pal(9,"Blues") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
# define a custom function "morecols" that converts a palette in a continuous series
morecols <- colorRampPalette(mypalette)

plot(density(counts_VST[, 1]), 
     main="",
     col = color_list[1],
     xlab="~ log2(scaled counts)",
     ylab="Density",
     ylim=range(pretty(c(0, 0.25))))

for (i in 2:ncol(counts_VST)) {
  lines(density(counts_VST[, i]), 
        col= color_list[i]
        )
  title(main = NULL)
}
# Let's add a blue vertical line that corresponds to the median logCPM
abline(v=median(as.matrix(counts_VST)),col="blue")
title("Density distribution of VST counts")

#MEAN-VARIANCE PLOT
# define a function that calculates variance
rowVar <- function(x) apply(x,1,var)

plot(rowMeans(counts_VST),rowVar(counts_VST),
     xlab='Mean count',
     ylab='Variance',
     col = alpha("black", 0.5),
     main="VST")


#RLE PLOTS
RLE_countsVST_forggplot <- sweep(log2(counts_VST+0.25), MARGIN=1, STATS= rowMeans(log2(counts_VST+0.25)))
RLE_countsVST_forggplot$genes <- row.names(RLE_countsVST_forggplot)
RLE_countsVST_forggplot  <- RLE_countsVST_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_countsVST_forggplot$Condition <- factor(RLE_countsVST_forggplot$Condition, levels =  ordered_levels)

#since this is a ggplot and we want to  plot it with baseR plots, we need to do this
#https://stackoverflow.com/questions/14124373/combine-base-and-ggplot-graphics-in-r-figure-window
plot.new()              
vps <- baseViewports()
pushViewport(vps$figure) ##   I am in the space of the RLE plots
vp1 <-plotViewport(c(1.8,1,0,1)) ## create new vp with margins, you play with this values 
#prepare the actual ggplot
plot6 <- ggplot(RLE_countsVST_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-1,1))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("Relative Levels of Expression: DeSeq2-VST")+
  NULL
#print the ggplot in the correct viewport
print(plot6,vp = vp1)

##remove unused variables and functions
rm(mypalette, morecols, i, RLE_countsVST_forggplot, rowVar, vp1, vps, plot6)
```

<br />
* __Step 2a:__ We now can subset our counts matrix, to just keep the most variable genes. This threshold could be chosen arbitrarily based either on number of genes (i.e. the top2000 most variable genes), or on variance of these genes (i.e. the genes with top 10% variance). Different possible thresholds on this dataset are illustrated below:

```{r, fig.width=20, fig.height=3, echo=FALSE}
par(mfrow=c(1,7))
# define a function that calculates variance
rowVar <- function(x) apply(x,1,var)
var_genes <- apply(counts_VST, 1, var)

#define tiers of genes
top1percent <- round(0.01*nrow(counts_VST))
top2percent <- round(0.02*nrow(counts_VST))
top5percent <- round(0.05*nrow(counts_VST))
top10percent <-  round(0.1*nrow(counts_VST))
top15percent <-  round(0.15*nrow(counts_VST))
top20percent <-  round(0.2*nrow(counts_VST)) 


#MEAN-VARIANCE PLOT
plot(rowMeans(counts_VST),rowVar(counts_VST), pch = 19,
     xlab='Mean count',
     ylab='Variance',
     col=alpha("black", 0.5),
     main="VST")


#MEAN-VARIANCE PLOT top20%
plot(rowMeans(counts_VST),rowVar(counts_VST),pch = 19,
     xlab='Mean count',
     ylab='Variance',
     col=ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top20percent], alpha("orchid", 0.5), alpha("black", 0.5)),
     main=paste0("VST (Top 20%-",top20percent, " genes)"))

#MEAN-VARIANCE PLOT top15%
plot(rowMeans(counts_VST),rowVar(counts_VST),pch = 19,
     xlab='Mean count',
     ylab='Variance',
     col=ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top15percent], alpha("blue", 0.5), alpha("black", 0.5)),
     main=paste0("VST (Top 15%-",top15percent, " genes)"))

#MEAN-VARIANCE PLOT top10%
plot(rowMeans(counts_VST),rowVar(counts_VST),pch = 19,
     xlab='Mean count',
     ylab='Variance',
     col=ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top10percent], alpha("dodgerblue", 0.5), alpha("black", 0.5)),
     main=paste0("VST (Top 10%-",top10percent, " genes)"))

#MEAN-VARIANCE PLOT top5%
plot(rowMeans(counts_VST),rowVar(counts_VST),pch = 19,
     xlab='Mean count',
     ylab='Variance',
     col=ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top5percent], alpha("forestgreen", 0.5), alpha("black", 0.5)),
     main=paste0("VST (Top 5%-",top5percent, " genes)"))

#MEAN-VARIANCE PLOT top2%
plot(rowMeans(counts_VST),rowVar(counts_VST),pch = 19,
     xlab='Mean count',
     ylab='Variance',
     col=ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top2percent], alpha("chocolate1", 0.5), alpha("black", 0.5)),
     main=paste0("VST (Top 2%-",top2percent, " genes)"))

#MEAN-VARIANCE PLOT top1%
plot(rowMeans(counts_VST),rowVar(counts_VST),pch = 19,
     xlab='Mean count',
     ylab='Variance',
     col=ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top1percent], alpha("lightcoral", 0.5), alpha("black", 0.5)),
     main=paste0("VST (Top 1%-",top1percent, " genes)"))


#plot(rowMeans(counts_VST),rowVar(counts_VST), pch = 19,
#     xlab='Mean count',
#     ylab='Variance',
#     col=ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top1percent], 
#                alpha("lightcoral", 0.5), 
#                ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top2percent], 
#                alpha("chocolate1", 0.5), 
#                ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top5percent], 
#                alpha("palegreen", 0.5), 
#                ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top10percent], 
#                alpha("dodgerblue", 0.5), 
#                ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top15percent], 
#                alpha("blue", 0.5), 
#                ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:top20percent], 
#                alpha("orchid", 0.5), 
#                alpha("black", 0.1))))))),
#     main="VST")
```
<br />
* __Step 2b:__ Here, we will select based on a variance threshold, but not an aribitrary one. We wukk select the genes with higest variance, based on the inflection point of the variance distribution of all genes. As per below:

```{r, fig.width=14, fig.height=5, echo=FALSE}
#set number of plots
par(mfrow=c(1,3))
#define the quick function to calculate the var() of each gene
rowVar <- function(x) apply(x,1,var)

#generate the data and find inflection points
variance_data <- hist(rowVar(counts_VST), 
                      breaks = 1000, 
                      plot = FALSE)
#let us stores c and y values; note we need to add the 0 y value at the 0 x value
variance_data_df <- data.frame(breaks = variance_data$breaks, counts = c(0,variance_data$counts))
#we want to find the knee point in the decreasing part of the plot, so we will only consider lines after the maximum
knee <- kneedle(variance_data_df[(1+match(max(variance_data_df$counts),variance_data_df$counts)):nrow(variance_data_df),"breaks"],
                variance_data_df[(1+match(max(variance_data_df$counts),variance_data_df$counts)):nrow(variance_data_df),"counts"],
                concave = T, 
                decreasing = T,
                s=1)
#let us calculate now the reverse cumulative distribution function
variance_data_df$revcum <- rev(cumsum(rev(variance_data_df$counts)))
#so the number of genes avbove that value is the cumulative distribution at the value after
variance_data_df$genes_above <- variance_data_df$revcum -variance_data_df$counts

#VARIANCE DISTRIBUTION
tmp<-hist(rowVar(counts_VST), 
     breaks = 1000,
     main="Gene variance distribution (VST object)",
     xlab="variance (s2)",
     ylab="number of genes with given variance",
     ylim = c(0,2500))
par(new=TRUE)
plot(variance_data_df$breaks,variance_data_df$genes_above, 
     ylim=c(0,22000) , 
     type="l", col="red", 
     axes=FALSE, ylab="", xlab="")
axis(side = 4)  
mtext("", side = 4, line = 2)  


#VARIANCE DISTRIBUTION (ZOOM + KNEE)
hist(rowVar(counts_VST), 
     breaks = 1000,
     main="[INSET] Gene variance distribution (VST object)",
     xlab="variance (s2)",
     ylab="number of genes with given variance",
     ylim = c(0,2500),
     xlim = c(0, 1))
abline(v=knee[1],col="blue")
par(new=TRUE)
plot(variance_data_df$breaks,variance_data_df$genes_above, 
     ylim=c(0,22000), xlim=c(0,1), 
     type="l", col="red", 
     axes=FALSE, ylab="", xlab="")
axis(side = 4)  
#abline(h=variance_data_df[match(as.character(knee[[1]]),variance_data_df$breaks),"genes_above"],col="blue")
segments(x0 = knee[[1]], y0= variance_data_df[match(as.character(knee[[1]]),variance_data_df$breaks),"genes_above"], 
         x1=1.5, y1= variance_data_df[match(as.character(knee[[1]]),variance_data_df$breaks),"genes_above"], col="blue")
mtext("", side = 4, line = 2)  




#MEAN-VARIANCE PLOT
# define a function that calculates variance
rowVar <- function(x) apply(x,1,var)

plot(rowMeans(counts_VST),rowVar(counts_VST), cex=0.1,
     xlab='Mean count',
     ylab='Variance', 
     col=ifelse(rownames(counts_VST) %in% names(sort(var_genes, decreasing=TRUE))[1:variance_data_df[match(as.character(knee[[1]]),variance_data_df$breaks),"genes_above"]], alpha("dodgerblue", 0.5), alpha("black", 0.5)),
     main="VST")
abline(h=knee[[1]],col="red")



#print data
paste0("The sample variance cutoff of s^2>", knee[[1]] ," has been selected based on the kneedle algorithm")
paste0("There are ", variance_data_df[match(as.character(knee[[1]]),variance_data_df$breaks),"genes_above"], " genes whose variance across all samples is above this threshold (", round(variance_data_df[match(as.character(knee[[1]]),variance_data_df$breaks),"genes_above"]*100/nrow(counts_VST), digits=2), "% of all genes)")
```

```{r, echo=FALSE, include=FALSE}
#check that the Rstudio var() function is using the the sample mean as denominator (i.e. n-1)
var_genes <- apply(counts_VST, 1, var)
sample_mean <- sum((counts_VST[1,]-rowMeans(counts_VST[1,]))^2)/(ncol(counts_VST)-1)
paste0("For gene 1, the function var() is calculating: ",var_genes[[1]])
paste0("For gene 1, the manually-calculated sample mean is :",sample_mean )
```


<br />
* __Step 3:__ We can now subset our object. In this case, we are thus using 3418 genes, the most variable ones.   The plots below show the summary properties of this subset (note indeed the high variance). In blue in the mean-variance plot `r emo::ji("small blue diamond")`, the genes that have been selected out of all of the genes in the original object.

```{r, fig.width=4, fig.height=4, echo=FALSE}
## For the PCA and clustering analysis, we will only use the part of the dataset that has the 1000 genes with the highest variance
# Estimate the variance for each row in our counts_VST starting object
var_genes <- apply(counts_VST, 1, var)
# Get the gene names for the top 1000 most variable genes
top_genes <- names(sort(var_genes, decreasing=TRUE))[1:variance_data_df[match(as.character(knee[[1]]),variance_data_df$breaks),"genes_above"]] #[1:2000] if you want to put a precise number (eg Top2000 genes)
# Subset vst matrix
counts_VST_top2000 <- counts_VST[top_genes,]

#remove unused variables
rm(var_genes)
```

```{r, fig.width=15, fig.height=10, warning= FALSE, echo=FALSE}
## Let us reanalyse the subset of just top2000 genes

# set space for 5 plots
par(mfrow=c(2,3))


plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, "Summary parameters \n of Top750 most variant genes", cex=1.2)

#MEAN-VARIANCE PLOT (highlighting top 2000variant genes in colour)
# define a function that calculates variance
rowVar <- function(x) apply(x,1,var)

plot(rowMeans(counts_VST),rowVar(counts_VST),
     xlab='Mean count',
     ylab='Variance',
     col=ifelse(rownames(counts_VST) %in% top_genes, alpha("dodgerblue", 0.5), alpha("black", 0.5)),
     main="VST object: mean-variance plot (all genes)")


#LIBRARY SIZES

barplot(colSums(counts_VST_top2000)/1000, 
        names=colnames(counts_VST_top2000),                  # use sample names
        las=2,                                       # The las argument rotates the axis names
        ann=FALSE, 
        cex.names=0.75,
        col = color_list,
        border = NA,
        ylim=range(pretty(c(0, max(colSums(counts_VST_top2000)/1000))))
        )
mtext(side = 1, text = "Samples", line = 4)
mtext(side = 2, text = "Library size (thousands)", line = 3)
title("Effective Library size on most variant genes")

#BOXPLOT COUNTS

boxplot(as.matrix(counts_VST_top2000), 
        xlab="", 
        ylab="log2 (vst-transformed counts)",
        ylim=c(0,20),
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(as.matrix(counts_VST_top2000)),col="blue")
title("Boxplots of most variant VST counts")


#COUNT DENSITY DISTRIBUTION
# Get some nice colours for plotting
# define a colour palette
mypalette <- brewer.pal(9,"Blues") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
# define a custom function "morecols" that converts a palette in a continuous series
morecols <- colorRampPalette(mypalette)

plot(density(counts_VST_top2000[, 1]), 
     main="",
     col = color_list[1],
     xlab="~ log2(scaled counts)",
     ylab="Density",
     ylim=range(pretty(c(0, 0.25))))

for (i in 2:ncol(counts_VST_top2000)) {
  lines(density(counts_VST_top2000[, i]), 
        col= color_list[i]
        )
  title(main = NULL)
}
# Let's add a blue vertical line that corresponds to the median logCPM
abline(v=median(as.matrix(counts_VST_top2000)),col="blue")
title("Density distribution of most variant VST counts")

#RLE PLOTS
RLE_countsVST_forggplot <- sweep(log2(counts_VST_top2000+0.25), MARGIN=1, STATS= rowMeans(log2(counts_VST_top2000+0.25)))
RLE_countsVST_forggplot$genes <- row.names(RLE_countsVST_forggplot)
RLE_countsVST_forggplot  <- RLE_countsVST_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_countsVST_forggplot$Condition <- factor(RLE_countsVST_forggplot$Condition, levels =  ordered_levels)

#since this is a ggplot and we want to  plot it with baseR plots, we need to do this
#https://stackoverflow.com/questions/14124373/combine-base-and-ggplot-graphics-in-r-figure-window
plot.new()              
vps <- baseViewports()
pushViewport(vps$figure) ##   I am in the space of the RLE plots
vp1 <-plotViewport(c(1.8,1,0,1)) ## create new vp with margins, you play with this values 
#prepare the actual ggplot
plot6 <- ggplot(RLE_countsVST_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-3,3))+
  xlab("") + 
  ylab("Relative log2 expression of each gene (expression-mean)")+
  ggtitle("RLE: most variant VST counts")+
  NULL
#print the ggplot in the correct viewport
print(plot6,vp = vp1)

##remove unused variables and functions
rm(mypalette, morecols, i, RLE_countsVST_forggplot, rowVar, vp1, vps, plot6, top_genes)
```

<br />

* __Step 4:__ Incidentally, we can highlight and list the top15 genes that have highest expression (though they might not be the variant ones)


```{r, fig.width=9, fig.height=3, echo=FALSE}
#as a curiosity, we can highlight and list the top10 genes thath have highes expression (though they might not be the variant ones)

# set space for 3 plots
par(mfrow=c(1,3))


plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, "Mean-variance plot \n (highest expression genes \n highlighted in blue)", cex=1.2)

top_mean_genes <- names(sort(apply(counts_VST, 1, mean), decreasing=TRUE))[1:15]
top_mean_genes <- as.data.frame(top_mean_genes)

colnames(top_mean_genes) <- "entrez_ID"
top_mean_genes$description <- annotation_info$merged_description[match(top_mean_genes$entrez_ID ,annotation_info$entrez_ID)] 
top_mean_genes$ensembl_description <- annotation_info$ensembl_description[match(top_mean_genes$entrez_ID ,annotation_info$entrez_ID)]
top_mean_genes$mean_count <- sort(apply(counts_VST, 1, mean), decreasing=TRUE)[1:15]

#MEAN-VARIANCE PLOT (highlighting top 1000variant genes in colour)
# define a function that calculates variance
rowVar <- function(x) apply(x,1,var)

plot(rowMeans(counts_VST),rowVar(counts_VST),
     xlab='Mean count',
     ylab='Variance',
     col=ifelse(rownames(counts_VST) %in% top_mean_genes$entrez_ID, alpha("dodgerblue", 0.5), alpha("black", 0.5)),
     main="VST object: mean-variance plot (all genes)")


#list top contributing genes
#kable(top_mean_genes, caption = "Top15 genes with highest expression")

## Formattable output

formattable(top_mean_genes, 
             caption ="Top15 genes with highest expression",
            align =c("c","l", "l", "c"), 
            list(`entrez_ID` = formatter("span", 
                                      style = x ~ style(
                                        color = "#A9A9A9", font.weight = "bold")
                                      ), 
                 `mean_count`= color_tile(NA,"dodgerblue")

                 )
            )

#remove unused variables
#rm(top_mean_genes, rowVar)
```


```{r, echo=FALSE}
#we will also print the pattern of expression of these highly-expressed genes
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes
genelist <- top_mean_genes$entrez_ID
selected_genes <- c(genelist)
```

```{r, echo=FALSE, include=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)

rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
rm(selected_genes)

```


```{r, fig.height=5, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of the highest-expressed genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = TRUE,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```




### Correlation between samples (most variable genes)

<br/>

#### Dendogram

```{r, fig.width=20, fig.height=5, echo=FALSE}
# Dissimilarity matrix
d <- dist(t(counts_VST_top2000), method = "euclidean")

#do not plot this or computer will start overheating
#result <- pvclust(t(vst_counts_top1000), method.dist="euclidean", method.hclust="ward.D2", nboot=1000, parallel=TRUE)
#plot(result)

# Hierarchical clustering using Complete Linkage
hc1 <- hclust(d, method = "ward.D2" )

# Plot the obtained dendrogram
#plot(as.dendrogram(hc1), type = "rectangle", ylab = "Height")

# plot with extended graphics
#https://r-graph-gallery.com/340-custom-your-dendrogram-with-dendextend.html

as.dendrogram(hc1) %>% 
  # Custom branches
  set("branches_col", "gray90") %>% set("branches_lwd", 2) %>%
  # Custom labels
  set("labels_col", "gray60") %>% set("labels_cex", 0.6) %>%
  plot()

colored_bars(colors = cbind(color_categorical_lane, color_list), # colors for category "experiment"
                            
             dend = as.dendrogram(hc1), 
             rowLabels = c("lane", "treatment"), #first category to plot
            y_scale	= 20,
             y_shift	= -100                           
             )


#remove unused variables
#rm(d, hc1)

```

<br/>

#### Correlation matrix:

```{r, fig.width=10, fig.height=10, echo=FALSE}
# calculate correlation betwwen samples
# RNA-Seq samples generally have very high correlation (R^2 > 0.9). R^2 values below 0.8 may be an indication of an outlier sample. Depending on other QC metric, these low correlation samples may be discarded from analyses.
correlation_matrix <- as.matrix(cor(counts_VST_top2000,method="spearman"))

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col'
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            #empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )

rowAnn <- rowAnnotation(df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to mutch the name of the named list
                            col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                        show_legend = FALSE,
                        show_annotation_name = FALSE
                            )


Heatmap(mat = correlation_matrix,
        name= "Spearman's rho",
        column_title = gt_render(paste0("<span style='color:darkorchid4'>**Spearman's ", expression(ρ), "**</span> correlation coeff. <br/> between samples <span style='color:gray60'>(on most variable genes)</span>")),
        col = brewer.pal(9,"BuPu"),
        na_col = "black",
        cluster_rows = FALSE,
        show_row_dend = FALSE,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        #column_order = ordered_levels,
        row_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #column_gap = unit(c(rep(1,9), rep(8,1), rep(1,9), rep(8,1), rep(1,9), rep(8,1), rep(1,9), rep(8,1), rep(1,9)), "mm"),
       
        row_title = NULL,
        row_gap = unit(1, "mm"),
        column_gap = unit(1, "mm"),
        width = unit(18, "cm"), 
        height = unit(18, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        #top_annotation = colAnn,
        bottom_annotation = colAnn,
        right_annotation = rowAnn,
        show_heatmap_legend = TRUE
        )


#library(GetoptLong)  # for the function qq()
#group_block_anno = function(group, empty_anno, gp = gpar(), 
#    label = NULL, label_gp = gpar()) {
#
#    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
#    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
#    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
#    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))
#
#    seekViewport("global")
#    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
#        just = c("left", "bottom"), gp = gp)
#    if(!is.null(label)) {
#        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
#    }
#}

#group_block_anno(1:10, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
#group_block_anno(11:20, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
#group_block_anno(21:30, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
#group_block_anno(31:40, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
#group_block_anno(41:50, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

### PCA plots

#### {.tabset}
##### PCA plots
We can run the PCA based on the top variable genes. Below, the scree plot indicating the contribution of each Principal Component, and the plot of the PCA over the top10 components. 


```{r, fig.width= 6, fig.height=4, echo=FALSE}
## For PCA we need to start with the data in the correct format (we need conditions as row, and genes as columns)
# transpose our counts matrix (switch rows and columns)
counts_VST_top2000_transposed <- t(counts_VST_top2000)


#we will change gene symbols with their description, but many genes have empty values. Where empty, we will now replace with the gene symbol
#annotation_info$description = coalesce(annotation_info$description, #when not NA
#                                       annotation_info$symbol) #when NA

#save the original col_names (entrez_ID)
old_colnames <- colnames(counts_VST_top2000_transposed)

# Place the gene description (is already unique from how we constructed the annotation table)
#colnames(counts_VST_top2000_transposed) <- dplyr::recode(
#  colnames(counts_VST_top2000_transposed), 
#  !!!setNames(as.character(annotation_info$merged_description), # column of dictionary table that has NEW names 
#              annotation_info$entrez_ID)  #column of dictionary table with OLD names
#  )
colnames(counts_VST_top2000_transposed) <- annotation_info$merged_description[match(colnames(counts_VST_top2000_transposed), annotation_info$entrez_ID)]

#save the new col_names (gull gene description, made unique with postscripts)
new_colnames <- colnames(counts_VST_top2000_transposed)
#allowing us to create a name conversion dictionary for later steps using this PCA object
entrezid2name_converter <- data.frame(entrez_ID = old_colnames, unique_description = new_colnames)


#we can now calculate PCA (on the top 2000 genes)
PCAobject_top2000 <- prcomp(x=counts_VST_top2000_transposed, center = T, scale. = F)

# Plot Scree Plot of our data
barplot(#round(PCAobject_top2000$sdev^2/sum(PCAobject_top2000$sdev^2)*100,2),
  round(PCAobject_top2000$sdev^2/sum(PCAobject_top2000$sdev^2)*100,2)[round(PCAobject_top2000$sdev^2/sum(PCAobject_top2000$sdev^2)*100,2) > 100/length(colnames(PCAobject_top2000$x))],
         las=2,
         names.arg=colnames(PCAobject_top2000$x)[round(PCAobject_top2000$sdev^2/sum(PCAobject_top2000$sdev^2)*100,2) > 100/length(colnames(PCAobject_top2000$x))],
         ylab="% Variance explained",
         xlab="PCA principal components",
         ylim =range(pretty(c(0, 100))),
         main = "Scree plot (top variant genes) \n (only showing main PCs)"
         )
abline(h=100/length(colnames(PCAobject_top2000$x)), lty=2, col="dodgerblue")


#remove unused variables
rm(new_colnames, old_colnames)
```

<br />

* __Step 1:__ Below, an exploratory overview of the distribution of samples across the main PCs, highlighting treatment conditions, as well as other known possible sources of variation (here: technical replicates: different lanes)

```{r, fig.width= 10, fig.height=20, echo=FALSE}
## PCA (segment colour code)

# we will use ggplot, so we need to add a column with the sample names to our data
PCAobject_top2000_ggplot <- merge(as.data.frame(PCAobject_top2000$x),
                                  sample_metadata, #we are merging with a dataframe that has a column "stage" for each sample
                                  by=0)

PCAobject_top2000_ggplot$treatment  <- factor(PCAobject_top2000_ggplot$treatment,levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP"))



plot1a <- ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC2,colour= treatment, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_treatment)+
  scale_shape_manual(values = c(16,1))+ 
 # scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="left")

plot1b <- ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC2,colour= lane, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_lane)+
  scale_shape_manual(values = c(16,1))+ 
 # scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")



#----------------

plot2a <- ggplot(PCAobject_top2000_ggplot,
       aes(PC3,PC2,colour= treatment, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_treatment)+
  scale_shape_manual(values = c(16,1))+ 
  #scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC3 (", round(summary(PCAobject_top2000)$importance[8]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

plot2b <- ggplot(PCAobject_top2000_ggplot,
       aes(PC3,PC2,colour= lane, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_lane)+
  scale_shape_manual(values = c(16,1))+ 
  #scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC3 (", round(summary(PCAobject_top2000)$importance[8]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")


#----------------

plot3a <- ggplot(PCAobject_top2000_ggplot,
       aes(PC3,PC4,colour= treatment, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_treatment)+
  scale_shape_manual(values = c(16,1))+ 
  #scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  theme_classic()+ theme(legend.position="none")

plot3b <- ggplot(PCAobject_top2000_ggplot,
       aes(PC3,PC4,colour= lane, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_lane)+
  #scale_color_manual(values = rep("gray30", 3))+
  scale_shape_manual(values = c(16,1))+
  #scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  theme_classic()+ theme(legend.position="none")


#----------------

plot4a <- ggplot(PCAobject_top2000_ggplot,
       aes(PC5,PC4,colour= treatment, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_treatment)+
  scale_shape_manual(values = c(16,1))+
  #scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  theme_classic()+ theme(legend.position="none")

plot4b <- ggplot(PCAobject_top2000_ggplot,
       aes(PC5,PC4,colour= lane, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_lane)+
  #scale_color_manual(values = rep("gray30", 3))+
  scale_shape_manual(values = c(16,1))+
  #scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  theme_classic()+ theme(legend.position="none")



#----------------

plot5a <- ggplot(PCAobject_top2000_ggplot,
       aes(PC5,PC6,colour= treatment, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_treatment)+
  scale_shape_manual(values = c(16,1))+ 
  #scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  theme_classic()+ theme(legend.position="none")

plot5b <- ggplot(PCAobject_top2000_ggplot,
       aes(PC5,PC6,colour= lane, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_lane)+
  #scale_color_manual(values = rep("gray30", 3))+
  scale_shape_manual(values = c(16,1))+
  #scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  theme_classic()+ theme(legend.position="none")



#----------------

plot6a <- ggplot(PCAobject_top2000_ggplot,
       aes(PC6,PC7,colour= treatment, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_treatment)+
  scale_shape_manual(values = c(16,1))+
  #scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  theme_classic()

plot6b <- ggplot(PCAobject_top2000_ggplot,
       aes(PC6,PC7,colour= lane, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_lane)+
  #scale_color_manual(values = rep("gray30", 3))+
 scale_shape_manual(values = c(16,1))+
  #scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  theme_classic()



grid.arrange(plot1a,plot1b,
             plot2a,plot2b,
             plot3a,plot3b,
             plot4a,plot4b,
             plot5a,plot5b,
             plot6a,plot6b, ncol=2, nrow=6)

#remove unused variables
#rm(plot1, plot2, plot3, plot4, plot5, plot6)

```

<br />
* __Step 2:__ The scree plot shows that most of the variance present in the dataset can be represented in two dimensions. Below is the PC1 vs PC2 summary plot, coloured by condition, with and without labels to correlate points to the actual larval samples (of which we have pictures)

```{r, echo=FALSE, fig.width=10, fig.height=5}
#let us also just plot the first PCA plot
ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC2,colour= treatment, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_treatment)+
  scale_shape_manual(values = c(16,1))+ 
  geom_label_repel(data = PCAobject_top2000_ggplot[seq(from=21, to =40, by=2),],
                   aes(x=PC1, y= PC2, colour= treatment, label=Row.names),
                   size = 3, show.legend = FALSE,
                   fill = "white",
                   max.overlaps= 50,
                   #xlim = c(-Inf, Inf)
                   ) + 
 # scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="left")



#without labels
ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC2,colour= treatment, shape=lane))+
  geom_point(size=5)+
  scale_color_manual(values = color_categorical_treatment)+
  scale_shape_manual("technical replicate", values = c(16,1))+ 
  #geom_label_repel(data = PCAobject_top2000_ggplot[seq(from=21, to =40, by=2),],
  #                 aes(x=PC1, y= PC2, colour= treatment, label=Row.names),
  #                 size = 3, show.legend = FALSE,
  #                 fill = "white",
  #                 max.overlaps= 50,
  #                 #xlim = c(-Inf, Inf)
  #                 ) + 
 # scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="right")
```

<br />
* __Step 3:__ With added polygons to highlight the spread of samples within each condition (this is the final figure reported in the paper)

```{r, echo=FALSE, fig.width=8, fig.height=5}


#with polygon
ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC2,colour= treatment, shape=lane))+
  geom_encircle(aes(fill = treatment), alpha = 0.07, show.legend = F, s_shape=0.8, expand = 0.05)+
  geom_point(size=5)+
  scale_fill_manual(values = color_categorical_treatment)+
  scale_color_manual(values = color_categorical_treatment)+
  scale_shape_manual("technical replicate", values = c(16,1))+ 
  #geom_label_repel(data = PCAobject_top2000_ggplot[seq(from=21, to =40, by=2),],
  #                 aes(x=PC1, y= PC2, colour= treatment, label=Row.names),
  #                 size = 3, show.legend = FALSE,
  #                 fill = "white",
  #                 max.overlaps= 50,
  #                 #xlim = c(-Inf, Inf)
  #                 ) + 
 # scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="right")
```




##### Top contributors PC1 (treatment (MPI vs T3, T3CPF))

We will here analyse the main genes driving separation along PC1.

```{r, echo=FALSE}
##plot top 50 contributing genes to PCA1 (liver vs others)
#find list of top (50) contributing genes
contrib_data <- fviz_contrib(PCAobject_top2000, choice = "var", 
                             axes = 1, 
                             top = 50
                             )

#PC1PC2_TOP50_contributors <- contrib_data[["plot_env"]][["data_sum"]][["name"]]
PC1_TOP50_contributors <- data.frame("genes" = sapply(contrib_data[["plot_env"]][["data_sum"]][["name"]], as.character), 
                                        "contribution to PC1PC2" = contrib_data[["plot_env"]][["data_sum"]][["contrib"]])
#add a column with the original NCBI ids
PC1_TOP50_contributors$entrez_ID <- entrezid2name_converter$entrez_ID[match(PC1_TOP50_contributors$genes ,entrezid2name_converter$unique_description)] 
#add a column with the ensembl description
PC1_TOP50_contributors$ensembl_description <- annotation_info$ensembl_description[match(PC1_TOP50_contributors$entrez_ID ,annotation_info$entrez_ID)] 
#rearrange column order
PC1_TOP50_contributors <- PC1_TOP50_contributors[,c(3,1,4,2)]

#list top contributing genes
#kable(PC1_TOP50_contributors, caption = "Top50 genes driving PC1 separation")

#save dataframe for manual annotation
#write.csv(PC1PC2_TOP50_contributors,"C://Users/Doctor/Desktop/RNAseq_analyses/Aocellaris_metamorphosis/Saved_objects/PC1PC2_TOP50_contributors_onTop1000variantgenes.csv",row.names = FALSE)

#removed unused variables
#rm(contrib_data)


## Formattable output

formattable(PC1_TOP50_contributors, 
             caption ="Top50 genes driving PC1 separation",
            align =c("c","l", "l", "c"), 
            list(`entrez_ID` = formatter("span", 
                                      style = x ~ style(
                                        color = "#A9A9A9", font.weight = "bold")
                                      ), 
                 `contribution.to.PC1PC2`= color_tile(NA,"lightcoral")

                 )
            )



```


Below, the biplot showing the relative influence of each of the genes

```{r, fig.width=20, fig.height=5, warning=FALSE, echo=FALSE}
plots <- list()

plots[[1]] <- ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC2,colour=treatment, shape=lane))+
  geom_point(size=3)+
  scale_color_manual(values = color_categorical_treatment)+
  scale_shape_manual(values = c(16,1))+ 
  #scale_fill_manual(values = color_categorical_stage)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

correlationloadings <- as.data.frame(cor(counts_VST_top2000_transposed, PCAobject_top2000$x))
correlationloadings_PC1subset <- correlationloadings[unlist(PC1_TOP50_contributors["genes"])[1:50],1:2]
correlationloadings_PC1subset$genes <- row.names(correlationloadings_PC1subset)
correlationloadings_PC1subset$symbols <- annotation_info$merged_symbol[match(correlationloadings_PC1subset$genes, annotation_info$merged_description)]

plots[[2]] <- ggplot(correlationloadings_PC1subset,
       aes(PC1,PC2,
           #colour= "firebrick1", 
           label = genes
           )
       )+
  geom_point(size=3, color= ifelse(correlationloadings_PC1subset$PC1>0, "lightcoral", "gray30"), alpha=0.5)+
  scale_color_manual(values = color_categorical_treatment)+
  geom_label_repel(size = 3, show.legend = FALSE,
                   fill = "white",
                   color = ifelse(correlationloadings_PC1subset$PC1>0, "lightcoral", "gray30"),
                   max.overlaps= 50,
                   #xlim = c(-Inf, Inf)
                   ) + 
  coord_cartesian(clip = "off") +
  xlim(-1, 1)+
  ylim(-1, 1)+
  xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+
 # theme(plot.margin = unit(c(0,-10,0,-10), "cm"))+
  annotate("path",
   x=0+1*cos(seq(0,2*pi,length.out=100)),
   y=0+1*sin(seq(0,2*pi,length.out=100)))


plots[[3]] <- ggplot(correlationloadings_PC1subset,
       aes(PC1,PC2,
           #colour= "firebrick1", 
           label = symbols
           )
       )+
  geom_point(size=3, color= ifelse(correlationloadings_PC1subset$PC1>0, "lightcoral", "gray30"), alpha=0.5)+
  scale_color_manual(values = color_categorical_treatment)+
  geom_label_repel(size = 3, show.legend = FALSE,
                   fill = "white",
                   color = ifelse(correlationloadings_PC1subset$PC1>0, "lightcoral", "gray30"),
                   max.overlaps= 40,
                   #xlim = c(-Inf, Inf)
                   ) + 
  coord_cartesian(clip = "off") +
  xlim(-1, 1)+
  ylim(-1, 1)+
  xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+
 # theme(plot.margin = unit(c(0,-10,0,-10), "cm"))+
  annotate("path",
   x=0+1*cos(seq(0,2*pi,length.out=100)),
   y=0+1*sin(seq(0,2*pi,length.out=100)))

par(mar=c(5,10,4,10)+.1, "cm")


plots[[1]] <- plots[[1]] + theme(legend.position = "none")

plots[[4]] <-
  ggdraw() +
  draw_plot(plots[[3]]) +
  draw_plot(plots[[1]], x = 0.7, y = -0.06, width = .3, height = .3)


ggarrange(plotlist = plots, ncol = 4, common.legend = TRUE, legend = "none")
#kable(correlationloadings_PC1subset[,c("symbols", "genes")], caption = "Gene-symbol dictionary")

#remove unused variables
rm(plots, correlationloadings_PC1subset)
```


<br />
Below, a dedicated visualisation of the relative level of expression of each gene, in each sample.

```{r, fig.width=10, fig.height=60, echo=FALSE}
#http://agroninfotech.blogspot.com/2020/06/biplot-for-pcs-using-base-graphic.html
# we can now verify how these top 50 genes actually move our samples across dimensions
# define palette
mypalette <- brewer.pal(9,"RdBu") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
morecols <- colorRampPalette(mypalette)
colorrange=rev(morecols(100))

#set rows and columns (4)
par(mfrow=c((length(unlist(PC1_TOP50_contributors["genes"]))/3)+1,3))

#plot loop
for (i in 1:length(unlist(PC1_TOP50_contributors["genes"]))) {
  gene_of_interest <- unlist(PC1_TOP50_contributors["genes"])[i]
  
  #normalise values of expression for gene X (e.g hbae5)
  #colorvalues <- 100*(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))/(max(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))) #transpose all values above 0 by adding minimal value (could be negative) to all. The normalised by max intensity to 1. Then on 100 scale
  colorvalues <- 100*(counts_VST_top2000_transposed[,gene_of_interest])/(max(counts_VST_top2000_transposed[,gene_of_interest]))
  
  
  #color datapoints (observations) by expression level
  par(pty = "s",
    cex.main = 1.2,
    cex.lab = 1,
    font.main = 2,
    font.lab = 2,
    family = "sans",
    col.main = "gray10",
    col.lab = "gray10",
    fg = "gray10",
    las = 1)
  
  plot.new()
  
  #we are first going to plot the different conditions (samples), which are in PCAobject_top2000$x 
  plot.window(xlim = extendrange(range(PCAobject_top2000$x[, 1]), f = 0.1), 
            ylim = extendrange(range(PCAobject_top2000$x[, 2]), f = 0.1), 
            asp = 1)
  axis(side = 1, 
     labels = TRUE)
  axis(side = 2, 
     labels = TRUE)
  title(main = gene_of_interest,
        xlab = paste("PC 1 (", 
                   round(summary(PCAobject_top2000)$importance[2]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      ylab = paste("PC 2 (", 
                   round(summary(PCAobject_top2000)$importance[5]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      #line = 2,
      adj = 0.5)
  
  # plot the different conditions (samples)
  points(x = PCAobject_top2000$x[,1:2],
       pch = 16,
       cex = 2,
       col = colorrange[colorvalues]
       #col = rep(c("black","gray50", "gray35"),each=7)
       )
  
  #text(PCAobject_top2000$x[,1:2]-5, 
  #     labels = row.names(PCAobject_top2000$x), 
  #     cex = 0.8,
  #     font = 2,
  #     col = "black"
  #     )
  
  
}

#remove unused variables
#rm(colorrange, colorvalues, gene_of_interest, i, mypalette, morecols)
```

##### Top contributors PC2 (CPF vs DMSO/T3)

We will here analyse the main genes driving separation along PC2.

```{r, echo=FALSE}
##plot top 50 contributing genes to PCA2 (stomach vs others)
#find list of top (50) contributing genes
contrib_data <- fviz_contrib(PCAobject_top2000, choice = "var", 
                             axes = 2, 
                             top = 50
                             )

#PC1PC2_TOP50_contributors <- contrib_data[["plot_env"]][["data_sum"]][["name"]]
PC2_TOP50_contributors <- data.frame("genes" = sapply(contrib_data[["plot_env"]][["data_sum"]][["name"]], as.character), 
                                        "contribution to PC1PC2" = contrib_data[["plot_env"]][["data_sum"]][["contrib"]])
#add a column with the original ensembl_gene_ids
PC2_TOP50_contributors$entrez_ID <- entrezid2name_converter$entrez_ID[match(PC2_TOP50_contributors$genes ,entrezid2name_converter$unique_description)] 
#add a column with the ensembl description
PC2_TOP50_contributors$ensembl_description <- annotation_info$ensembl_description[match(PC2_TOP50_contributors$entrez_ID ,annotation_info$entrez_ID)] 
#rearrange column order
PC2_TOP50_contributors <- PC2_TOP50_contributors[,c(3,1,4,2)]

#list top contributing genes
#kable(PC2_TOP50_contributors, caption = "Top50 genes driving PC2 separation")

## Formattable output

formattable(PC2_TOP50_contributors, 
             caption ="Top50 genes driving PC1 separation",
            align =c("c","l", "l", "c"), 
            list(`entrez_ID` = formatter("span", 
                                      style = x ~ style(
                                        color = "#A9A9A9", font.weight = "bold")
                                      ), 
                 `contribution.to.PC1PC2`= color_tile(NA,"lightcoral")

                 )
            )


#save dataframe for manual annotation
#write.csv(PC1PC2_TOP50_contributors,"C://Users/Doctor/Desktop/RNAseq_analyses/Aocellaris_metamorphosis/Saved_objects/PC1PC2_TOP50_contributors_onTop1000variantgenes.csv",row.names = FALSE)

#removed unused variables
rm(contrib_data)

```


<br />
Below, a dedicated visualisation of the relative level of expression of each gene, in each sample.

```{r, fig.width=10, fig.height=60, echo=FALSE}
#http://agroninfotech.blogspot.com/2020/06/biplot-for-pcs-using-base-graphic.html
# we can now verify how these top 50 genes actually move our samples across dimensions
# define palette
mypalette <- brewer.pal(9,"RdBu") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
morecols <- colorRampPalette(mypalette)
colorrange=rev(morecols(100))

#set rows and columns (4)
par(mfrow=c((length(unlist(PC2_TOP50_contributors["genes"]))/3)+1,3))

#plot loop
for (i in 1:length(unlist(PC2_TOP50_contributors["genes"]))) {
  gene_of_interest <- unlist(PC2_TOP50_contributors["genes"])[i]
  
  #normalise values of expression for gene X (e.g hbae5)
  #colorvalues <- 100*(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))/(max(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))) #transpose all values above 0 by adding minimal value (could be negative) to all. The normalised by max intensity to 1. Then on 100 scale
  colorvalues <- 100*(counts_VST_top2000_transposed[,gene_of_interest])/(max(counts_VST_top2000_transposed[,gene_of_interest]))
  
  
  #color datapoints (observations) by expression level
  par(pty = "s",
    cex.main = 1.2,
    cex.lab = 1,
    font.main = 2,
    font.lab = 2,
    family = "sans",
    col.main = "gray10",
    col.lab = "gray10",
    fg = "gray10",
    las = 1)
  
  plot.new()
  
  #we are first going to plot the different conditions (samples), which are in PCAobject_top2000$x 
  plot.window(xlim = extendrange(range(PCAobject_top2000$x[, 1]), f = 0.1), 
            ylim = extendrange(range(PCAobject_top2000$x[, 2]), f = 0.1), 
            asp = 1)
  axis(side = 1, 
     labels = TRUE)
  axis(side = 2, 
     labels = TRUE)
  title(main = gene_of_interest,
        xlab = paste("PC 1 (", 
                   round(summary(PCAobject_top2000)$importance[2]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      ylab = paste("PC 2 (", 
                   round(summary(PCAobject_top2000)$importance[5]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      #line = 2,
      adj = 0.5)
  
  # plot the different conditions (samples)
  points(x = PCAobject_top2000$x[,1:2],
       pch = 16,
       cex = 2,
       col = colorrange[colorvalues]
       #col = rep(c("black","gray50", "gray35"),each=7)
       )
  
  #text(PCAobject_top2000$x[,1:2]-5, 
  #     labels = row.names(PCAobject_top2000$x), 
  #     cex = 0.8,
  #     font = 2,
  #     col = "black"
  #     )
  
  
}

#remove unused variables
rm(colorrange, colorvalues, gene_of_interest, i, mypalette, morecols)
```

 __Explore sample distribution PC2 drivers__

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- PC2_TOP50_contributors$entrez_ID
selected_genes <- c(genelist)
```

```{r, echo=FALSE, include=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
rm(selected_genes)

```

```{r, fig.height=8, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of the top contributors to PC"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = TRUE,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### Top contributors PC3 (T3?)

We will here analyse the main genes driving separation along PC3.
```{r, echo=FALSE}
##plot top 50 contributing genes to PCA3 (stage)
#find list of top (50) contributing genes
contrib_data <- fviz_contrib(PCAobject_top2000, choice = "var", 
                             axes = 3, 
                             top = 50
                             )

#PC1PC2_TOP50_contributors <- contrib_data[["plot_env"]][["data_sum"]][["name"]]
PC3_TOP50_contributors <- data.frame("genes" = sapply(contrib_data[["plot_env"]][["data_sum"]][["name"]], as.character), 
                                        "contribution to PC1PC2" = contrib_data[["plot_env"]][["data_sum"]][["contrib"]])
#add a column with the original ensembl_gene_ids
PC3_TOP50_contributors$entrez_ID <- entrezid2name_converter$entrez_ID[match(PC3_TOP50_contributors$genes ,entrezid2name_converter$unique_description)] 
#add a column with the ensembl description
PC3_TOP50_contributors$ensembl_description <- annotation_info$ensembl_description[match(PC3_TOP50_contributors$entrez_ID ,annotation_info$entrez_ID)] 
#rearrange column order
PC3_TOP50_contributors <- PC3_TOP50_contributors[,c(3,1,4,2)]

#list top contributing genes
#kable(PC3_TOP50_contributors, caption = "Top50 genes driving PC3 separation")

#save dataframe for manual annotation
#write.csv(PC1PC2_TOP50_contributors,"C://Users/Doctor/Desktop/RNAseq_analyses/Aocellaris_metamorphosis/Saved_objects/PC1PC2_TOP50_contributors_onTop1000variantgenes.csv",row.names = FALSE)


## Formattable output

formattable(PC3_TOP50_contributors, 
             caption ="Top50 genes driving PC1 separation",
            align =c("c","l", "l", "c"), 
            list(`entrez_ID` = formatter("span", 
                                      style = x ~ style(
                                        color = "#A9A9A9", font.weight = "bold")
                                      ), 
                 `contribution.to.PC1PC2`= color_tile(NA,"lightcoral")

                 )
            )


#removed unused variables
rm(contrib_data)

```

Below, the relative expression level

```{r, fig.width=10, fig.height=60, echo=FALSE}
#http://agroninfotech.blogspot.com/2020/06/biplot-for-pcs-using-base-graphic.html
# we can now verify how these top 50 genes actually move our samples across dimensions
# define palette
mypalette <- brewer.pal(9,"RdBu") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
morecols <- colorRampPalette(mypalette)
colorrange=rev(morecols(100))

#set rows and columns (4)
par(mfrow=c((length(unlist(PC3_TOP50_contributors["genes"]))/3)+1,3))

#plot loop
for (i in 1:length(unlist(PC3_TOP50_contributors["genes"]))) {
  gene_of_interest <- unlist(PC3_TOP50_contributors["genes"])[i]
  
  #normalise values of expression for gene X (e.g hbae5)
  #colorvalues <- 100*(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))/(max(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))) #transpose all values above 0 by adding minimal value (could be negative) to all. The normalised by max intensity to 1. Then on 100 scale
  colorvalues <- 100*(counts_VST_top2000_transposed[,gene_of_interest])/(max(counts_VST_top2000_transposed[,gene_of_interest]))
  
  
  #color datapoints (observations) by expression level
  par(pty = "s",
    cex.main = 1.2,
    cex.lab = 1,
    font.main = 2,
    font.lab = 2,
    family = "sans",
    col.main = "gray10",
    col.lab = "gray10",
    fg = "gray10",
    las = 1)
  
  plot.new()
  
  #we are first going to plot the different conditions (samples), which are in PCAobject_top2000$x 
  plot.window(xlim = extendrange(range(PCAobject_top2000$x[, 3]), f = 0.1), #PCA on x axis
            ylim = extendrange(range(PCAobject_top2000$x[, 2]), f = 0.1), #PCA on y axis
            asp = 1)
  axis(side = 1, 
     labels = TRUE)
  axis(side = 2, 
     labels = TRUE)
  title(main = gene_of_interest,
        xlab = paste("PC 3 (", 
                   round(summary(PCAobject_top2000)$importance[8]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      ylab = paste("PC 2 (", 
                   round(summary(PCAobject_top2000)$importance[5]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      #line = 2,
      adj = 0.5)
  
  # plot the different conditions (samples)
  points(x = PCAobject_top2000$x[,3:2],
       pch = 16,
       cex = 2,
       col = colorrange[colorvalues]
       #col = rep(c("black","gray50", "gray35"),each=7)
       )
  
  #text(PCAobject_top2000$x[,3:2]-5, 
  #     labels = row.names(PCAobject_top2000$x), 
  #     cex = 0.8,
  #     font = 2,
  #     col = "black"
  #     )
  
  
}

#remove unused variables
rm(colorrange, colorvalues, gene_of_interest, i, mypalette, morecols)
```

 __Explore sample distribution PC3 drivers__

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- PC3_TOP50_contributors$entrez_ID
selected_genes <- c(genelist)
```

```{r, echo=FALSE, include=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
rm(selected_genes)

```

```{r, fig.height=8, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of the top contributors to PC"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = TRUE,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### Top contributors PC4 (?)
We will here analyse the main genes driving separation along PC4.
```{r, echo=FALSE}
##plot top 50 contributing genes to PCA3 (stage)
#find list of top (50) contributing genes
contrib_data <- fviz_contrib(PCAobject_top2000, choice = "var", 
                             axes = 4, 
                             top = 50
                             )

#PC1PC2_TOP50_contributors <- contrib_data[["plot_env"]][["data_sum"]][["name"]]
PC4_TOP50_contributors <- data.frame("genes" = sapply(contrib_data[["plot_env"]][["data_sum"]][["name"]], as.character), 
                                        "contribution to PC1PC2" = contrib_data[["plot_env"]][["data_sum"]][["contrib"]])
#add a column with the original ensembl_gene_ids
PC4_TOP50_contributors$entrez_ID <- entrezid2name_converter$entrez_ID[match(PC4_TOP50_contributors$genes ,entrezid2name_converter$unique_description)] 
#add a column with the ensembl description
PC4_TOP50_contributors$ensembl_description <- annotation_info$ensembl_description[match(PC4_TOP50_contributors$entrez_ID ,annotation_info$entrez_ID)] 
#rearrange column order
PC4_TOP50_contributors <- PC4_TOP50_contributors[,c(3,1,4,2)]

#list top contributing genes
#kable(PC4_TOP50_contributors, caption = "Top50 genes driving PC4 separation")

#save dataframe for manual annotation
#write.csv(PC1PC2_TOP50_contributors,"C://Users/Doctor/Desktop/RNAseq_analyses/Aocellaris_metamorphosis/Saved_objects/PC1PC2_TOP50_contributors_onTop1000variantgenes.csv",row.names = FALSE)


## Formattable output

formattable(PC4_TOP50_contributors, 
             caption ="Top50 genes driving PC1 separation",
            align =c("c","l", "l", "c"), 
            list(`entrez_ID` = formatter("span", 
                                      style = x ~ style(
                                        color = "#A9A9A9", font.weight = "bold")
                                      ), 
                 `contribution.to.PC1PC2`= color_tile(NA,"lightcoral")

                 )
            )

#removed unused variables
rm(contrib_data)
```

Below, the relative expression level of each gene

```{r, fig.width=10, fig.height=60, echo=FALSE}
#http://agroninfotech.blogspot.com/2020/06/biplot-for-pcs-using-base-graphic.html
# we can now verify how these top 50 genes actually move our samples across dimensions
# define palette
mypalette <- brewer.pal(9,"RdBu") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
morecols <- colorRampPalette(mypalette)
colorrange=rev(morecols(100))

#set rows and columns (4)
par(mfrow=c((length(unlist(PC4_TOP50_contributors["genes"]))/3)+1,3))

#plot loop
for (i in 1:length(unlist(PC4_TOP50_contributors["genes"]))) {
  gene_of_interest <- unlist(PC4_TOP50_contributors["genes"])[i]
  
  #normalise values of expression for gene X (e.g hbae5)
  #colorvalues <- 100*(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))/(max(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))) #transpose all values above 0 by adding minimal value (could be negative) to all. The normalised by max intensity to 1. Then on 100 scale
  colorvalues <- 100*(counts_VST_top2000_transposed[,gene_of_interest])/(max(counts_VST_top2000_transposed[,gene_of_interest]))
  
  
  #color datapoints (observations) by expression level
  par(pty = "s",
    cex.main = 1.2,
    cex.lab = 1,
    font.main = 2,
    font.lab = 2,
    family = "sans",
    col.main = "gray10",
    col.lab = "gray10",
    fg = "gray10",
    las = 1)
  
  plot.new()
  
  #we are first going to plot the different conditions (samples), which are in PCAobject_top2000$x 
  plot.window(xlim = extendrange(range(PCAobject_top2000$x[, 3]), f = 0.1), #PCA on x axis
            ylim = extendrange(range(PCAobject_top2000$x[, 4]), f = 0.1), #PCA on y axis
            asp = 1)
  axis(side = 1, 
     labels = TRUE)
  axis(side = 2, 
     labels = TRUE)
  title(main = gene_of_interest,
        xlab = paste("PC 3 (", 
                   round(summary(PCAobject_top2000)$importance[8]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      ylab = paste("PC 4 (", 
                   round(summary(PCAobject_top2000)$importance[11]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      #line = 2,
      adj = 0.5)
  
  # plot the different conditions (samples)
  points(x = PCAobject_top2000$x[,3:4],
       pch = 16,
       cex = 2,
       col = colorrange[colorvalues]
       #col = rep(c("black","gray50", "gray35"),each=7)
       )
  
  #text(PCAobject_top2000$x[,3:4]-5, 
  #     labels = row.names(PCAobject_top2000$x), 
  #     cex = 0.8,
  #     font = 2,
  #     col = "black"
  #     )
  
  
}

#remove unused variables
rm(colorrange, colorvalues, gene_of_interest, i, mypalette, morecols)
```



##### Top contributors PC5 (pre/post metamorphosis?)
We will here analyse the main genes driving separation along PC5.
```{r, echo=FALSE}
##plot top 50 contributing genes to PCA3 (stage)
#find list of top (50) contributing genes
contrib_data <- fviz_contrib(PCAobject_top2000, choice = "var", 
                             axes = 5, 
                             top = 50
                             )

#PC1PC2_TOP50_contributors <- contrib_data[["plot_env"]][["data_sum"]][["name"]]
PC5_TOP50_contributors <- data.frame("genes" = sapply(contrib_data[["plot_env"]][["data_sum"]][["name"]], as.character), 
                                        "contribution to PC1PC2" = contrib_data[["plot_env"]][["data_sum"]][["contrib"]])
#add a column with the original ensembl_gene_ids
PC5_TOP50_contributors$entrez_ID <- entrezid2name_converter$entrez_ID[match(PC5_TOP50_contributors$genes ,entrezid2name_converter$unique_description)] 
#add a column with the ensembl description
PC5_TOP50_contributors$ensembl_description <- annotation_info$ensembl_description[match(PC5_TOP50_contributors$entrez_ID ,annotation_info$entrez_ID)] 
#rearrange column order
PC5_TOP50_contributors <- PC5_TOP50_contributors[,c(3,1,4,2)]

#list top contributing genes
#kable(PC5_TOP50_contributors, caption = "Top50 genes driving PC4 separation")

#save dataframe for manual annotation
#write.csv(PC1PC2_TOP50_contributors,"C://Users/Doctor/Desktop/RNAseq_analyses/Aocellaris_metamorphosis/Saved_objects/PC1PC2_TOP50_contributors_onTop1000variantgenes.csv",row.names = FALSE)

formattable(PC5_TOP50_contributors, 
             caption ="Top50 genes driving PC1 separation",
            align =c("c","l", "l", "c"), 
            list(`entrez_ID` = formatter("span", 
                                      style = x ~ style(
                                        color = "#A9A9A9", font.weight = "bold")
                                      ), 
                 `contribution.to.PC1PC2`= color_tile(NA,"lightcoral")

                 )
            )

#removed unused variables
rm(contrib_data)
```

Below, the relative expression level of each gene:

```{r, fig.width=10, fig.height=60, echo=FALSE}
#http://agroninfotech.blogspot.com/2020/06/biplot-for-pcs-using-base-graphic.html
# we can now verify how these top 50 genes actually move our samples across dimensions
# define palette
mypalette <- brewer.pal(9,"RdBu") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
morecols <- colorRampPalette(mypalette)
colorrange=rev(morecols(100))

#set rows and columns (4)
par(mfrow=c((length(unlist(PC5_TOP50_contributors["genes"]))/3)+1,3))

#plot loop
for (i in 1:length(unlist(PC5_TOP50_contributors["genes"]))) {
  gene_of_interest <- unlist(PC5_TOP50_contributors["genes"])[i]
  
  #normalise values of expression for gene X (e.g hbae5)
  #colorvalues <- 100*(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))/(max(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))) #transpose all values above 0 by adding minimal value (could be negative) to all. The normalised by max intensity to 1. Then on 100 scale
  colorvalues <- 100*(counts_VST_top2000_transposed[,gene_of_interest])/(max(counts_VST_top2000_transposed[,gene_of_interest]))
  
  
  #color datapoints (observations) by expression level
  par(pty = "s",
    cex.main = 1.2,
    cex.lab = 1,
    font.main = 2,
    font.lab = 2,
    family = "sans",
    col.main = "gray10",
    col.lab = "gray10",
    fg = "gray10",
    las = 1)
  
  plot.new()
  
  #we are first going to plot the different conditions (samples), which are in PCAobject_top2000$x 
  plot.window(xlim = extendrange(range(PCAobject_top2000$x[, 5]), f = 0.1), #PCA on x axis
            ylim = extendrange(range(PCAobject_top2000$x[, 6]), f = 0.1), #PCA on y axis
            asp = 1)
  axis(side = 1, 
     labels = TRUE)
  axis(side = 2, 
     labels = TRUE)
  title(main = gene_of_interest,
        xlab = paste("PC 5 (", 
                   round(summary(PCAobject_top2000)$importance[14]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      ylab = paste("PC 6 (", 
                   round(summary(PCAobject_top2000)$importance[17]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      #line = 2,
      adj = 0.5)
  
  # plot the different conditions (samples)
  points(x = PCAobject_top2000$x[,5:6],
       pch = 16,
       cex = 2,
       col = colorrange[colorvalues]
       #col = rep(c("black","gray50", "gray35"),each=7)
       )
  
  #text(PCAobject_top2000$x[,3:4]-5, 
  #     labels = row.names(PCAobject_top2000$x), 
  #     cex = 0.8,
  #     font = 2,
  #     col = "black"
  #     )
  
  
}

#remove unused variables
rm(colorrange, colorvalues, gene_of_interest, i, mypalette, morecols)
```



##### Top contributors PC6 (?)
We will here analyse the main genes driving separation along PC6
```{r, echo=FALSE}
##plot top 50 contributing genes to PCA3 (stage)
#find list of top (50) contributing genes
contrib_data <- fviz_contrib(PCAobject_top2000, choice = "var", 
                             axes = 6, 
                             top = 50
                             )

#PC1PC2_TOP50_contributors <- contrib_data[["plot_env"]][["data_sum"]][["name"]]
PC6_TOP50_contributors <- data.frame("genes" = sapply(contrib_data[["plot_env"]][["data_sum"]][["name"]], as.character), 
                                        "contribution to PC1PC2" = contrib_data[["plot_env"]][["data_sum"]][["contrib"]])
#add a column with the original ensembl_gene_ids
PC6_TOP50_contributors$entrez_ID <- entrezid2name_converter$entrez_ID[match(PC6_TOP50_contributors$genes ,entrezid2name_converter$unique_description)] 
#add a column with the ensembl description
PC6_TOP50_contributors$ensembl_description <- annotation_info$ensembl_description[match(PC6_TOP50_contributors$entrez_ID ,annotation_info$entrez_ID)] 
#rearrange column order
PC6_TOP50_contributors <- PC6_TOP50_contributors[,c(3,1,4,2)]

#list top contributing genes
#kable(PC6_TOP50_contributors, caption = "Top50 genes driving PC4 separation")

#save dataframe for manual annotation
#write.csv(PC1PC2_TOP50_contributors,"C://Users/Doctor/Desktop/RNAseq_analyses/Aocellaris_metamorphosis/Saved_objects/PC1PC2_TOP50_contributors_onTop1000variantgenes.csv",row.names = FALSE)

formattable(PC6_TOP50_contributors, 
             caption ="Top50 genes driving PC1 separation",
            align =c("c","l", "l", "c"), 
            list(`entrez_ID` = formatter("span", 
                                      style = x ~ style(
                                        color = "#A9A9A9", font.weight = "bold")
                                      ), 
                 `contribution.to.PC1PC2`= color_tile(NA,"lightcoral")

                 )
            )


#removed unused variables
rm(contrib_data)

```

Below, the relative expression level of each gene:
```{r, fig.width=10, fig.height=60, echo=FALSE}
#http://agroninfotech.blogspot.com/2020/06/biplot-for-pcs-using-base-graphic.html
# we can now verify how these top 50 genes actually move our samples across dimensions
# define palette
mypalette <- brewer.pal(9,"RdBu") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
morecols <- colorRampPalette(mypalette)
colorrange=rev(morecols(100))

#set rows and columns (4)
par(mfrow=c((length(unlist(PC6_TOP50_contributors["genes"]))/3)+1,3))

#plot loop
for (i in 1:length(unlist(PC6_TOP50_contributors["genes"]))) {
  gene_of_interest <- unlist(PC6_TOP50_contributors["genes"])[i]
  
  #normalise values of expression for gene X (e.g hbae5)
  #colorvalues <- 100*(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))/(max(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))) #transpose all values above 0 by adding minimal value (could be negative) to all. The normalised by max intensity to 1. Then on 100 scale
  colorvalues <- 100*(counts_VST_top2000_transposed[,gene_of_interest])/(max(counts_VST_top2000_transposed[,gene_of_interest]))
  
  
  #color datapoints (observations) by expression level
  par(pty = "s",
    cex.main = 1.2,
    cex.lab = 1,
    font.main = 2,
    font.lab = 2,
    family = "sans",
    col.main = "gray10",
    col.lab = "gray10",
    fg = "gray10",
    las = 1)
  
  plot.new()
  
  #we are first going to plot the different conditions (samples), which are in PCAobject_top2000$x 
  plot.window(xlim = extendrange(range(PCAobject_top2000$x[, 5]), f = 0.1), #PCA on x axis
            ylim = extendrange(range(PCAobject_top2000$x[, 6]), f = 0.1), #PCA on y axis
            asp = 1)
  axis(side = 1, 
     labels = TRUE)
  axis(side = 2, 
     labels = TRUE)
  title(main = gene_of_interest,
        xlab = paste("PC 5 (", 
                   round(summary(PCAobject_top2000)$importance[14]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      ylab = paste("PC 6 (", 
                   round(summary(PCAobject_top2000)$importance[17]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      #line = 2,
      adj = 0.5)
  
  # plot the different conditions (samples)
  points(x = PCAobject_top2000$x[,5:6],
       pch = 16,
       cex = 2,
       col = colorrange[colorvalues]
       #col = rep(c("black","gray50", "gray35"),each=7)
       )
  
  #text(PCAobject_top2000$x[,3:4]-5, 
  #     labels = row.names(PCAobject_top2000$x), 
  #     cex = 0.8,
  #     font = 2,
  #     col = "black"
  #     )
  
  
}

#remove unused variables
rm(colorrange, colorvalues, gene_of_interest, i, mypalette, morecols)
```

#### {-}

### Hierarchical clustering

#### {.tabset}
##### Hierarchical clustering on the top 250 most variable genes

`r emo::ji("magnifying glass tilted right")` An alternative to PCA  for examining relationships between samples is using hierarchical clustering. Heatmaps are a nice visualisation to examine hierarchical clustering of samples. 

```{r, echo=FALSE}
# Estimate the variance for each row in our counts_VST starting object
var_genes <- apply(counts_VST, 1, var)
# Get the gene names for the top 100 most variable genes
top250_genes <- names(sort(var_genes, decreasing=TRUE))[1:250]
#head(print)  #this produced a list with the codes of each of the most variable genes
# Subset vst matrix
counts_VST_top250 <- counts_VST[top250_genes,]

rownames(counts_VST_top250) <- annotation_info$merged_description[match(rownames(counts_VST_top250), annotation_info$entrez_ID)]

```

```{r, fig.height=25, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_top250))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of the top contributors to PC"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = TRUE,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```



##### Thyroid signalling

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes



genelist <- c("111583913", #dio1
              "111563633", #dio2
              "111586185", "111573799", #dio3
              "111588109", #thyroglobulin
              "111577711", #duox
              "111577709", #duox2
              "111576557", #slc5a5/sis/nis
              "111565036", #selenocysteine lyase
              "111562581", #tpo
              "111585831", #slc16a10
              "111580672", #LOC111580672_slco1c1
              "111581275", #slc3a2a
              "111572371", #slc7a11
              "111575976", # LOC111575976 thyroid hormone receptor alpha.2 (thrab)
              "111566418", #LOC111566418_thraa
              "111573399", #thrb
              "111568343", #nr1h4
              "111588196", #LOC111588196_SLC10A1
              "111569563",  #slc10a1
              "111565180", #hhex
              "111570790", #klf9
              "118470383", #nkx2.1
              "111573897", "111567846", #pax2
              "111567309", #pax8
              "111566720", #med1
              "111565463", #ncoa1
              "111587689", #ncoa2
              "111579940", #ncoa3
              "111575203", #ncor1
              "111581903", #ncor2
              "111571366", #slc16a2
              "111576582", #slc2a1a
              "111580035" #slc2a1b
              #"111569632", #ttr
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```

```{r, fig.height=5, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of TH signalling genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = TRUE,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```
##### HPT only

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/sample_metadata.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111569336", #crha
              "111572469", #crhb
              "111572645","111564686", "111575142", #crhbp
              "111570405", #TRH
              "111584834", #TRHRa
              "111568983", #TRHRb
              "111571736", #TRH-DE
              "111568011", #TSHb
              "111569120" #tshr
              
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```


```{r, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_significant_genes.rds")

selected_genes <- selected_genes[selected_genes %in% CPF_significant] #only one
```

```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```

```{r, fig.height=2.6, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of HPT axis genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### HPI axis 

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/sample_metadata.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111569336", #crha
              "111572469", #crhb
              "111572645","111564686", "111575142", #crhbp
              "111568171", #crhr1a
              "111584347", #crhr1b
              "111568629", #crhr2
              "111580118", #pomcaa
              "111577563", #pomcab
              "111584656", #pomcb
              "111571458", #ucn3l
              "111589063", #mc2r
              "111566450" #mrap2 (where is mrap1)
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```


```{r, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_significant_genes.rds")

selected_genes <- selected_genes[selected_genes %in% CPF_significant] #only one
```

```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
rm(selected_genes)

```

```{r, fig.height=3, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of HPI axis genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```



##### Pigmentation/white bands

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111569139", 
              "111565550", 
              "111569513", 
              "111570960", 
              "111588081", 
              "111572545", 
              "111567987",
              "111563999", 
              "111575420",
              "111587765",
              "111580307",
              "111588950",
              "111579034",
              "111578142",
              "111563999",
              "111582670",
               "111574460",
              "111575080",
              "111566467",
              "111569591",
               "111582421",
              "111573654",
              "111579411",
              "111580815",
               "111570150",
              "111571609",
              "111579412",
              "111589141",
               "111564757",
              "111580694",
              "111568296",
              "111572570",
               "111566314",
              "111587270",
              "111577709",
              "111577711",
              "111577940"
              )





#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```

```{r, echo=FALSE}
#only keep iridophore development genes that are responsive to T3, i.e. they go up when you give T3 and they go down when you give MPI
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/T3IOP_upregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/MPI_downregulated_genes.rds")

selected_genes <- selected_genes[selected_genes %in% MPI_downregulated]
```


```{r, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_significant_genes.rds")

selected_genes <- selected_genes[selected_genes %in% CPF_significant] #only one
```



```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```

```{r, fig.height=3, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of iridophore genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### Ossification

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111586202", 
              "111565877", 
              "111575452", 
              "111578891", 
              "111585038", 
              "111568804", #mature osteoblasts
              "111586092",
              "129348561", 
              "111588590", #developing bony elements and ectoderm
              "111579186",
              "111573347",
              "111568799",
              "111583050",
              "111566038",
              "111563675",
              "111581736",
              "111566783", #ucmab
              "111578138", #decorin
              "111585394", #osteoblast differentiation and function
              "111571631", #osteoclasts
              "111583782", #sp7 intermediate osteoblasts
              "129350849", #runx2a
              "111573513", #runx2b
              "111566984", #p38
              "111587875", #p38
              "111580436", #calcineurin expressed in osteoblasts and enhances the differentiation of osteoblasts
              "111587000",
              "111586959",
              "111568611", #fgfr4
              "111564840", #fibronectin1b
              "111581811",
              "111583895", #osteocalcin2
              "111573268",#col10a1a
              "111581321", #spp1
              "111580793", #spp2
              "111568939", #trpv6
              "111583163",
              "111585858",
              "111564978",
              "111566783"
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```

```{r, echo=FALSE}
#only keep CPF DE genes
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_upregulated_genes.rds")

selected_genes <- selected_genes[selected_genes %in% union(CPF_upregulated, CPF_downregulated)] #only one
```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
rm(selected_genes)

```

```{r, fig.height=3, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of ossification genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = TRUE,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### Vision/opsins

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/sample_metadata.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111570385","111573988","111586084","111567778","111573963","111576828","111575293","111575291","111575250", 
              
              "111579646","111586232","111567772","111563423","111581093","111578886","111563016","111587070","111587069","111588534","111584765","111581525","111564732","111579901","111571076","111569239","111573371","111579255","111582970","111582442","111588513","111585507","111584041","111572086","111563629","111575524","111588514","111569185","111580086","111567077","111573047","111564372","111564656","111578133","111581809","111581810","111574501","111574862","111563131","111565835","111586731","111567440","111575107","111575698","111575703","111573588","111575014"
              )


#genelist <- c("111570385","111573988","111586084","111567778","111573963","111576828","111575293","111575291","111575250")


#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```

```{r, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_upregulated_genes.rds")

selected_genes <- selected_genes[selected_genes %in% union(CPF_downregulated, CPF_upregulated)] #only one
```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```

```{r, fig.height=3, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of iridophore genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = TRUE,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```



##### NMJ genes

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111566251", 
              "111568185", 
              "111571932", 
              "111577329", 
              "111581865", 
              "111566250", #mature osteoblasts
              "111566253",
              "111575390", 
              "111577330", #developing bony elements and ectoderm
              "111581113",
              "111583962",
              "111583968",
              "111581877",
              "111567659",
              "111588831"
              
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```

```{r, echo=FALSE}
#only keep CPF DE genes
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_upregulated_genes.rds")

selected_genes <- selected_genes[selected_genes %in% union(CPF_downregulated, CPF_upregulated)] #only one
```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
rm(selected_genes)

```

```{r, fig.height=3, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of NMJ genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### Cholesterol

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111564800", #acetylCoA to lanosterol
              "111570356", 
              "111575348", "111579328",
              "111568310", 
              "111569478", 
              "111577166", 
              "111565278",
              "111571978", 
              "111569937", 
              "111562938",
              "111582860",
              
              
              "111581125", #lanosterol to cholesterol
              "111565075",
              "111572615", "111583488", #==DHCR14
              "111574709", "111565582", "111563582", "111586999", "111574572", #C4 demethylation complex
              "111580686", "111584459",
              "111568124", "111573906",
              "111567200",
              
              "111570931", "111572884", #cholesterol export/use
              "111563899", "111583785",
              "111568530",
              
              "111563276", #vitaminD3 Cholecalciferol to calcitriol
              "111587639",
              "111579624",
              "111577005", "111565886"
              
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```

```{r, echo=FALSE}
#only keep CPF-DE genes
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_upregulated_genes.rds")

selected_genes <- selected_genes[selected_genes %in% union(CPF_downregulated, CPF_upregulated)] #only one
```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```

```{r, echo=FALSE}
#sort genes based on metabolic pathway
counts_VST_selectedgenes_sorted <- counts_VST_selectedgenes
counts_VST_selectedgenes_sorted <- counts_VST_selectedgenes_sorted[match(selected_genes$description, rownames(counts_VST_selectedgenes_sorted)), ]
```


```{r, fig.height=5, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes_sorted))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of cholesterol and vitaminD genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = F,
        show_row_dend = F,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### Steroidogenesis

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111587899", #CYP11A1/P450scc 
              "111575471", #FDX1/adrenoxin
              "111570558", #FDXR ferredoxin reductase
              "111570570", #Hsd3b(2?)
              "111563640", #cyp17a1
              "111575402", #pgr/NR3C3  progesterone receptor
              
              #mineralcorticoids and glucocorticoids; but also androstenedione
              #"", #cyp21(a2?)
              "111567446", "111575932", #cyp11b1/cyp11c
                #cortisone
              "", #hsd11b1 (will activate)
              "111567954", #hsd11b2 (will inactivate to cortisone)
              "111565142",#GR1/nr3c1a,
              "111574492",#GR2/nr3c1b 
              #"", #androstenedione receptor?
              
                #mineral/corticosterone
              #"",#cyp11b2
              #"", #aldosterone synthase?
              "111563254", #MR/nr3c2
              
              #testosterone
              "111576668", #hsd17b3
              "111572734", #hsd17b14
              "111569843", #srd5a1
              "", #HSD3a/AKR1C4 3α-hydroxysteroid dehydrogenase
              "111587360", #AR? there should be two
              
                #estrogen
              "111565746", "111577263", #aromatase
              #"", #Estrogen synthetase CYP19A1
              "111572734", #HSD17b14 β-Hydroxysteroid dehydrogenase type 14
              "111571044",  #ER esr1 (ERa)
              "111588998", #ER esr2a (ERbII)
              "111586778", #ER esr2b (ERbI)
              "111567926" #gper
              
              #111575402
              
              
              #stard5?
              #fdx2?
              #others?
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```


```{r, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_significant_genes.rds")

selected_genes <- selected_genes[selected_genes %in% CPF_significant] #only one
```

```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```


```{r, fig.height=4, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes_sorted))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of steroidogenesis genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### Bile acids

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111564965", #ABC transporter G5 (cellular export)
              "111564964", #ABC transporter G8 (cellular export)
              "111575042", #star (mito import)
              "111576985", #cyp7a1
              "111564486", #cyp7b1 (alternative)
              "111588900", #hsd3b7
              "111568649", "111568654", #CYP8B1 (cholic acid shunt)
              "111573167", #AKR1D1/SRD5B1
              #"X", #AKR1C4
              "111568532", "111574457", #CYP27A1 (also involved in alternative path, and CA shunt)
              "111563882", "111577715", #SLC27A5
              "111564846", #AMACR
              "111564207", "111564180", #ACOX2 (could not find)
              "111564685", #HSD17B4
              "111587618", "111576150", #Peroxisomal thiolase (SCP2)
              
              #conjugation
              "111569566", #BAAT (could not find)
              #excretion
              "111572824", "111564168", #ABC11/BSEP ATP-binding cassette, sub-family B member 11 (could not find). Note that only acbc1b is liver (i.e. bile secretion), Abcb11a is intestinal
              "111565670" #ATP8B1?
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```

```{r, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_significant_genes.rds")

selected_genes <- selected_genes[selected_genes %in% CPF_significant] #only one
```

```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```


```{r, fig.height=4, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes_sorted))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of bile acids genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```
##### Cholesterol regulation and transport

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#https://www.ncbi.nlm.nih.gov/books/NBK305896/

#select genes

genelist <- c("111580133", "111567927", #upstream cholesin regulation
              "111578189", "111583833", #SREBP...srebf1/2
              "111572868", #scap
              "111572568", "111581423", "111588229",#spring1/erlin
              "111571031", #LXR/nr1h3
              #reverse cholesterol transport/ HDL
              #removal of excess tissue cholesterol, and bring back to liver for redistribution, or bile expulsion
              "111579104","111575059","111564949",
              "111574547", #Apoa1a/b #apoa1a lost?
              "118469590", #Apoa2
              "111562603", "111562606", "111588528",#Apoa4a/b
              "111579104", "111575059",#afp4
              
              "111575002", "111570931","111565691", #abca1a/b
              "111574427",  #scarb1, 
              "111580395","111575640", "111583031",#(scarb2a, scarb2b, scarb2c)
              "111572688", #npc2
              "111588691", #abcg
              "111580988", "111571376", #lcat
              
              #delivery back to the liver
              #direct, the whole HDL is taken up
                #LDL receptor
              "111578413", #hepatic lipases
                #ApoE
              "111568009", "111575117", "111587369", "111564477", "111586529",# LRP and syndecan-4 
              #direct, HDL directly binds scarb1 and cholesterol is taken
              #indirect, transfer to LDL/Apob100
              "111569004",#CETP
              
              #distribution from the liver/LDL (endogenous lipoprotein pathway)
              #will be etserified when it's distributed
              "111583607", "111574222",#ACAT
              "111563899", "111583785",#SOAT
              "111575319", #MTTP/PDIA
              "111586299","111566432", #Apoba/b
              #"", #ApoB100
              "111588529", #ApoC1/2/4 (secondary components; 1/4 lost?)
              "111562605","111588526", #ApoE (secondary components)
              
              
              #receival of cholesterol (liver LDL)
              "111566387", "111570157",#LDLRa/b
              "111581309", #(vLDLr)
              "111567577", #IDOL mylipa/b
              "111581127", #pcsk9
              "111573603", #NPC1 
              "111572824", "111564168", #ABC11/BSEP ATP-binding cassette, sub-family B member 11 (could not find). Note that only acbc1b is liver (i.e. bile secretion), Abcb11a is intestinal
              "111565670", #ATP8B1?
              "111585084", "111586568", "111586565", "111567821", #de-esterification: LIPA, LPL
              "111571620", "111571946", 
              
              #secretion to bile
              #either direct
              "111564965", "111564964"# ABCG5 and ABCG8 
             #or bile pathway
              
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```

```{r, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_significant_genes.rds")

selected_genes <- selected_genes[selected_genes %in% CPF_significant] #only one
```

```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```

```{r, fig.height=8, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes_sorted))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of bile acids genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### Liver function

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111580890", "111580892", "111580894", "111580895",#alpha 2 macroglobulins
              "111578413", #hepatic lipase
              "111578802", #transferrin
              "111572849", #serum amyloid A
              "111565453", #plasminogen
              "111582600", #ceruloplasmin
              "111584065", #complementC3
              "111583320", #coagulation factor IX
              "111570235", #selenoP2
              "111568029" #serpinf2a

              
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```

```{r, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_significant_genes.rds")

selected_genes <- selected_genes[selected_genes %in% CPF_significant] #only one
```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```


```{r, fig.height=4, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes_sorted))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of bile acids genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### Oxidative

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111578837", #catalase
              #superoxide dismutases
              "111575864", "111574223", "111575331", #sod1/2/3
              "111575353", #ccs
              #glutathione peroxidases
              "111574945", "111581951", #gpx11/b 
              "111588174", #gpx2
              "111577687", #gpx3
              "111563473", "111571007", #gpx4a/gpx4b 
              "111582504", #gpx7
              "111580757", #gpx8
              "111567860", #gpx9
              #antioxidant genes
              "111569366", #Nqo1
              "111575507", "111584778", #Ho-1 (spleen liver)
              "111569915", "111567707", #HO-2 (intestine)
              "111570374", #blvra/blvrb
              "111562529", "111565959", "111565989", "111568569",
              "111571828", "111580426",#ugt
              "111566481", "111586211", "111570618", #Gcl
              "111583489", "111573235", "111572235", "111585235", #Eh-1 microsomal epoxide hydrolase
              "111572118", #Srxn1
              #"",#Mrps multidrug resistance-associated proteins
              "111572824", "111564168", #ABC11/BSEP ATP-binding cassette, sub-family B member 11 (could not find). Note that only acbc1b is liver (i.e. bile secretion), Abcb11a is intestinal
              "111562997","111563019", "111569059", #ces
                #GSTs  glutathione S-transferases
              #"", 
              #signalling
              "111577847", #Nrf2?
              "111582902", "111570165" #Keap1
              #"", #mafs
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```



```{r, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_significant_genes.rds")

selected_genes <- selected_genes[selected_genes %in% CPF_significant] #only one
```

```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```


```{r, fig.height=6, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes_sorted))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of bile acids genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```



##### Immunity

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes


genelist <- c("111563069", "111563068", #chemokines and inflammation
              "111569545", 
              "111580200", 
              "111562955", "111562957",
              "111577429", 
              "111580483",
              "111571831", "111578399", 
              "4850669", "111580534",
              
               "118471831", "118471830", #(interferon gamma)
              "111567671", "111583941",
              "111588419",
              "111572427",
              "111566617",
              
              "118471608", "111570784", "111566734", "111570786", #(interferon alpha/beta (phi))
              "111588499", "111588460","111588602",
              
              "111584600", #interferon and interferon related
              "111574762", "111574765",
              "111585454", "129347476",
              "111562646", "111562649", "111577915",
              "111588558",
              "111584047",
              "111582153", "111582159",
              
              #nucleic acid sensing
              "111582915", #toll3
              "111575744", #mda5
              "111584798", "111575035", "111566535","111575123", #RIG
              
              "111588283", #MAVS
              "111583331",
              "111577797", 
              "111575755",
              "111576450", "111568017", "111584314", "111571002",
              "111583532",
              "111568701",
              
              "111576738",
              "111581409", "111567460", "111577292", "111566565", "111582017",
              "111581683",
              "111577551", "111581711",
              "111583748", "111577944", "111582710", "111563992", "111574678",
              "111587970", "111563857", "111584600", "111584372", #IRFs 1/3/7
              
              "111586938", "111567610", #cgas-sting
              
             
              
              
              "111588095")



genelist <- c("X", #chemokines and chemokine receptors + inflammation
              "111563069", "111563068", 
              "111569545", 
              "111580200", 
              "111562955", "111562957",
              "111577429", 
              "111580483",
              "111571831", "111578399", 
              "4850669", "111580534",
              
              "111586938", "111563935", #dsRNA sensing and response
              "111584798",
              "111583331",
              "111567610",
              "111576250",
              "111573712", "111573720", "111573734",
              
              "111588694", #(response involving nucleotides)
              "111588695",
              "111574265",
              "111562645",
              
              
              "111584600", #interferon and interferon related
              "111574762", "111574765",
              "111585454", "129347476",
              "111562646", "111562649", "111577915",
              "111588558",
              "111584047",
              "111582153", "111582159",
              
              "118471831", "118471830", #(interferon gamma)
              "111567671", "111583941",
              "111588419",
              "111572427",
              "111566617",
              
              "118471608", "111570784", "111566734", "111570786", #(interferon alpha/beta (phi))
              "111588499", "111588460","111588602"
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```

```{r, echo=FALSE}
#only keep iridophore development genes that are responsive to T3, i.e. they go up when you give T3 and they go down when you give MPI
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/T3IOP_upregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/MPI_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_upregulated_genes.rds")

selected_genes <- selected_genes[selected_genes %in% union(CPF_downregulated, CPF_upregulated)] #only one
```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```

```{r, echo=FALSE}
#sort based on immune categories
counts_VST_selectedgenes_sorted <- counts_VST_selectedgenes
counts_VST_selectedgenes_sorted <- counts_VST_selectedgenes_sorted[match(selected_genes$description, rownames(counts_VST_selectedgenes_sorted)), ]
```


```{r, fig.height=6, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes_sorted))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of Immunity genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = F,
        show_row_dend = F,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```


##### DNA_repair

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE}
#select genes

genelist <- c("111571778", #E2F1 pathway
              "111577644",
              
              "111584657", #cell membrane damage
              "111574372", #senescence/cell cycle
              "111582895", 
              "111577187",
              "111588942",
              "111573057",
              "111563434",
              "111580652",
              
              "111563642", #cell cycle
              "111581445", "111564411", "111562849",
              "111576335", "111568375",
              "111579731",
              "111588254", "111578176",
              "111574031", "111582432", "111569251",
              
              "111574402", #NHEJ
              "111588580",
              "111565415", "111574562",
              "111578673",
              "111582839",
              "111580627", "111576022",
              "111566556",
              
              "111568731", # DSB and HR/Fanconi
              "111585542",
              "111576667",
              "111566993",
              "111570203", "111584109",
              "111584863",
              "111573217",
              "111586009",
              
              "111581904",
              "111563082",
              "111567306",
              "111581228",
              "111587086", "111570500", "111586798",
              "111572887",
              "111566265",
              "111563668",
              
              "111575168", #rad dsb detection
              "111571484",
              "111582787",
              "111581756",
              "111580833",
              "111588143",
              
              "111564068", #interstrand crosslink repair
              "111579911",
              "111579441",
              "111577714",
              "111569906",
              "111581512",
              
              "111588554", #base excision repair
              "111570389",
              "111587643",
              "111567879",
              "111567882",
              "111583792",
              "111583902",
              "111574839",
              "111571908",
              "111587902",
              "111581512",
              "111580604", "111588339",
              "111577272",
              "111574508",
              "111574625",
              "111571483",
              "111572504",
              "111571989",
              
              
              "111576505", #ssDNA
              "111567173",
              "111578679",
              "111576631",
              "111565135",
              "111563836",
              "111587039",
              "111569022",
              
              "111569726",
              "111563381",
              "111575174",
              "111582416",
              
              "111577896", #mismatch repair
              "111567184",
              "111564701",
              "111573097",
              "111574574",
              "111575371",
              "111564421",
              "111586691"
            
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```

```{r, echo=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/T3IOP_upregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/MPI_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_upregulated_genes.rds")

selected_genes <- selected_genes[selected_genes %in% union(CPF_downregulated, CPF_upregulated)] #only one
```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```

```{r, echo=FALSE}
#sort based on DNA repair families
counts_VST_selectedgenes_sorted <- counts_VST_selectedgenes
counts_VST_selectedgenes_sorted <- counts_VST_selectedgenes_sorted[match(selected_genes$description, rownames(counts_VST_selectedgenes_sorted)), ]
```


```{r, fig.height=6, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes_sorted))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of Immunity genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = F,
        show_row_dend = F,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```


##### UP T3 and CPF (selected)

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/sample_metadata.rds")
```

```{r, echo=FALSE}
#load list of genes
upregulated_CPFandT3IOP_df <- read.csv(file="D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/upregulated_CPFandT3IOP_clean.csv")

#load differentially expressed genes between S1 and S7, ranked by FC
DE_genes <- upregulated_CPFandT3IOP_df$ensembl_ID_CPF

#select genes

genelist <- c("111565606", "111565785", "111569545",
              #"111588557", "111584687", "111586659",
              "111565603", "129350609", "111566617", 
              "111584583", "111562713", "111571519", 
              "111584589", "111569157", "111586660",
              "111574043", "111588744"              )

#genelist <- upregulated_CPFandT3IOP_df$entrez_ID

#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```

```{r, fig.height=5, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of HPT axis genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### DOWN CPF and MPI (selected)

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/sample_metadata.rds")
```

```{r, echo=FALSE}
#load list of genes
downregulated_CPFandMPI_df <- read.csv(file="D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/downregulated_CPFandMPI_clean.csv")

#load differentially expressed genes between S1 and S7, ranked by FC
DE_genes <- upregulated_CPFandT3IOP_df$ensembl_ID_CPF

#select genes

genelist <- c("111574818", "111582400", "111570155",
              "111585684",
              "111581053", "111582409", "111579739"
              
              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```

```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```

```{r, fig.height=3, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of HPT axis genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

##### DOWN CPF and T3 (selected)

```{r, echo=FALSE}
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/sample_metadata.rds")
```

```{r, echo=FALSE}
#load list of genes
downregulated_CPFandT3_df <- read.csv(file="D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/downregulated_CPFandT3IOP_clean.csv")

#load differentially expressed genes between S1 and S7, ranked by FC
DE_genes <- upregulated_CPFandT3IOP_df$ensembl_ID_CPF

#select genes

genelist <- c("111574812", "111574813", "111574814", "111574811",
              "111566442", "111566432", "111564925", "111570821", "111566479", "111588379","111566479", "111571760", "111564800"              )



#annotation_info[annotation_info$ensembl_ID %in% genelist,c("ensembl_ID", "entrez_ID")]



selected_genes <- c(genelist)



#the subset above was chosen based on the ensemble annotation. convert to NCBI
#selected_genes <- annotation_info$entrez_ID[match(selected_genes, annotation_info$ensembl_ID)]


```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#no missing genes

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

#kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes present in the dataset (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)
rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]

#remove unused variables
#rm(selected_genes)

```

```{r, fig.height=3.5, fig.width=10, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        column_title = gt_render(
          "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of HPT axis genes"
          ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        #left_annotation = rowAnn,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```

#### {-}

### Differential Expression Analysis

#### {.tabset}
##### Differential gene expression analysis

`r emo::ji("magnifying glass tilted right")`  For differential expression , gene expression is rarely considered at the level of raw counts since libraries sequenced at a greater depth will result in higher counts. Rather, it is common practice to transform raw counts onto a scale that accounts for such library size differences. Popular transformations include counts per million (CPM), log2-counts per million (log-CPM), reads per kilobase of transcript per million (RPKM), and fragments per kilobase of transcript per million (FPKM). Here raw counts are converted log-CPM values using the voom function in limma package.

<br/>
<p class="comment">
**What is voom doing?** Counts are transformed to log2 counts per million reads (CPM), where “per million reads” is defined based on the normalization factors we calculated earlier
A linear model is fitted to the log2 CPM for each gene, and the residuals are calculated
A smoothed curve is fitted to the sqrt(residual standard deviation) by average expression (see red line in plot above)
The smoothed curve is used to obtain weights for each gene and sample that are passed into limma along with the log2 CPMs.
</p>

```{r echo=FALSE, fig.height=6, fig.width=10, warning=F, paged.print=FALSE}
# https://rpubs.com/jrgonzalezISGlobal/transcriptomic_analyses
#we will work from our filtered object (i.e. untransformed) DGE_object_filterednormed (Not CPM because voom will do log2CPM automatically)

#Load the object "DGE_object_filterednormed" and plot summary plots as reminder
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/DGE_object_filterednormed.rds")

# set space for 5 plots
par(mfrow=c(2,3))

plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, "Summary parameters \n of loaded DGE object \n (filtered, TMM normalised)", cex=1.2)

#LIBRARY SIZES

#Plot library sizes AFTER normalisation (relative to smallest one)
# notice that even the normalised DGE object does not store the converted lib.sizes (lib.size * norm factor)
# you need to calculate it explicitely with effectiveLibSizes(), now getNormLibSizes

barplot(getNormLibSizes(DGE_object_filterednormed, log = F)/1e6,
        #effectiveLibSizes(DGE_object_filterednormed, log = F)/effectiveLibSizes(DGE_object_filterednormed, log = F)[21], #i.e. reference to sample 21
        names=colnames(DGE_object_filterednormed),                  # use sample names
        las=2,                                       # The las argument rotates the axis names
        ann=FALSE, 
        cex.names=0.75,
        col = color_list,
        border = NA,
        ylim=range(pretty(c(0, 15))), #otherwise y axis too short
        #ylim=range(pretty(c(0, 4)))  #if showing relative size
        )
mtext(side = 1, text = "Samples", line = 4)
mtext(side = 2, text = "Library size (millions)", line = 3)
title("Effective library size \n (TMM-adjusted for compositional bias)")
#abline(h=1,col="dodgerblue")

#BOXPLOT COUNTS

boxplot(log2(as.matrix(DGE_object_filterednormed$counts)+0.25), 
        xlab="", 
        ylab="log2 (counts+0.25)",
        #ylim=c(0,20),
        las=2,
        col = color_list,
        border = "gray")
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(log2(as.matrix(DGE_object_filterednormed$counts)+0.25)),col="blue")
title("Boxplots of DGE counts")


#COUNT DENSITY DISTRIBUTION

plot(density(log2(as.matrix(DGE_object_filterednormed$counts[,1])+0.25)), 
     main="",
     col= color_list[1],
     xlab="log2 (counts+0.25)",
     ylab="Density",
     ylim=range(pretty(c(0, 0.25)))
     )

for (i in 2:ncol(DGE_object_filterednormed$counts)) {
  lines(density(log2(as.matrix(DGE_object_filterednormed$counts[,i])+0.25)), 
        col= color_list[i]
        )
  title(main = NULL)
}
# Let's add a blue vertical line that corresponds to the median logCPM
abline(v=median(log2(as.matrix(DGE_object_filterednormed$counts))+0.25),col="blue")
title("Density distribution of DGE counts")

#MEAN-VARIANCE PLOT
# define a function that calculates variance
rowVar <- function(x) apply(x,1,var)

plot(rowMeans(log2(DGE_object_filterednormed$counts+0.25)),rowVar(log2(DGE_object_filterednormed$counts+0.25)),
     xlab='log2 (mean count+0.25)',
     ylab='log2 (variance+0.25)',
     col = alpha("black", 0.5),
     main="Mean-variance plot")


#RLE PLOTS
RLE_countsDGE_forggplot <- sweep(log2(DGE_object_filterednormed$counts+0.25), 
                                 MARGIN=1, 
                                 STATS= rowMeans(log2(DGE_object_filterednormed$counts+0.25)))
RLE_countsDGE_forggplot <- as.data.frame(RLE_countsDGE_forggplot)
RLE_countsDGE_forggplot$genes <- row.names(RLE_countsDGE_forggplot)
RLE_countsDGE_forggplot  <- RLE_countsDGE_forggplot  %>%  pivot_longer(-genes, names_to = "Condition", values_to = "deviations")
#lock in the order of the samples, or they will be rearranged during plotting
RLE_countsDGE_forggplot$Condition <- factor(RLE_countsDGE_forggplot$Condition, levels =  ordered_levels)

#since this is a ggplot and we want to  plot it with baseR plots, we need to do this
#https://stackoverflow.com/questions/14124373/combine-base-and-ggplot-graphics-in-r-figure-window
plot.new()              
vps <- baseViewports()
pushViewport(vps$figure) ##   I am in the space of the RLE plots
vp1 <-plotViewport(c(1.8,1,0,1)) ## create new vp with margins, you play with this values 
#prepare the actual ggplot
plot6 <- ggplot(RLE_countsDGE_forggplot, aes(x=Condition, y=deviations, fill=Condition)) +
  geom_violin(trim=FALSE)+
  scale_fill_manual(values=color_list)+
  #geom_jitter(shape=16, position=position_jitter(0.2), alpha=0.01) +
  #geom_boxplot(width=0.1, outlier.color = "black", outlier.alpha=0.01)+
  stat_summary(fun=median, pch=21, size=0.5, color="black", fill="dodgerblue")+
  theme_classic()+
  theme(legend.position="none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  geom_hline(yintercept=0, linetype="longdash", color = "dodgerblue", size=0.5)+
  ylim(c(-15,15))+
  xlab("") + 
  ylab("Relative log2 expression of each gene \n (expression-mean)")+
  ggtitle("Relative Levels of Expression: \n DGE counts")+
  NULL
#print the ggplot in the correct viewport
print(plot6,vp = vp1)

##remove unused variables and functions
rm(i, RLE_countsDGE_forggplot, rowVar, vp1, vps, plot6)
```

<br />
* __Step 2:__  We can now process our original (filtered, TMM-normalised) object through the voom-limma pipeline, which will normalised it by library size by calculating logCPM and using the normalisation factors provided, and then fit a linear model through it:

```{r echo=FALSE, fig.height=6, fig.width=9, warning=TRUE, paged.print=FALSE}
# https://rpubs.com/jrgonzalezISGlobal/transcriptomic_analyses
#we will work from our filtered object (i.e. untransformed) DGE_object_filterednormed (Not CPM because voom will do log2CPM automatocally)
#this produces the 0/1 design matrix, gene expression data modelled by stage 
# this just means model.matrix( ~-1+ DGE_object_filterednormed_reassigned$samples$stage_reassigned) 
model_matrix<- model.matrix( ~-1+ treatment, data=DGE_object_filterednormed$samples) 

#If counts is a DGEList object from the edgeR package, then voom will use the normalization factors found in the object when computing the logCPM values. In other words, the logCPM values are computed from the effective library sizes rather than the raw library sizes. 
DGE_object_filterednormed_Voomed <- voom(DGE_object_filterednormed, 
                                         design = model_matrix, 
                                         plot = FALSE)   #we will put FALSE here and plot the same data manually
#a DGE object that incorporates the matrix and the mean-variance weights   

#Mean-variance relationship now stored in voom will be injected into the statistical model as observational-level weights.
# When the weights are incorporated into a linear modeling procedure, the mean-variance relationship in the log-cpm values is effectively eliminated.


#PLOTTING
# set space for 5 plots
par(mfrow=c(2,3))

plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, "Applying voom to the \n  DGE object", cex=1.2)

#MEAN-VARIANCE PLOT (original)
# define a function that calculates variance
rowVar <- function(x) apply(x,1,var)

plot(rowMeans(log2(DGE_object_filterednormed$counts+0.25)),
     rowVar(log2(DGE_object_filterednormed$counts+0.25)),
     xlab='mean log2(counts+0.25)',
     ylab='variance log2(counts+0.25)',
     pch=16,
     cex=0.8,
     col = alpha("black", 0.10),
     main="Mean-variance plot \n (original, not CPM-normalised)")


#MEAN-sqrt(standard deviation) (original)
# define a function that calculates variance
rowVar <- function(x) apply(x,1,var)

plot(rowMeans(log2(DGE_object_filterednormed$counts+0.25)),
     rowVar(log2(DGE_object_filterednormed$counts+0.25))^(1/4),
     xlab='mean log2(counts+0.25)',
     ylab='sqrt(sigma) log2(counts+0.25)',
     pch=16,
     cex=0.8,
     col = alpha("black", 0.10),
     main="Mean-sigma plot \n (original, not CPM-normalised)")


#Let us now plot the same data, after CPM normalisation (the same way voom would do)

#MEAN-VARIANCE PLOT (CPM-normalised)
#store the library millions as calculated by voom (effective library size + 1, all in millions)
permillions <- ((DGE_object_filterednormed$samples$lib.size*DGE_object_filterednormed$samples$norm.factors)+1)/1e6

# define a function that calculates variance
rowVar <- function(x) apply(x,1,var)

plot(rowMeans(log2((DGE_object_filterednormed$counts+0.5)/permillions))+mean(log2(permillions)), #note that voom adds 0.5, not 0.25 #also, for some reason voom adds the log2 of the mean librarysize (in millions)
     rowVar(log2((DGE_object_filterednormed$counts+0.5)/permillions)),
     xlab='mean log2(counts+0.5)+ \n average library size',
     ylab='variance log2(counts+0.5)',
     pch=16,
     cex=0.8,
     col = alpha("black", 0.10),
     main="Mean-variance plot \n (CPM-normalised)")


#MEAN-sqrt(standard deviation) (CPM-normalised)
# define a function that calculates variance
rowVar <- function(x) apply(x,1,var)

plot(rowMeans(log2((DGE_object_filterednormed$counts+0.5)/permillions))+mean(log2(permillions)),
     rowVar(log2((DGE_object_filterednormed$counts+0.5)/permillions))^(1/4),
     xlab='mean log2(counts+0.5)+ \n average library size',
     ylab='sqrt(sigma) log2(counts+0.5)',
     pch=16,
     cex=0.8,
     col = alpha("black", 0.10),
     main="Mean-sigma plot \n (CPM-normalised)")

#MEAN-VARIANCE PLOT (as plotted by voom)
# https://rdrr.io/bioc/limma/src/R/voom.R

lib.size <- DGE_object_filterednormed$samples$lib.size*DGE_object_filterednormed$samples$norm.factors
counts <- DGE_object_filterednormed$counts
#Fit linear model to log2-counts-per-million
y <- t(
  log2(
    t(counts+0.5)/(lib.size+1)*1e6
    )
       )
fit <- lmFit(y,model_matrix)

#MEAN-VARIANCE PLOT 2
# define a function that calculates variance
#	Fit lowess trend to sqrt-standard-deviations by log-count-size
sx <- fit$Amean+mean(log2(lib.size+1))-log2(1e6)
sy <- sqrt(fit$sigma)

l <- lowess(sx,sy,f=0.5)

plot(sx,
     sy,
     xlab="log2( count size + 0.5 ) + \n average library size",
     ylab="Sqrt( standard deviation )",
     pch=16,
     cex=0.8,
     col = alpha("black", 0.10))
title("voom: Mean-variance trend")
lines(l,col="dodgerblue",lwd=2.0)

#remove unused variables
rm(counts, DGE_object_filterednormed, fit, l, y, permillions, sx, sy, rowVar)


#Save the voomed (filtered, TMM-normalised + logCPM), stage-reassigned, object for differential expression analysis
#save(DGE_object_filterednormed_Voomed, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/DGE_object_filterednormed_Voomed.rds")

```
<p class="comment">
Notice how I could not quite reproduce the limma-lmFit calculated sigma values. (compare with manually generated ones in plot just next to it). Will need to figure out the details of the limma sigma calculation.
</p>


```{r echo=FALSE}
# standard pipeline with lmFIT but try lm() [chunck above]

# apply linear regression model with mean-variance relationship weights calculated above
# lmFit fits a linear model using weighted least squares for each gene:
#extract the linear models that had been fit in the voom object
fit_results <- lmFit(DGE_object_filterednormed_Voomed) #this is the same as doing #fit_results <- lmFit(DGE_object_filterednormed_Voomed, weights=DGE_object_filterednormed_Voomed[["weights"]])

#same as doing lm() individually on each gene (can also supply here the model matrix, but already incorporated through vooming)
head(coef(fit_results))
```




##### effect of CPF (CPF vs DMSO)


```{r, echo=FALSE, results = FALSE}
#Load voom object "DGE_object_filterednormed_Voomed" for differential expression analysis, and annotation info
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/DGE_object_filterednormed_Voomed.rds")
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated.rds") 

#rename the dataframe as "annotation_info"
annotation_info <- annotation_info_NCBIEnsembl
#remove the column with the original description
#annotation_info <- subset(annotation_info, select = -c(original_description))

#remove unused variables
rm(annotation_info_NCBIEnsembl)

#----------

# apply linear regression model with mean-variance relationship weights calculated above
# lmFit fits a linear model using weighted least squares for each gene:
#extract the linear models that had been fit in the voom object
fit_results <- lmFit(DGE_object_filterednormed_Voomed) #this is the same as doing #fit_results <- lmFit(DGE_object_filterednormed_Voomed, weights=DGE_object_filterednormed_Voomed[["weights"]])

#same as doing lm() individually on each gene (can also supply here the model matrix, but already incorporated through vooming)
head(coef(fit_results))
```


```{r, echo=FALSE, fig.height=2.5, fig.width=9, warning=TRUE, paged.print=FALSE}
#Compute comparisons of interest

#Comparisons between groups (log fold-changes) are obtained as contrasts of these fitted linear models:
contrast_matrix <- makeContrasts(treatmentCPF - treatmentDMSO ,  # positive logchanges will be higher in S4, negative will be higher in S1
                       levels = colnames(coef(fit_results)))
#show newly created contrast matrix
contrast_matrix  # positive logchanges will be higher in S4, negative will be higher in S1

#add the contrast matrix to our fit object
# need to do new objects or it chenges  coefficients instead?
fit_results_contrasted <- contrasts.fit(fit_results, contrast_matrix)

#Empirical Bayes smoothing of standard errors (shrinks standard errors that are much larger or smaller than those from other genes towards the average standard error) (see https://www.degruyter.com/doi/10.2202/1544-6115.1027)
fit_results_contrasted <- eBayes(fit_results_contrasted) #when applied to the output of lmFit(), performs the pooled estimation of standard errors that results in the moderated t-statistics and resulting p-values.

#p.adjust (but this will be done automatically by TopTable function)
#indiv.P.values<-apply(tmp[["p.value"]], 2, p.adjust, method="BH")
#tmp[["BH.adjusted.pvalue"]] <- indiv.P.values


#remove unused variables
rm(fit_results, DGE_object_filterednormed_Voomed)
```
<br/>
Below, a list of all the genes that appear significantly differently expressed between treatment and control (in either direction; __Table 1__). In __Table 2__, the subest of significantly changing genes whose fold-change is bigger than 2folds (in either direction). These genes are ranked in order of decreasing fold change. <br/>

```{r, echo=FALSE}
#What genes are most differentially expressed?
full_top_table <- topTable(fit_results_contrasted, 
                           sort.by = "logFC", 
                           n = Inf, 
                           adjust.method="BH",
                           confint=0.95, #note that these are not adjusted for multiple testing 
                           #p.value=0.05
                           )

#create column that shows logFoldChange as the Fold Change
full_top_table["FC"] <- sign(full_top_table["logFC"])*2^abs(full_top_table["logFC"])

#save list
#save(full_top_table, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/full_top_table_CPFvsDMSO.rds")
#load(file = "C://Users/Doctor/Desktop/RNAseq_analyses/Aocellaris_gut_metamorphosis_liver/Saved_objects/full_top_table_S4vsS1.rds")
```

```{r, echo=FALSE}
#find genes with adjusted pvalue
significant <- full_top_table$adj.P.Val < 0.05
#subset genes that are significantly upregulated
upregulated <- significant & sign(full_top_table$FC) == 1
#subest gene that are significantly downregulated
downregulated <- significant & sign(full_top_table$FC) == -1
#find genes that change more than 2x (log2(FC)>=1 or -1)
changing <- (sign(full_top_table$FC)*log2(abs(full_top_table$FC)) > 1 | (sign(full_top_table$FC)*log2(abs(full_top_table$FC))) < -1)


#genes that are neither significant nor changing
neither <- !significant & !changing
#genes that are changing but not significant
notsignificant_high <- !significant & changing
#genes that are significant but not changing
significant_low <- significant & !changing
#find genes that are both significant and changing
both <- significant & changing
```

```{r, echo=FALSE}
#adjust confidence intervals if we are to only select a subset of genes (in our case, significant genes)
#see https://monashbioinformaticsplatform.github.io/r-linear-abacbs2018/topics/linear_models_abacbs2018.html
#find genes which we consider "selected" (significant, or significant AND log2 changing)

prop_both <- mean(changing) #"significant is a 0/1 boolean so the mean is the proportion 
#double check here on why using mean(both) gives non-significant CIs though the adj.p.value is significant.
fcr_confint <- 1 - 0.05*prop_both
#so now replace the confidence interval values

full_top_table <- topTable(fit_results_contrasted, 
                           sort.by = "logFC", 
                           n = Inf, 
                           adjust.method="BH",
                           confint=fcr_confint, #these are now adjusted, when we are just considering the significant genes
                           #p.value=0.05
                           )

#only keep row past p.value threshold
#top.table <- top.table[top.table$adj.P.Val <= 0.5, ]
#create column that shows logFoldChange as the Fold Change
full_top_table["FC"] <- sign(full_top_table["logFC"])*2^abs(full_top_table["logFC"])


#only keep columns we are interested in
top_table <- full_top_table[c("logFC", "FC", "P.Value","adj.P.Val","entrez_ID", "ensembl_ID", "merged_symbol","merged_description","ensembl_description", "AveExpr", "CI.L", "CI.R","t")]

#remove rownames (now redundant)
rownames(top_table) <- NULL

#kable(top_table[top_table$adj.P.Val <= 0.05, ][1:20,1:9], caption = "Top20 genes Liver vs All; adj.p <0.05; ranked by logFC") #note that the condifence intervals displayed here are adjusted for judging signficant AND 2xfold changing, not just significant
# list top genes that are significant and logfold 2X changing
#kable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both], ][1:20,], caption = "Top20 genes CPF vs DMSO; FC<1/2 or FC>2, adj.p <0.05; ranked by logFC")
# list top genes higher in Liver
#kable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][1:20,], caption = "Top20 genes upregulated genes (CPF); FC>2, adj.p <0.05; ranked by logFC")

formattable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][1:20,], 
             caption ="Top20 genes upregulated genes (CPF); FC>2, adj.p <0.05; ranked by logFC",
            #align =c("c","l", "l", "c"), 
            list(#`entrez_ID` = formatter("span", 
                #                      style = x ~ style(
                #                        color = "#A9A9A9", font.weight = "bold")
                #                      ), 
                 `logFC`= color_tile(NA,"dodgerblue")

                 )
            )


# list top genes higher in Gut tube
#kable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:20,], caption = "Top20 downregulated genes (CPF); FC<1/2, adj.p <0.05; ranked by logFC")


formattable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:20,], 
             caption ="Top20 downregulated genes (CPF); FC<1/2, adj.p <0.05; ranked by logFC",
            #align =c("c","l", "l", "c"), 
            list(#`entrez_ID` = formatter("span", 
                #                      style = x ~ style(
                #                        color = "#A9A9A9", font.weight = "bold")
                #                      ), 
                 `logFC`= color_tile("lightcoral", NA)

                 )
            )

#remove unused variables
rm(prop_both, fcr_confint )
```


```{r, echo=FALSE}
#save upregulated and downregulated CPF genes
CPF_upregulated <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][,5]
CPF_downregulated<- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][,5]
#save(CPF_upregulated, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_upregulated_genes.rds")
#save(CPF_downregulated, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_downregulated_genes.rds")
```

```{r, echo=FALSE}
#save CPF genes with a significant change (of any magnitude)
CPF_significant <-  top_table[top_table$entrez_ID %in% top_table$entrez_ID[significant], ][,5]
#save(CPF_significant, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_significant_genes.rds")
```


```{r, echo=FALSE}
#make a formattable of the DE upregulated and downregulated genes

#define the conditional color_tile function
color_tile_conditional <- function(fun="comma", digits=0, palette="RdBu", n=9){
  fun <- match.fun(fun)
  stopifnot(n >=5)
  return_cut <- function(y)
    cut(y, breaks = quantile(y, probs = 0:n/n, na.rm =T),
        labels = 1:n, ordered_result = T, include.lowest =T)
  
  return_col <- function(y)
    RColorBrewer::brewer.pal(n, palette)[as.integer(return_cut(y))]
  
  formatter("span", x ~ fun(x, digits= digits),
            style = function(y) style(
              display = "block",
              padding = "0 4px",
              `border-radius` = "4px",
              color = ifelse(return_cut(y) %in% c(1, 2, n-1, n),
                             csscolor("white"), csscolor("black")),
              font.weight = ifelse(y<=-1 | y>=1, "bold", NA),
              `background-color` = return_col(y)
            )
            )
}


formattable_output <- formattable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[significant], c(1,2,5,7,8, 6,9, 4) ], 
             caption ="DE genes; FC<1/2 or FC>2, adj.p <0.05; ranked by logFC",
            align =c("c","c", "c", "l", "l", "l", "l", "c"), 
            list(`entrez_ID` = formatter("span", 
                                      style = x ~ style(
                                        #color = "#A9A9A9", 
                                        font.weight = "bold")
                                      ), 
                 area(col = 6:7) ~ formatter("span", 
                                      style = x ~ style(
                                       color = "#A9A9A9")
                                      ),
                 area(col =1) ~ color_tile_conditional(digits=2)

                 )
            )

formattable_output[1:20,]
```

```{r, echo=FALSE, include=FALSE}
#The whole table can be saved as an html object
formattable_output <- as.datatable(formattable_output, options = list(pageLength = 100)) 

#save to share and for exploration 
#html widgets::saveWidget(formattable_output, "C://Users/Doctor/Desktop/DEgenes_CPF.html", selfcontained = T) 
```



```{r, echo=FALSE}
#Let us print a summary representation of the differentially expressed genes
paste0(summary(changing & significant)[3] ," differentially expressed genes (P <0.05, FC<1/2 OR FC>2):")
paste0(summary(changing & upregulated)[3] ," genes upregulated by CPF")
paste0(summary(changing & downregulated)[3] ," genes downregulated by CPF")
```
```{r, echo=FALSE}
#to use this as a reference for the genes signaled out from the venn diagram, save as object,
top_table_CPF <- top_table
#save(top_table_CPF, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/top_table_CPF.rds")
```

```{r, echo=FALSE, fig.width=4, fig.height=4}
#and the corresponding plot

ggplot(top_table, aes(x=AveExpr, y=sign(FC)*log2(abs(FC)))) + 
  geom_point(data=top_table[neither,], size=0.5, color="gray60", alpha=0.1) +
  geom_point(data=top_table[notsignificant_high,], size=0.8, color="gray60", alpha=0.5)+
  geom_point(data=top_table[significant_low,], size=0.8, color="gray40", alpha=0.5)+
  geom_point(data=top_table[both,], size=1, color=ifelse(top_table[both, "logFC"]>0,"lightcoral","dodgerblue2"), alpha=0.5)+
  theme_bw()+theme(panel.border = element_rect(color="lightskyblue", fill=NA, linewidth= 2))+
   ylim(-15,15)+
  ylab("log2(CPF/DMSO)")+
  xlab("Average Expression")+ 
  geom_hline(yintercept=1, color = "lightcoral", linewidth=0.1)+ # can add linetype="dashed"
  geom_hline(yintercept=-1, color = "dodgerblue2", linewidth=0.1)+
  ggtitle('**CPF** vs **DMSO**')+
  labs(subtitle = '<span style = "color:lightcoral"> upregulated</span>, 
       <span style = "color:dodgerblue2">downregulated</span>')+
  theme_bw()+theme(panel.border = element_rect(color="lightskyblue", fill=NA, linewidth= 2),
                   plot.title = ggtext::element_markdown(),
                   plot.subtitle = ggtext::element_markdown())

```

```{r, echo=FALSE}
#Let us plot the pattern of expression of differentially expressed genes
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE, include=FALSE}
#to add the correlation values with T3 and MPI conditions, let us make a table


#calculate z-score
counts_VST_z <- t(scale(t(counts_VST)))

#create counts table with average values
group_indeces <- c(0, cumsum(unname( table(sample_metadata$treatment))))

counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_z),ncol=0))

#calculate the average by group of replicates

for (i in seq(1:(length(group_indeces)-1))) {
  tmp <- counts_VST_z[,(group_indeces[i]+1):group_indeces[i+1]]
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
}

colnames(counts_VST_averaged) <- unique(sample_metadata$treatment)

corr_df <- as.data.frame(rownames(counts_VST_averaged))
names(corr_df) <- "gene_id"
head(corr_df)

corr_df$deltaT3 <- abs(counts_VST_averaged[,"CPF"]-counts_VST_averaged[,"T3IOP"]) 
corr_df$deltaMPI <- abs(counts_VST_averaged[,"CPF"]-counts_VST_averaged[,"MPI"]) 
corr_df$similarity <- NA
head(corr_df)

for (i in seq(1:nrow(corr_df))) {
  if (abs(corr_df$deltaT3[i])< abs(corr_df$deltaMPI[i])) {
    corr_df$similarity[i] <- "T3"
    
  }
  
  else {
    corr_df$similarity[i] <- "MPI"
    
  }
  
  #if the closest treatment is more than 1signma away, CPF is not similar to it (and so even less to the other one), it's a unique response
  if (min(corr_df$deltaT3[i], corr_df$deltaMPI[i]) >1) {
    corr_df$similarity[i] <- "neither"
    
  }
  
  #if both other treatments are within 1 sigma, CPF is in fact similar to both treatments
  if ((corr_df$deltaT3[i] <1) & (corr_df$deltaMPI[i] <1)) {
    corr_df$similarity[i] <- "both"
    
  }
  
}

rownames(corr_df) <- corr_df$gene_id
corr_df <- corr_df[,2:4]
head(corr_df)

rownames(corr_df) <- annotation_info$merged_description[match(rownames(corr_df), annotation_info$entrez_ID)]

head(corr_df)
```


```{r, echo=FALSE, include=FALSE}
selected_genes <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][1:as.numeric(summary(changing & upregulated)[3]),"entrez_ID"]
#selected_genes <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][1:50,"entrez_ID"]

# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST)))
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]


#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained")


## subset the original VST object to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)

## Create Unique Column Names
#rownames(counts_VST_selectedgenes) <- dplyr::recode(
#  rownames(counts_VST_selectedgenes), 
#  !!!setNames(make.unique(as.character(annotation_info$description)), # column of dictionary table that has NEW names
#              annotation_info$ensembl_gene_id)  #column of dictionary table with OLD names
#  )

rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]


#remove unused variables
#rm(missing_genes)
```

```{r, fig.height=5, fig.width=15, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


similarity_list_named <- c("palegreen3", "lightcoral", "gray80", "white")
names(similarity_list_named) <- c("T3", "MPI", "neither", "both")

ha = rowAnnotation(df = data.frame(treatment = corr_df[rownames(corr_df) %in% rownames(counts_VST_selectedgenes),"similarity"]), #the name of the column needs to match the name of the named list
                            
                            col = list("treatment" = similarity_list_named), #set the name of the named list so it matches
                   simple_anno_size = unit(2, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(8, "mm"))
                   )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        #column_title = gt_render(
        #  "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of CPF-upregulated genes"
        #  ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        right_annotation = ha,
        show_row_names = FALSE,
        show_column_names = FALSE,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        #use_raster = TRUE, raster_magick_filter = "Gaussian"
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```


```{r, echo=FALSE, include=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
selected_genes <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:as.numeric(summary(changing & downregulated)[3]),"entrez_ID"]
#selected_genes <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:50,"entrez_ID"]

# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST)))
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]


#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained")


## subset the original VST object to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)

## Create Unique Column Names
#rownames(counts_VST_selectedgenes) <- dplyr::recode(
#  rownames(counts_VST_selectedgenes), 
#  !!!setNames(make.unique(as.character(annotation_info$description)), # column of dictionary table that has NEW names
#              annotation_info$ensembl_gene_id)  #column of dictionary table with OLD names
#  )

rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]


#remove unused variables
#rm(missing_genes)
```

```{r, fig.height=5, fig.width=15, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


similarity_list_named <- c("palegreen3", "lightcoral", "gray80", "white")
names(similarity_list_named) <- c("T3", "MPI", "neither", "both")

ha = rowAnnotation(df = data.frame(treatment = corr_df[rownames(corr_df) %in% rownames(counts_VST_selectedgenes),"similarity"]), #the name of the column needs to match the name of the named list
                            
                            col = list("treatment" = similarity_list_named), #set the name of the named list so it matches
                   simple_anno_size = unit(2, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(8, "mm"))
                   )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        #column_title = gt_render(
        #  "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of CPF-upregulated genes"
        #  ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        right_annotation = ha,
        show_row_names = FALSE,
        show_column_names = FALSE,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        #use_raster = TRUE, raster_magick_filter = "Gaussian"
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```





##### __Over-representation Analysis:__

`r emo::ji("magnifying glass tilted right")` Can we get some broad ideas of the families of genes represented by the genes we have found to be differentially expressed? In our ranked list of Differentially Expressed genes, are some pathways/biological processes over-represented? We will use the clusterProfileR/enricheR packages for a first analysis.



```{r, echo=FALSE, include=FALSE}
#Over representation analysis (over-representation of GO:terms in DiffExpressed genes (as defined by us a logFC>2 and p <0.05))
# uncomment if not run this earlier in the code and object "ensembl" does not exist
require(biomaRt)
ensembl <- useMart('ensembl', dataset = 'aocellaris_gene_ensembl')
#tab_GO
GO_annotations <- getBM(attributes = c("ensembl_gene_id", 'namespace_1003', "go_id", "name_1006"),
                        mart = ensembl)
#only keep genes annotated for Biological Process GO terms
GO_annotations <- subset(GO_annotations, (namespace_1003 %in% "biological_process"))

#let us also add a column with the descriptions from our annotation_info file
GO_annotations$description <- annotation_info$merged_description[match(GO_annotations$ensembl_gene_id, annotation_info$ensembl_ID)]

```

```{r, echo=FALSE}
#load differentially expressed genes between S1 and S7, ranked by FC
DE_genes <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both], ]$ensembl_ID

#remove genes that do not have an ensembl_ID
DE_genes <- na.omit(DE_genes)

#for later, also prepare a list of DE_genes, but their descriptions instead of the ensembl_id
DE_genes_description <- top_table[top_table$ensembl_ID %in% DE_genes, ]$merged_description


#prepare the required dictionary tables
#TERM2GENE <- GO_annotations[c("go_id", "ensembl_gene_id")]
#TERM2NAME <- GO_annotations[c("go_id", "name_1006")]

#let's try to make dictionaries based on gene description rather than gene code
TERM2GENE <- GO_annotations[c("go_id", "description")]
TERM2NAME <- GO_annotations[c("go_id", "name_1006")]
#in which case, the DE_Genes list needs to be descriptions
DE_genes2 <- annotation_info$ensembl_description[match(DE_genes,annotation_info$ensembl_ID)]

enriched_object <- enricher(DE_genes2, 
         pvalueCutoff = 0.05, 
         pAdjustMethod = "BH", 
         #universe, 
         #minGSSize = 10, 
         #maxGSSize = 500, 
         qvalueCutoff = 0.05, 
         TERM2GENE = TERM2GENE, 
         TERM2NAME = TERM2NAME)

#goplot(enriched_object)
```

<br/> * Top over-represented Gene Ontology gene sets (ordered by adjusted p.value, descending):
```{r, fig.height=4, fig.width=8, echo=FALSE}
#enriched_object
OverRepresentation_plot1 <- barplot(enriched_object, x="count", showCategory = length(enriched_object@result), color = "p.adjust")+
  scale_fill_gradientn(colours = rev(brewer.pal(9,"Blues")[2:9]))+
  NULL
OverRepresentation_plot1
```

<br/> * ... and genes associated with it (notice the overlaps of genes belonging to multiple sets):

```{r, fig.width=10, fig.height=15, echo=FALSE}
#https://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html
OverRepresentation_plot2 <- heatplot(enriched_object, showCategory=length(enriched_object@result) )+ 
  #coord_equal() + 
  NULL

OverRepresentation_plot2+ ggplot2::coord_flip()
```

<br/> * Relationship between the Gene sets identified:
```{r, echo=FALSE, message=FALSE}
enriched_object_with_similarity <- pairwise_termsim(enriched_object)
OverRepresentation_plot3 <- emapplot(enriched_object_with_similarity, 
                                     cex_label_category=0.6, 
                                     cex_category=1.5, 
                                     cex_line=1, 
                                     showCategory=length(enriched_object_with_similarity@result) )+
  scale_fill_gradientn(colours = rev(brewer.pal(9,"Blues")[1:9]))+
  NULL
OverRepresentation_plot3
```
<br/> * Quantification of the overlap between genes in each set:

```{r, echo=FALSE}
#OverRepresentation_plot4 <- upsetplot(enriched_object, showCategory=length(enriched_object@result))
#OverRepresentation_plot4


#to be able to customise the colors of the upsetplot, we will modify its source code and call it from there
#https://github.com/YuLab-SMU/enrichplot/blob/master/R/upsetplot.R

list2df <- function(inputList) {
    # ldf <- lapply(1:length(inputList), function(i) {
    ldf <- lapply(seq_len(length(inputList)), function(i) {
        data.frame(categoryID=rep(names(inputList[i]),
                                  length(inputList[[i]])),
                   Gene=inputList[[i]])
    })

    do.call('rbind', ldf)
}

theme_dose <- function(font.size=14) {
    theme_bw() +
        theme(axis.text.x = element_text(colour = "black",
                                         size = font.size, vjust =1 ),
              axis.text.y = element_text(colour = "black",
                                         size = font.size, hjust =1 ),
              axis.title = element_text(margin=margin(10, 5, 0, 0),
                                        color = "black",
                                        size = font.size),
              axis.title.y = element_text(angle=90)
              )
}
    
df <- as.data.frame(enriched_object)
id <- df$ID[1:9] #these are the GO ids
des <- df$Description[1:9] #these are the GO titles
glist <- geneInCategory(enriched_object)[id]
names(glist) <- des
d <- list2df(glist)
res <- tibble::tibble(Description = split(d[,1], d[,2]))

OverRepresentation_plot4 <- ggplot(res, aes_(x = ~Description)) + 
  geom_bar(fill= rev(colorRampPalette(brewer.pal(9,"Blues"))(length(unique(res$Description))))) + # for sequence of colors
  #geom_bar(fill=c(rep("gray",5-1),rep("dodgerblue",1), rep("gray",length(unique(res$Description))-5))) +  #to highlight a specific category at position e.g. 5
  #scale_fill_gradient(colours = rev(brewer.pal(9,"Blues")[1:9]))+
  theme_dose(font.size = 12) +
  xlab(NULL) + 
  ylab(NULL) +
  ggupset::scale_x_upset(order_by = "degree")+ #default was order_by = "freq"
  NULL

OverRepresentation_plot4    
#remove unused variables
rm(list2df, df, id, des, glist, d, res, theme_dose)
```
<br/> Below, a list of the pathway identified by Gene Enrichment Analysis, and the genes in our differential-expression list that belong to each: <br/>
```{r, echo=FALSE}
#print a list of the gene sets identified as significant, and the genes belonging to each category
# names(enriched_object@geneSets[enriched_object@result[["ID"]][1:9]]) #these are the GO ids found significant

collated_dataframe <- data.frame(index= seq(1:3))

for (i in 1:length(enriched_object@result)) {
  col <- as.data.frame(enriched_object@geneSets[enriched_object@result[["ID"]][1:length(enriched_object@result)]][names(enriched_object@geneSets[enriched_object@result[["ID"]][i]])])
  #only keep genes that are among our DE genes
  col <- as.data.frame(col[col[,1] %in% DE_genes_description,])
  #we need to rename the column
  colnames(col) <- names(enriched_object@geneSets[enriched_object@result[["ID"]][i]])
  #add index column otherwise we cannot merge properly
  col$index <- seq(1:dim(col)[1])
  #merge the new column (GO gene set + genes), with all previous ones
  collated_dataframe <- merge(collated_dataframe, col , by="index", all=TRUE)
}

#remove index column
collated_dataframe <- collated_dataframe[,2:dim(collated_dataframe)[2]]


for (i in 1:length(enriched_object@result)) {
  colnames(collated_dataframe)[i] <-  distinct(TERM2NAME)$name_1006[distinct(TERM2NAME)$go_id ==  names(enriched_object@geneSets[enriched_object@result[["ID"]][i]])] 
}


collated_dataframe
```


##### __Gene Set Enrichment analysis:__

`r emo::ji("magnifying glass tilted right")` Complementarily, we can perform Gene Set Enrichment Analysis (GSE), not on just the genes we have found to be truly Differentially Expressed (i.e. significant, fold change above a given threshold), but on all genes found to differ between the two timepoints. GSE will look for genes showing significantly co-ordinated shifts in expression across the timepoints, regardless of their magnitude, and indicate the Gene Ontology family to which they most belong.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
#Gene Set Enrichment analysis (to capture genes that did not pass our threshold of DiffExpression)

#prepare the required dictionary tables
GENELIST <- na.omit(top_table[c("ensembl_description", "logFC")]) #remember that here usually you would use the GeneID, but we use descriptions instead to have more informative names

#the GSEA function will give a warning if two ranking values (in this case, logFC values) are the same. We can solve this by creating a rank, where tied entries are sorted randomly.
#see https://github.com/YuLab-SMU/clusterProfiler/issues/214
GENELIST <- GENELIST %>% mutate(rank = rank(logFC,  ties.method = "random")) 

#now sort in decreasing rank order
GENELIST <- GENELIST[order(GENELIST$rank, decreasing = TRUE),]


## assume 1st column is ID
## 2nd column is FC

## feature 1: numeric vector
geneList = GENELIST[,2]
#geneList = GENELIST[,3] # if using rank column

## feature 2: named vector
names(geneList) = as.character(GENELIST[,1])

## feature 3: decreasing order
#geneList = sort(geneList, decreasing = TRUE)



enriched_geneset_object <- GSEA(geneList, 
                                TERM2GENE = TERM2GENE, 
                                TERM2NAME = TERM2NAME,
                                #scoreType = "pos"    #if using rank column
                                )

enriched_geneset_object@result

```

```{r, echo=FALSE, fig.width=20, fig.height=5}
#index of enriched pathways with positive NES
#which(enriched_geneset_object@result$NES > 0) 
#which(enriched_geneset_object@result$NES < 0) 

plot1 <- gseaplot2(enriched_geneset_object, 
                   geneSetID = which(enriched_geneset_object@result$NES > 0),
                   subplots = 1:2)
plot2 <- gseaplot2(enriched_geneset_object, 
                   geneSetID = which(enriched_geneset_object@result$NES < 0)[1:10],
                   subplots = 1:2)
plot3 <- gseaplot2(enriched_geneset_object, geneSetID = 11:15)
plot4 <- gseaplot2(enriched_geneset_object, geneSetID = 16:20)

ggarrange(plot_list(plot1), plot_list(plot2), ncol = 2, nrow = 1)


```


```{r, echo=FALSE}
#output list of genes for upregulated gene sets
#for each of the top (e.g.) 15 ranking GO pathways
for (i in which(enriched_geneset_object@result$NES > 0)) {
  pathway_genes <- annotation_info[annotation_info$ensembl_description %in% na.omit(TERM2GENE[TERM2GENE$go_id %in% enriched_geneset_object@result$ID[i], "description" ]), "ensembl_ID"]#take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  #pathway_genes <- pathway_genes[[1]]
  expressed <- intersect(pathway_genes, DE_genes) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(top_table[top_table$ensembl_ID %in% expressed, c("FC", "adj.P.Val", "ensembl_ID", "merged_description", "AveExpr", "CI.L", "CI.R")], 
              caption= paste0("Genes of GO set:[",enriched_geneset_object@result$Description[i],"] present amonst genes of interest")))
  
}
     

```



##### __MGSA analysis (Model-based Gene Set Analysis__: 

An alternative analysis of gene-set enrichment is Model-based Gene Set Analysis, which tries to find the most conservative set of Gene Ontology gene sets that covers the genes submitted for analysis (in this case, the differentially expressed genes). In theory, the resulting Gene Sets will be less redundant than previous approaches.

<br/> The Gene sets with highest probability of activation are:
<br/>

```{r, fig.width=8, fig.height=8, echo=FALSE}
#but try also clusterprofiler
#Groups of genes identified by some analyses are used as input list to the mgsa function from the mgsa package13
#(with parameters restarts=3 and steps=1e7).

#The model assumes that some sets to be inferred are active and that all genes member of active sets are themselves active. Active genes are more likely to belong to the observations and inactive genes not. Fitting the model amounts to infer the probability of every set to be active given the observations.
#Classical methods analyze each set in isolation. Because sets such as biological pathways often share genes with each other, the returned list of enriched sets is usually long and redundant. In contrast, MGSA takes set overlap into account by working on all sets simultaneously and substantially reduces the number of redundant sets.

#e.g. take list of DE genes S1/S2 [== example_o]
# take list of GO terms (obtained previously) [== example_go]
#myset = new( "MgsaSets", sets=list(set1=LETTERS[1:3], set2=LETTERS[2:5]) )


#prepare table where each column is a GO:pathwayID and entries are the genes that belong to that group
GO_annotations_wide <- GO_annotations[, c("ensembl_gene_id", "go_id")]
GO_annotations_wide$id <- seq.int(nrow(GO_annotations_wide))
GO_annotations_wide <- GO_annotations_wide %>% pivot_wider(names_from = go_id, values_from = ensembl_gene_id)

#only keep GO groups with at least 4 genes and max 500
GO_annotations_wide <- GO_annotations_wide %>% select_if(~ sum(!is.na(.)) > 4 & sum(!is.na(.)) < 500)

#replace GO codes with full names so the results are easier to interpret
tmp <- GO_annotations[, c("name_1006", "go_id")]
tmp <- tmp[!duplicated(tmp),]

colnames(GO_annotations_wide) <- tmp$name_1006[tmp$go_id %in% colnames(GO_annotations_wide)]
rm(tmp)

#run the mgsa function
MGSA_result = mgsa(DE_genes, #this is a list of genes previously obtained during the DE analysis
                   #should maybe just take upregulated in one stage  and upregulated in the other, separatedly
                   GO_annotations_wide, 
                   restarts=5,  
                   steps=1e7)

#show the ordered list of gene sets found
setsResults(MGSA_result)[order(setsResults(MGSA_result)$estimate, decreasing = TRUE),][1:25,]
#plot(MGSA_result)

#The model have three parameters:
# α, the false positive rate i.e. the probability of an inactive gene to actually be observed;
# β, the false negative rate i.e. the probability of an active gene to actually be not observed;
# p, the prior probability for any set to be active, a typically small number ensuring sparse solutions to be inferred

#res = setsResults(MGSA_result)
#subset(res, estimate > 0.5)
```

<br/> Below, for reference, the scoring of all Gene Ontology gene sets considered, and the hyperparameters of the model ( _alpha_ , _beta_, and indirectly _p_ ):

```{r, echo=FALSE, fig.width=9, fig.height=9, warning=FALSE}
#for customisation purposes, let us try to obtain the same plots as plot(MGSA_result)

#set space for 4 plots
par(mfrow=c(2,2))

##p, alpha, beta hyperparameters of the model
## Note this is the information that would be extracted from the original bottom 3 plots

# average number of gene sets expected to be active: p* number of gene sets considered
pPost <- (pPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value)*dim(MGSA_result@setsResults)[1]
# most likely alpha parameter of the model (false positive)
pAlpha <- alphaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value
# most likely beta parameter of the model (false negative rate)
pBeta <- betaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value

title <- paste0("MGSA analysis: \n \n expected active gene sets: ",pPost,"\n alpha (false positives): ", pAlpha, "\n beta (false negatives): ",pBeta)

# TEXT
plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, title , cex=1.2)

## DOTPLOT

tmp <- data.frame(go_id = colnames(GO_annotations_wide), estimate =MGSA_result@setsResults[["estimate"]])
# sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10] #returns the index of the top 10 scoring sets

plot(seq(1:dim(tmp)[1]),
     tmp$estimate,
     xlab="",
     ylab="Posterior Probability of activation",
     #ylim=c(0,3.6),
     xaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(seq(1:dim(tmp)[1]) %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 0.3))
     )
axis(1, sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10],las=2, cex.axis=0.5, font=2, labels = colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]])
title("Posterior probabilities of activation")
abline(h=0.5,col="grey")
#text(sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], tmp$estimate[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]]-0.04, labels=colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]], cex=0.7)

#DENSITY PLOT

plot(density(tmp$estimate),
     col= "dodgerblue",
     lwd= 2,
     main="",
     xlab="Posterior probability of activation",
     ylab="Number of GO sets \n with given probability",
     #ylim=range(pretty(c(0, 1)))
     )
abline(v=0.5,col="grey")
title("Distribution of posterior activation probabilities")

#BARPLOT

sorted_tmp <- tmp
sorted_tmp$sd <- MGSA_result@setsResults[["std.error"]]
sorted_tmp$index <- seq(1:dim(sorted_tmp)[1])
sorted_tmp <- sorted_tmp[order(sorted_tmp$estimate, decreasing = TRUE),]
#sorted_tmp <- as.data.frame(sort(sorted_tmp$estimate, index.return=TRUE, decreasing=TRUE))
sorted_tmp$rank <- seq(1:dim(sorted_tmp)[1])
#colnames(sorted_tmp) <- c("estimate", "index", "rank")

plot(sorted_tmp[1:20,]$estimate,
     sorted_tmp[1:20,]$rank,
     xlab="Posterior Probability of activation \n +/- Standard Error",
     ylab="",
     #ylim=c(1,20),
     ylim = rev(range(sorted_tmp[1:20,]$rank)), #so that higher ranks (lower positions) are at the bottom
     yaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(sorted_tmp$index %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 1))
     )
axis(2, sorted_tmp[1:20,]$rank,las=2, 
     cex.axis=0.5, 
     font=2, 
     labels = colnames(GO_annotations_wide)[sorted_tmp[1:20,]$index])
title("Posterior probabilities of activation")
# Add error bars
#https://www.benjaminbell.co.uk/2019/04/how-to-add-error-bars-in-r.html
arrows(x0=sorted_tmp[1:20,]$estimate - sorted_tmp[1:20,]$sd, 
       y0=sorted_tmp[1:20,]$rank, 
       x1=sorted_tmp[1:20,]$estimate+ sorted_tmp[1:20,]$sd, 
       y1=sorted_tmp[1:20,]$rank, 
       code=3, 
       angle=90, 
       length=0.1,
       col = "gray")

```

<br/> For the top scoring pathways, below the list of the actual genes belonging to that pathway that were found in our list of differentially-expressed genes:


```{r, echo=FALSE, include=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:10)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, DE_genes) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(top_table[top_table$ensembl_ID %in% expressed, c("FC", "adj.P.Val", "ensembl_ID", "merged_description", "AveExpr", "CI.L", "CI.R")], 
              caption= paste0("Genes of GO set:[",sorted_tmp[i,1],"] present amonst genes of interest")))
  
}
     
```

##### __Competitive Gene Set Tests (MRGSE)__

```{r, echo=FALSE}
#Gene set tests were applied to statistical contrasts using function geneSetTest14 from the limma package (with
#parameters alternative="mixed", type="t" and ranks.only=TRUE)

#The method tests whether a set of genes is highly ranked relative to other genes in terms of their t-statistics (competitive approach).
#The approach was applied to the Gene Ontology terms (from the “Biological Process” tree) and the KEGG pathways separately.
#Only sets with at least 25 genes and at most 1000 were considered.


#run a competitive gene test for every GO_set we have downloaded from ensembl (object "GO annotations" made earlier)
#from:https://support.bioconductor.org/p/107553/
#The competitive gene test will show me wich gene set is more affected than other gene sets by the response. 

GO_id_list <- list()
GO_pvalue_list <- list()

for (GO_id in unique(GO_annotations$go_id)) {
  
  #prepare required"index" object
  #index is a TRUE/FALSE column the same length as the genes submitted, which is TRUE for genes in a given geneset
  #remember to start from a list of GO sets that has all genes, not just those expressed in your dataset
  GO_genes <- GO_annotations[GO_annotations$go_id == GO_id, "ensembl_gene_id"]

  #make a TRUE/FALSE vector for each toptable gene 
  index <- top_table$ensembl_ID %in% GO_genes
  
  #run geneSetTest to obtain resulting pvalue for each GO set
  #output is the pvalue (calculated from Wicloxon test) that genes of GOset "X" are higher ranked in the contrast statistics, compared to randomly chosen genes 
  GO_pvalue <- geneSetTest(index = index, 
            statistics = na.omit(top_table)$t, 
            alternative = "mixed",       #alternative hypothesis is "mixed", direction does not matter
            type = "t",                  #i.e. statistics are signed, t-like
            ranks.only = TRUE            #only ranks of object "statistics" will be used
            )
  
  #store GO_id and pvalue in lists
  GO_id_list <- append(GO_id_list, GO_id)
  GO_pvalue_list <- append(GO_pvalue_list, GO_pvalue)
  
}
```

```{r, echo=FALSE}
#create a dataframe with the 𝑝-values (column p.value) and GO_id
CGST_table <- data.frame(matrix(unlist(GO_pvalue_list), nrow=length(GO_pvalue_list), byrow=TRUE))
colnames(CGST_table) <- "p.value"
CGST_table$p.value <- as.numeric(CGST_table$p.value)

CGST_table$id <- unlist(GO_id_list)

#Add number of probe sets in the gene set (column nb)

#Add and information for each identified gene set (columns database, and description)
CGST_table$database <- rep("GO", dim(CGST_table)[1])

for (id in CGST_table$id) {
  CGST_table[match(id, CGST_table$id),"description"] <- GO_annotations[match(id, GO_annotations$go_id)  ,"name_1006"]
}


##Add false discovery rate adjusted 𝑝-values (column FDR)
#calculate adjusted p values manually
#order pvalues from smallest to highest
CGST_table <- CGST_table[order(CGST_table$p.value),]
CGST_table$rank <- seq.int(nrow(CGST_table))

# find BH correction threshold (based on formula).
#we are accepting a FDR of  5% (p value = 0.05)
CGST_table$adjusted_pvalue <- (CGST_table[,"rank"]/nrow(CGST_table))*0.05

#remove rank column, wich we do not need anymore
CGST_table <- subset(CGST_table, select = -c(rank))
#sort by adjusted p value
CGST_table <- CGST_table[order(CGST_table$adjusted_pvalue),]

#show table
kable(CGST_table[1:30,], caption = "GO gene sets identified by the Mean-Rank Gene Set Enrichment tests (MRGSE) method, ranked by adjusted p.value")
```


```{r, echo=FALSE, include=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:30)) {
  pathway_genes <- GO_annotations[GO_annotations$go_id == CGST_table$id[i],"ensembl_gene_id"] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  #pathway_genes <- pathway_genes[[1]]
  #expressed <- intersect(pathway_genes, DE_genes) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(top_table[top_table$ensembl_ID %in% pathway_genes, c("FC", "adj.P.Val", "ensembl_ID", "merged_description", "AveExpr", "CI.L", "CI.R")], 
              caption= paste0("Genes of GO set:[",CGST_table$description[i],"] present amonst genes of interest")))
  
}
    


```

We can do the same with KEGG pathways

```{r, echo=FALSE}

load("C://Users/Doctor/Desktop/RNAseq_analyses/dictionary_gene2KEGG_wide.rds")
load("C://Users/Doctor/Desktop/RNAseq_analyses/dictionary_KEGG2description.rds")
#run a competitive gene test for every KEGG set we have obtained from KEGG (object "dictionary_gene2KEGG_wide" made earlier)
#from:https://support.bioconductor.org/p/107553/
#The competitive gene test will show me wich gene set is more affected than other gene sets by the response. 

KEGG_id_list <- list()
KEGG_pvalue_list <- list()

for (KEGG_id in colnames(dictionary_gene2KEGG_wide)) {
  
  #prepare required"index" object
  #index is a TRUE/FALSE column the same length as the genes submitted, which is TRUE for genes in a given geneset
  #remember to start from a list of GO sets that has all genes, not just those expressed in your dataset
  KEGG_genes <- unlist(na.omit(dictionary_gene2KEGG_wide[[KEGG_id]]))

  #make a TRUE/FALSE vector for each toptable gene 
  index <- top_table$ensembl_ID%in% KEGG_genes
  
  #run geneSetTest to obtain resulting pvalue for each GO set
  #output is the pvalue (calculated from Wicloxon test) that genes of GOset "X" are higher ranked in the contrast statistics, compared to randomly chosen genes 
  KEGG_pvalue <- geneSetTest(index = index, 
            statistics = top_table$t, 
            alternative = "mixed",       #alternative hypothesis is "mixed", direction does not matter
            type = "t",                  #i.e. statistics are signed, t-like
            ranks.only = TRUE            #only ranks of object "statistics" will be used
            )
  
  #store GO_id and pvalue in lists
  KEGG_id_list <- append(KEGG_id_list, KEGG_id)
  KEGG_pvalue_list <- append(KEGG_pvalue_list, KEGG_pvalue)
  
}
```

```{r, echo=FALSE}
#create a dataframe with the 𝑝-values (column p.value) and GO_id
CGST_table_KEGG <- data.frame(matrix(unlist(KEGG_pvalue_list), nrow=length(KEGG_pvalue_list), byrow=TRUE))
colnames(CGST_table_KEGG) <- "p.value"
CGST_table_KEGG$p.value <- as.numeric(CGST_table_KEGG$p.value)

CGST_table_KEGG$id <- unlist(KEGG_id_list)

#Add number of probe sets in the gene set (column nb)

#Add and information for each identified gene set (columns database, and description)
CGST_table_KEGG$database <- rep("KEGG", dim(CGST_table_KEGG)[1])

for (id in CGST_table_KEGG$id) {
  CGST_table_KEGG[match(id, CGST_table_KEGG$id),"description"] <- dictionary_KEGG2description[id, "Description"]
}


##Add false discovery rate adjusted 𝑝-values (column FDR)
#calculate adjusted p values manually
#order pvalues from smallest to highest
CGST_table_KEGG <- CGST_table_KEGG[order(CGST_table_KEGG$p.value),]
CGST_table_KEGG$rank <- seq.int(nrow(CGST_table_KEGG))

# find BH correction threshold (based on formula).
#we are accepting a FDR of  5% (p value = 0.05)
CGST_table_KEGG$adjusted_pvalue <- (CGST_table_KEGG[,"rank"]/nrow(CGST_table_KEGG))*0.05

#remove rank column, wich we do not need anymore
CGST_table_KEGG <- subset(CGST_table_KEGG, select = -c(rank))
#sort by adjusted p value
CGST_table_KEGG <- CGST_table_KEGG[order(CGST_table_KEGG$adjusted_pvalue),]
#add index
CGST_table_KEGG$index <- seq(1:dim(CGST_table_KEGG)[1])

#show table
kable(CGST_table_KEGG[1:30,], caption = "KEGG gene sets identified by the Mean-Rank Gene Set Enrichment tests (MRGSE) method, ranked by adjusted p.value")
```

```{r, echo=FALSE, include=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:10)) {
  pathway_genes <- na.omit(dictionary_gene2KEGG_wide[,CGST_table_KEGG[i, "id"]])#take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  pathway_genes <- pathway_genes[[1]]
  expressed <- intersect(pathway_genes, DE_genes) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(top_table[top_table$ensembl_ID %in% expressed, c("FC", "adj.P.Val", "ensembl_ID", "merged_description", "AveExpr", "CI.L", "CI.R")], 
              caption= paste0("Genes of GO set:[",CGST_table_KEGG[i, "description"],"] present amonst genes of interest")))
  
}
     
```


##### effect of MPI (MPI vs DMSO)


```{r, echo=FALSE, results = FALSE}
#Load voom object "DGE_object_filterednormed_Voomed" for differential expression analysis, and annotation info
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/DGE_object_filterednormed_Voomed.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/sample_metadata.rds")
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated.rds") 

#rename the dataframe as "annotation_info"
annotation_info <- annotation_info_NCBIEnsembl
#remove the column with the original description
#annotation_info <- subset(annotation_info, select = -c(original_description))

#remove unused variables
rm(annotation_info_NCBIEnsembl)

#----------

# apply linear regression model with mean-variance relationship weights calculated above
# lmFit fits a linear model using weighted least squares for each gene:
#extract the linear models that had been fit in the voom object
fit_results <- lmFit(DGE_object_filterednormed_Voomed) #this is the same as doing #fit_results <- lmFit(DGE_object_filterednormed_Voomed, weights=DGE_object_filterednormed_Voomed[["weights"]])

#same as doing lm() individually on each gene (can also supply here the model matrix, but already incorporated through vooming)
head(coef(fit_results))
```


```{r echo=FALSE, fig.height=2.5, fig.width=9, warning=TRUE, paged.print=FALSE}
#Compute comparisons of interest

#Comparisons between groups (log fold-changes) are obtained as contrasts of these fitted linear models:
contrast_matrix <- makeContrasts(treatmentMPI  - treatmentDMSO ,  # positive logchanges will be higher in S4, negative will be higher in S1
                       levels = colnames(coef(fit_results)))
#show newly created contrast matrix
contrast_matrix  # positive logchanges will be higher in S4, negative will be higher in S1

#add the contrast matrix to our fit object
# need to do new objects or it chenges  coefficients instead?
fit_results_contrasted <- contrasts.fit(fit_results, contrast_matrix)

#Empirical Bayes smoothing of standard errors (shrinks standard errors that are much larger or smaller than those from other genes towards the average standard error) (see https://www.degruyter.com/doi/10.2202/1544-6115.1027)
fit_results_contrasted <- eBayes(fit_results_contrasted) #when applied to the output of lmFit(), performs the pooled estimation of standard errors that results in the moderated t-statistics and resulting p-values.

#p.adjust (but this will be done automatically by TopTable function)
#indiv.P.values<-apply(tmp[["p.value"]], 2, p.adjust, method="BH")
#tmp[["BH.adjusted.pvalue"]] <- indiv.P.values


#remove unused variables
rm(fit_results, DGE_object_filterednormed_Voomed)
```
<br/>
Below, a list of all the genes that appear significantly differently expressed between treatment and control (in either direction; __Table 1__). In __Table 2__, the subest of significantly changing genes whose fold-change is bigger than 2folds (in either direction). These genes are ranked in order of decreasing fold change. <br/>

```{r, echo=FALSE}
#What genes are most differentially expressed?
full_top_table <- topTable(fit_results_contrasted, 
                           sort.by = "logFC", 
                           n = Inf, 
                           adjust.method="BH",
                           confint=0.95, #note that these are not adjusted for multiple testing 
                           #p.value=0.05
                           )

#create column that shows logFoldChange as the Fold Change
full_top_table["FC"] <- sign(full_top_table["logFC"])*2^abs(full_top_table["logFC"])

#save list
#save(full_top_table, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/full_top_table_MPIvsDMSO.rds")
#load(file = "C://Users/Doctor/Desktop/RNAseq_analyses/Aocellaris_gut_metamorphosis_liver/Saved_objects/full_top_table_S4vsS1.rds")
```

```{r, echo=FALSE}
#find genes with adjusted pvalue
significant <- full_top_table$adj.P.Val < 0.05
#subset genes that are significantly upregulated
upregulated <- significant & sign(full_top_table$FC) == 1
#subest gene that are significantly downregulated
downregulated <- significant & sign(full_top_table$FC) == -1
#find genes that change more than 2x (log2(FC)>=1 or -1)
changing <- (sign(full_top_table$FC)*log2(abs(full_top_table$FC)) > 1 | (sign(full_top_table$FC)*log2(abs(full_top_table$FC))) < -1)


#genes that are neither significant nor changing
neither <- !significant & !changing
#genes that are changing but not significant
notsignificant_high <- !significant & changing
#genes that are significant but not changing
significant_low <- significant & !changing
#find genes that are both significant and changing
both <- significant & changing
```

```{r, echo=FALSE}
#adjust confidence intervals if we are to only select a subset of genes (in our case, significant genes)
#see https://monashbioinformaticsplatform.github.io/r-linear-abacbs2018/topics/linear_models_abacbs2018.html
#find genes which we consider "selected" (significant, or significant AND log2 changing)

prop_both <- mean(changing) #"significant is a 0/1 boolean so the mean is the proportion 
#double check here on why using mean(both) gives non-significant CIs though the adj.p.value is significant.
fcr_confint <- 1 - 0.05*prop_both
#so now replace the confidence interval values

full_top_table <- topTable(fit_results_contrasted, 
                           sort.by = "logFC", 
                           n = Inf, 
                           adjust.method="BH",
                           confint=fcr_confint, #these are now adjusted, when we are just considering the significant genes
                           #p.value=0.05
                           )

#only keep row past p.value threshold
#top.table <- top.table[top.table$adj.P.Val <= 0.5, ]
#create column that shows logFoldChange as the Fold Change
full_top_table["FC"] <- sign(full_top_table["logFC"])*2^abs(full_top_table["logFC"])


#only keep columns we are interested in
top_table <- full_top_table[c("logFC", "FC", "P.Value","adj.P.Val","entrez_ID", "merged_symbol","merged_description","ensembl_description", "AveExpr", "CI.L", "CI.R","t")]

#remove rownames (now redundant)
rownames(top_table) <- NULL

formattable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][1:20,], 
             caption ="Top20 genes upregulated genes (CPF); FC>2, adj.p <0.05; ranked by logFC",
            #align =c("c","l", "l", "c"), 
            list(#`entrez_ID` = formatter("span", 
                #                      style = x ~ style(
                #                        color = "#A9A9A9", font.weight = "bold")
                #                      ), 
                 `logFC`= color_tile(NA,"dodgerblue")

                 )
            )


# list top genes higher in Gut tube
#kable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:20,], caption = "Top20 downregulated genes (CPF); FC<1/2, adj.p <0.05; ranked by logFC")


formattable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:20,], 
             caption ="Top20 downregulated genes (CPF); FC<1/2, adj.p <0.05; ranked by logFC",
            #align =c("c","l", "l", "c"), 
            list(#`entrez_ID` = formatter("span", 
                #                      style = x ~ style(
                #                        color = "#A9A9A9", font.weight = "bold")
                #                      ), 
                 `logFC`= color_tile("lightcoral", NA)

                 )
            )


#remove unused variables
rm(prop_both, fcr_confint )
```

```{r, echo=FALSE}
MPI_upregulated <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][,5]
MPI_downregulated<- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][,5]
#save(MPI_upregulated, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/MPI_upregulated_genes.rds")
#save(MPI_downregulated, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/MPI_downregulated_genes.rds")
```




```{r, echo=FALSE}
#Let us print a summary representation of the differentially expressed genes
paste0(summary(changing & significant)[3] ," differentially expressed genes (P <0.05, FC<1/2 OR FC>2):")
paste0(summary(changing & upregulated)[3] ," genes upregulated by MPI")
paste0(summary(changing & downregulated)[3] ," genes downregulated by MPI")
```
```{r, echo=FALSE}
#to use this as a reference for the genes signaled out from the venn diagram, save as object,
top_table_MPI <- top_table
#save(top_table_MPI, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/top_table_MPI.rds")
```


```{r, echo=FALSE, fig.width=4, fig.height=4}
#and the corresponding plot

ggplot(top_table, aes(x=AveExpr, y=sign(FC)*log2(abs(FC)))) + 
  geom_point(data=top_table[neither,], size=0.5, color="gray60", alpha=0.1) +
  geom_point(data=top_table[notsignificant_high,], size=0.8, color="gray60", alpha=0.5)+
  geom_point(data=top_table[significant_low,], size=0.8, color="gray40", alpha=0.5)+
  geom_point(data=top_table[both,], size=1, color=ifelse(top_table[both, "logFC"]>0,"lightcoral","dodgerblue2"), alpha=0.5)+
   ylim(-15,15)+
  ylab("log2( MPI / DMSO )")+
  xlab("Average Expression")+ 
  geom_hline(yintercept=1, color = "lightcoral", linewidth=0.1)+ # can add linetype="dashed"
  geom_hline(yintercept=-1, color = "dodgerblue2", linewidth=0.1)+
  ggtitle('**CPF** vs **DMSO**')+
  labs(subtitle = '<span style = "color:lightcoral"> upregulated</span>, 
       <span style = "color:dodgerblue2">downregulated</span>')+
  theme_bw()+theme(panel.border = element_rect(color="lightcoral", fill=NA, linewidth= 2),
                   plot.title = ggtext::element_markdown(),
                   plot.subtitle = ggtext::element_markdown())

```

```{r, echo=FALSE}
#Let us plot the top 200 DE genes
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE, include=FALSE}
#to add the correlation values with T3 and MPI conditions, let us make a table


#calculate z-score
counts_VST_z <- t(scale(t(counts_VST)))

#create counts table with average values
group_indeces <- c(0, cumsum(unname( table(sample_metadata$treatment))))

counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_z),ncol=0))

#calculate the average by group of replicates

for (i in seq(1:(length(group_indeces)-1))) {
  tmp <- counts_VST_z[,(group_indeces[i]+1):group_indeces[i+1]]
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
}

colnames(counts_VST_averaged) <- unique(sample_metadata$treatment)

corr_df <- as.data.frame(rownames(counts_VST_averaged))
names(corr_df) <- "gene_id"
head(corr_df)

corr_df$deltaT3 <- abs(counts_VST_averaged[,"MPI"]-counts_VST_averaged[,"T3IOP"]) 
corr_df$deltaCPF <- abs(counts_VST_averaged[,"MPI"]-counts_VST_averaged[,"CPF"]) 
corr_df$similarity <- NA
head(corr_df)

for (i in seq(1:nrow(corr_df))) {
  if (abs(corr_df$deltaT3[i])< abs(corr_df$deltaCPF[i])) {
    corr_df$similarity[i] <- "T3"
    
  }
  
  else {
    corr_df$similarity[i] <- "CPF"
    
  }
  
  #if the closest treatment is more than 1signma away, CPF is not similar to it (and so even less to the other one), it's a unique response
  if (min(corr_df$deltaT3[i], corr_df$deltaCPF[i]) >1) {
    corr_df$similarity[i] <- "neither"
    
  }
  
  #if both other treatments are within 1 sigma, CPF is in fact similar to both treatments
  if ((corr_df$deltaT3[i] <1) & (corr_df$deltaCPF[i] <1)) {
    corr_df$similarity[i] <- "both"
    
  }
  
}

rownames(corr_df) <- corr_df$gene_id
corr_df <- corr_df[,2:4]
head(corr_df)

rownames(corr_df) <- annotation_info$merged_description[match(rownames(corr_df), annotation_info$entrez_ID)]

head(corr_df)
```

```{r, echo=FALSE, include=FALSE}
selected_genes <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][1:as.numeric(summary(changing & upregulated)[3]),"entrez_ID"]
#selected_genes <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][1:50,"entrez_ID"]

# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST)))
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]


#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained")


## subset the original VST object to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)

## Create Unique Column Names
#rownames(counts_VST_selectedgenes) <- dplyr::recode(
#  rownames(counts_VST_selectedgenes), 
#  !!!setNames(make.unique(as.character(annotation_info$description)), # column of dictionary table that has NEW names
#              annotation_info$ensembl_gene_id)  #column of dictionary table with OLD names
#  )

rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]


#remove unused variables
#rm(missing_genes)
```

```{r, fig.height=5, fig.width=15, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


similarity_list_named <- c("palegreen3", "lightskyblue", "gray80", "white")
names(similarity_list_named) <- c("T3", "CPF", "neither", "both")

ha = rowAnnotation(df = data.frame(treatment = corr_df[rownames(corr_df) %in% rownames(counts_VST_selectedgenes),"similarity"]), #the name of the column needs to match the name of the named list
                            
                            col = list("treatment" = similarity_list_named), #set the name of the named list so it matches
                   simple_anno_size = unit(2, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(8, "mm"))
                   )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        #column_title = gt_render(
        #  "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of CPF-upregulated genes"
        #  ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        right_annotation = ha,
        show_row_names = FALSE,
        show_column_names = FALSE,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        #use_raster = TRUE, raster_magick_filter = "Gaussian"
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```


```{r, echo=FALSE, include=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
selected_genes <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:as.numeric(summary(changing & downregulated)[3]),"entrez_ID"]
#selected_genes <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:50,"entrez_ID"]

# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST)))
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]


#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained")


## subset the original VST object to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)

## Create Unique Column Names
#rownames(counts_VST_selectedgenes) <- dplyr::recode(
#  rownames(counts_VST_selectedgenes), 
#  !!!setNames(make.unique(as.character(annotation_info$description)), # column of dictionary table that has NEW names
#              annotation_info$ensembl_gene_id)  #column of dictionary table with OLD names
#  )

rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]


#remove unused variables
#rm(missing_genes)
```

```{r, fig.height=5, fig.width=15, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


similarity_list_named <- c("palegreen3", "lightskyblue", "gray80", "white")
names(similarity_list_named) <- c("T3", "CPF", "neither", "both")

ha = rowAnnotation(df = data.frame(treatment = corr_df[rownames(corr_df) %in% rownames(counts_VST_selectedgenes),"similarity"]), #the name of the column needs to match the name of the named list
                            
                            col = list("treatment" = similarity_list_named), #set the name of the named list so it matches
                   simple_anno_size = unit(2, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(8, "mm"))
                   )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        #column_title = gt_render(
        #  "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of CPF-upregulated genes"
        #  ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        right_annotation = ha,
        show_row_names = FALSE,
        show_column_names = FALSE,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        #use_raster = TRUE, raster_magick_filter = "Gaussian"
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```


##### effect of T3 (T3 vs DMSO)


```{r, echo=FALSE, results = FALSE}
#Load voom object "DGE_object_filterednormed_Voomed" for differential expression analysis, and annotation info
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/DGE_object_filterednormed_Voomed.rds")
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated.rds") 

#rename the dataframe as "annotation_info"
annotation_info <- annotation_info_NCBIEnsembl
#remove the column with the original description
#annotation_info <- subset(annotation_info, select = -c(original_description))

#remove unused variables
rm(annotation_info_NCBIEnsembl)

#----------

# apply linear regression model with mean-variance relationship weights calculated above
# lmFit fits a linear model using weighted least squares for each gene:
#extract the linear models that had been fit in the voom object
fit_results <- lmFit(DGE_object_filterednormed_Voomed) #this is the same as doing #fit_results <- lmFit(DGE_object_filterednormed_Voomed, weights=DGE_object_filterednormed_Voomed[["weights"]])

#same as doing lm() individually on each gene (can also supply here the model matrix, but already incorporated through vooming)
head(coef(fit_results))
```


```{r echo=FALSE, fig.height=2.5, fig.width=9, warning=TRUE, paged.print=FALSE}
#Compute comparisons of interest

#Comparisons between groups (log fold-changes) are obtained as contrasts of these fitted linear models:
contrast_matrix <- makeContrasts(treatmentT3IOP  - treatmentDMSO ,  # positive logchanges will be higher in S4, negative will be higher in S1
                       levels = colnames(coef(fit_results)))
#show newly created contrast matrix
contrast_matrix  # positive logchanges will be higher in S4, negative will be higher in S1

#add the contrast matrix to our fit object
# need to do new objects or it chenges  coefficients instead?
fit_results_contrasted <- contrasts.fit(fit_results, contrast_matrix)

#Empirical Bayes smoothing of standard errors (shrinks standard errors that are much larger or smaller than those from other genes towards the average standard error) (see https://www.degruyter.com/doi/10.2202/1544-6115.1027)
fit_results_contrasted <- eBayes(fit_results_contrasted) #when applied to the output of lmFit(), performs the pooled estimation of standard errors that results in the moderated t-statistics and resulting p-values.

#p.adjust (but this will be done automatically by TopTable function)
#indiv.P.values<-apply(tmp[["p.value"]], 2, p.adjust, method="BH")
#tmp[["BH.adjusted.pvalue"]] <- indiv.P.values


#remove unused variables
rm(fit_results, DGE_object_filterednormed_Voomed)
```
<br/>
Below, a list of all the genes that appear significantly differently expressed between treatment and control (in either direction; __Table 1__). In __Table 2__, the subest of significantly changing genes whose fold-change is bigger than 2folds (in either direction). These genes are ranked in order of decreasing fold change. <br/>

```{r, echo=FALSE}
#What genes are most differentially expressed?
full_top_table <- topTable(fit_results_contrasted, 
                           sort.by = "logFC", 
                           n = Inf, 
                           adjust.method="BH",
                           confint=0.95, #note that these are not adjusted for multiple testing 
                           #p.value=0.05
                           )

#create column that shows logFoldChange as the Fold Change
full_top_table["FC"] <- sign(full_top_table["logFC"])*2^abs(full_top_table["logFC"])

#save list
#save(full_top_table, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/full_top_table_T3IOPvsDMSO.rds")
#load(file = "C://Users/Doctor/Desktop/RNAseq_analyses/Aocellaris_gut_metamorphosis_liver/Saved_objects/full_top_table_S4vsS1.rds")
```

```{r, echo=FALSE}
#find genes with adjusted pvalue
significant <- full_top_table$adj.P.Val < 0.05
#subset genes that are significantly upregulated
upregulated <- significant & sign(full_top_table$FC) == 1
#subest gene that are significantly downregulated
downregulated <- significant & sign(full_top_table$FC) == -1
#find genes that change more than 2x (log2(FC)>=1 or -1)
changing <- (sign(full_top_table$FC)*log2(abs(full_top_table$FC)) > 1 | (sign(full_top_table$FC)*log2(abs(full_top_table$FC))) < -1)


#genes that are neither significant nor changing
neither <- !significant & !changing
#genes that are changing but not significant
notsignificant_high <- !significant & changing
#genes that are significant but not changing
significant_low <- significant & !changing
#find genes that are both significant and changing
both <- significant & changing


```

```{r, echo=FALSE}
#adjust confidence intervals if we are to only select a subset of genes (in our case, significant genes)
#see https://monashbioinformaticsplatform.github.io/r-linear-abacbs2018/topics/linear_models_abacbs2018.html
#find genes which we consider "selected" (significant, or significant AND log2 changing)

prop_both <- mean(changing) #"significant is a 0/1 boolean so the mean is the proportion 
#double check here on why using mean(both) gives non-significant CIs though the adj.p.value is significant.
fcr_confint <- 1 - 0.05*prop_both
#so now replace the confidence interval values

full_top_table <- topTable(fit_results_contrasted, 
                           sort.by = "logFC", 
                           n = Inf, 
                           adjust.method="BH",
                           confint=fcr_confint, #these are now adjusted, when we are just considering the significant genes
                           #p.value=0.05
                           )

#only keep row past p.value threshold
#top.table <- top.table[top.table$adj.P.Val <= 0.5, ]
#create column that shows logFoldChange as the Fold Change
full_top_table["FC"] <- sign(full_top_table["logFC"])*2^abs(full_top_table["logFC"])


#only keep columns we are interested in
top_table <- full_top_table[c("logFC", "FC", "P.Value","adj.P.Val","entrez_ID", "merged_symbol","merged_description","ensembl_description", "AveExpr", "CI.L", "CI.R","t")]

#remove rownames (now redundant)
rownames(top_table) <- NULL

formattable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][1:20,], 
             caption ="Top20 genes upregulated genes (CPF); FC>2, adj.p <0.05; ranked by logFC",
            #align =c("c","l", "l", "c"), 
            list(#`entrez_ID` = formatter("span", 
                #                      style = x ~ style(
                #                        color = "#A9A9A9", font.weight = "bold")
                #                      ), 
                 `logFC`= color_tile(NA,"dodgerblue")

                 )
            )


# list top genes higher in Gut tube
#kable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:20,], caption = "Top20 downregulated genes (CPF); FC<1/2, adj.p <0.05; ranked by logFC")


formattable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:20,], 
             caption ="Top20 downregulated genes (CPF); FC<1/2, adj.p <0.05; ranked by logFC",
            #align =c("c","l", "l", "c"), 
            list(#`entrez_ID` = formatter("span", 
                #                      style = x ~ style(
                #                        color = "#A9A9A9", font.weight = "bold")
                #                      ), 
                 `logFC`= color_tile("lightcoral", NA)

                 )
            )

#remove unused variables
rm(prop_both, fcr_confint )
```

```{r, echo=FALSE}
T3IOP_upregulated <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][,5]
T3IOP_downregulated<- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][,5]
#save(T3IOP_upregulated, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/T3IOP_upregulated_genes.rds")
#save(T3IOP_downregulated, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/T3IOP_downregulated_genes.rds")
```


```{r, echo=FALSE}
#Let us print a summary representation of the differentially expressed genes
paste0(summary(changing & significant)[3] ," differentially expressed genes (P <0.05, FC<1/2 OR FC>2):")
paste0(summary(changing & upregulated)[3] ," genes upregulated by T3_IOP")
paste0(summary(changing & downregulated)[3] ," genes downregulated by T3_IOP")
```


```{r, echo=FALSE}
#to use this as a reference for the genes signaled out from the venn diagram, save as object,
top_table_T3IOP <- top_table
#save(top_table_T3IOP, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/top_table_T3IOP.rds")
```


```{r, echo=FALSE, fig.width=4, fig.height=4}
#and the corresponding plot

ggplot(top_table, aes(x=AveExpr, y=sign(FC)*log2(abs(FC)))) + 
  geom_point(data=top_table[neither,], size=0.5, color="gray60", alpha=0.1) +
  geom_point(data=top_table[notsignificant_high,], size=0.8, color="gray60", alpha=0.5)+
  geom_point(data=top_table[significant_low,], size=0.8, color="gray40", alpha=0.5)+
  geom_point(data=top_table[both,], size=1, color=ifelse(top_table[both, "logFC"]>0,"lightcoral","dodgerblue2"), alpha=0.5)+
   ylim(-10,10)+
  ylab("log2( T3+IOP / DMSO )")+
  xlab("Average Expression")+ 
  geom_hline(yintercept=1, color = "lightcoral", linewidth=0.1)+
  geom_hline(yintercept=-1, color = "dodgerblue2", linewidth=0.1)+
  ggtitle('**CPF** vs **DMSO**')+
  labs(subtitle = '<span style = "color:lightcoral"> upregulated</span>, 
       <span style = "color:dodgerblue2">downregulated</span>')+
  theme_bw()+theme(panel.border = element_rect(color="palegreen3", fill=NA, linewidth= 2),
                   plot.title = ggtext::element_markdown(),
                   plot.subtitle = ggtext::element_markdown())

```

```{r, echo=FALSE}
#Let us plot the top 200 DE genes
#load the counts_VST object
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
```

```{r, echo=FALSE, include=FALSE}
#to add the correlation values with T3 and MPI conditions, let us make a table


#calculate z-score
counts_VST_z <- t(scale(t(counts_VST)))

#create counts table with average values
group_indeces <- c(0, cumsum(unname( table(sample_metadata$treatment))))

counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_z),ncol=0))

#calculate the average by group of replicates

for (i in seq(1:(length(group_indeces)-1))) {
  tmp <- counts_VST_z[,(group_indeces[i]+1):group_indeces[i+1]]
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
}

colnames(counts_VST_averaged) <- unique(sample_metadata$treatment)

corr_df <- as.data.frame(rownames(counts_VST_averaged))
names(corr_df) <- "gene_id"
head(corr_df)

corr_df$deltaMPI <- abs(counts_VST_averaged[,"T3IOP"]-counts_VST_averaged[,"MPI"]) 
corr_df$deltaCPF <- abs(counts_VST_averaged[,"T3IOP"]-counts_VST_averaged[,"CPF"]) 
corr_df$similarity <- NA
head(corr_df)

for (i in seq(1:nrow(corr_df))) {
  if (abs(corr_df$deltaMPI[i])< abs(corr_df$deltaCPF[i])) {
    corr_df$similarity[i] <- "MPI"
    
  }
  
  else {
    corr_df$similarity[i] <- "CPF"
    
  }
  
  #if the closest treatment is more than 1signma away, CPF is not similar to it (and so even less to the other one), it's a unique response
  if (min(corr_df$deltaMPI[i], corr_df$deltaCPF[i]) >1) {
    corr_df$similarity[i] <- "neither"
    
  }
  
  #if both other treatments are within 1 sigma, CPF is in fact similar to both treatments
  if ((corr_df$deltaMPI[i] <1) & (corr_df$deltaCPF[i] <1)) {
    corr_df$similarity[i] <- "both"
    
  }
  
}

rownames(corr_df) <- corr_df$gene_id
corr_df <- corr_df[,2:4]
head(corr_df)

rownames(corr_df) <- annotation_info$merged_description[match(rownames(corr_df), annotation_info$entrez_ID)]

head(corr_df)
```

```{r, echo=FALSE, include=FALSE}
selected_genes <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][1:as.numeric(summary(changing & upregulated)[3]),"entrez_ID"]


# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST)))
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]


#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained")


## subset the original VST object to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)

## Create Unique Column Names
#rownames(counts_VST_selectedgenes) <- dplyr::recode(
#  rownames(counts_VST_selectedgenes), 
#  !!!setNames(make.unique(as.character(annotation_info$description)), # column of dictionary table that has NEW names
#              annotation_info$ensembl_gene_id)  #column of dictionary table with OLD names
#  )

rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]


#remove unused variables
#rm(missing_genes)
```

```{r, fig.height=5, fig.width=15, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


similarity_list_named <- c("lightcoral", "lightskyblue", "gray80", "white")
names(similarity_list_named) <- c("MPI", "CPF", "neither", "both")

ha = rowAnnotation(df = data.frame(treatment = corr_df[rownames(corr_df) %in% rownames(counts_VST_selectedgenes),"similarity"]), #the name of the column needs to match the name of the named list
                            
                            col = list("treatment" = similarity_list_named), #set the name of the named list so it matches
                   simple_anno_size = unit(2, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(8, "mm"))
                   )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        #column_title = gt_render(
        #  "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of CPF-upregulated genes"
        #  ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        right_annotation = ha,
        show_row_names = FALSE,
        show_column_names = FALSE,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        #use_raster = TRUE, raster_magick_filter = "Gaussian"
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```


```{r, echo=FALSE, include=FALSE}
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/counts_VST.rds")
selected_genes <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:as.numeric(summary(changing & downregulated)[3]),"entrez_ID"]


# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST)))
colnames(missing_genes) <- "entrez_ID"
missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]


#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained")


## subset the original VST object to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)

## Create Unique Column Names
#rownames(counts_VST_selectedgenes) <- dplyr::recode(
#  rownames(counts_VST_selectedgenes), 
#  !!!setNames(make.unique(as.character(annotation_info$description)), # column of dictionary table that has NEW names
#              annotation_info$ensembl_gene_id)  #column of dictionary table with OLD names
#  )

rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]


#remove unused variables
#rm(missing_genes)
```

```{r, fig.height=5, fig.width=15, echo=FALSE}

##define the colors for the heatmap (categorical): 1 color for each smallest experimental unit that is being  compared; i.e. here the treatment
color_categorical_heatmap <- color_categorical_treatment
#name this list of color with the corresponding names (note: these are the unique values for that category in the sample metadata)
color_categorical_heatmap_named <- color_categorical_heatmap
names(color_categorical_heatmap_named) <- unique(sample_metadata$treatment)

#load this information into the heatmap
colAnn <- HeatmapAnnotation(#df = data.frame(treatment = sample_metadata$treatment), #the name of the column needs to match the name of the named list
                            
                            #col = list("treatment" = color_categorical_heatmap_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE,
                            which = 'col',
                            
                            #also create an empty row aboe the heatmap, to display additional info
                            empty1 = anno_empty(border = FALSE, height= unit(8, "mm"))
                            )


similarity_list_named <- c("lightcoral", "lightskyblue", "gray80", "white")
names(similarity_list_named) <- c("MPI", "CPF", "neither", "both")

ha = rowAnnotation(df = data.frame(treatment = corr_df[rownames(corr_df) %in% rownames(counts_VST_selectedgenes),"similarity"]), #the name of the column needs to match the name of the named list
                            
                            col = list("treatment" = similarity_list_named), #set the name of the named list so it matches
                   simple_anno_size = unit(2, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(8, "mm"))
                   )


Heatmap(mat = t(scale(t(counts_VST_selectedgenes))),
        name= "z-score",
        #column_title = gt_render(
        #  "Pattern of expression (as <span style='color:brown2'>**z-scores**</span>) <br/> of CPF-upregulated genes"
        #  ),
        col = rev(brewer.pal(11,"RdBu")),
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        #column_order = ordered_levels,
        #row_split = factor(paste0(sample_metadata$segment, sample_metadata$stage), levels = c("liverS1", "liverS4", "liverS7", "stomachS1", "intestineS1", "stomachS4", "A_intestineS4", "P_intestineS4", "stomachS7", "A_intestineS7", "P_intestineS7")),
        column_split = factor(sample_metadata$treatment, levels = c("DMSO", "T3IOP", "MPI", "CPF", "CPF.T3IOP")),
        #cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(c(rep(10,1), rep(2,3)), "mm"),
        #width = unit(8, "cm"), 
        #height = unit(8, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        right_annotation = ha,
        show_row_names = FALSE,
        show_column_names = FALSE,
        show_heatmap_legend = F,
        border = TRUE,
        clustering_method_rows = 'ward.D2'
        #use_raster = TRUE, raster_magick_filter = "Gaussian"
        )


library(GetoptLong)  # for the function qq()
group_block_anno = function(group, empty_anno, gp = gpar(), 
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, 
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}

group_block_anno(1:1, "empty1", gp = gpar(fill = "gray70"), label = "DMSO")
group_block_anno(2:2, "empty1", gp = gpar(fill = "palegreen3"), label = "T3+IOP")
group_block_anno(3:3, "empty1", gp = gpar(fill = "lightcoral"), label = "MPI")
group_block_anno(4:4, "empty1", gp = gpar(fill = "lightskyblue"), label = "CPF")
group_block_anno(5:5, "empty1", gp = gpar(fill = "orchid2"), label = "CPF+T3+IOP")


```




##### effect of CPF.T3 (CPFT3 vs DMSO)


```{r, echo=FALSE, results = FALSE}
#Load voom object "DGE_object_filterednormed_Voomed" for differential expression analysis, and annotation info
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/DGE_object_filterednormed_Voomed.rds")
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated.rds") 

#rename the dataframe as "annotation_info"
annotation_info <- annotation_info_NCBIEnsembl
#remove the column with the original description
#annotation_info <- subset(annotation_info, select = -c(original_description))

#remove unused variables
rm(annotation_info_NCBIEnsembl)

#----------

# apply linear regression model with mean-variance relationship weights calculated above
# lmFit fits a linear model using weighted least squares for each gene:
#extract the linear models that had been fit in the voom object
fit_results <- lmFit(DGE_object_filterednormed_Voomed) #this is the same as doing #fit_results <- lmFit(DGE_object_filterednormed_Voomed, weights=DGE_object_filterednormed_Voomed[["weights"]])

#same as doing lm() individually on each gene (can also supply here the model matrix, but already incorporated through vooming)
head(coef(fit_results))
```


```{r echo=FALSE, fig.height=2.5, fig.width=9, warning=TRUE, paged.print=FALSE}
#Compute comparisons of interest

#Comparisons between groups (log fold-changes) are obtained as contrasts of these fitted linear models:
contrast_matrix <- makeContrasts(treatmentCPF.T3IOP  - treatmentDMSO ,  # positive logchanges will be higher in S4, negative will be higher in S1
                       levels = colnames(coef(fit_results)))
#show newly created contrast matrix
contrast_matrix  # positive logchanges will be higher in S4, negative will be higher in S1

#add the contrast matrix to our fit object
# need to do new objects or it chenges  coefficients instead?
fit_results_contrasted <- contrasts.fit(fit_results, contrast_matrix)

#Empirical Bayes smoothing of standard errors (shrinks standard errors that are much larger or smaller than those from other genes towards the average standard error) (see https://www.degruyter.com/doi/10.2202/1544-6115.1027)
fit_results_contrasted <- eBayes(fit_results_contrasted) #when applied to the output of lmFit(), performs the pooled estimation of standard errors that results in the moderated t-statistics and resulting p-values.

#p.adjust (but this will be done automatically by TopTable function)
#indiv.P.values<-apply(tmp[["p.value"]], 2, p.adjust, method="BH")
#tmp[["BH.adjusted.pvalue"]] <- indiv.P.values


#remove unused variables
rm(fit_results, DGE_object_filterednormed_Voomed)
```
<br/>
Below, a list of all the genes that appear significantly differently expressed between treatment and control (in either direction; __Table 1__). In __Table 2__, the subest of significantly changing genes whose fold-change is bigger than 2folds (in either direction). These genes are ranked in order of decreasing fold change. <br/>

```{r, echo=FALSE}
#What genes are most differentially expressed?
full_top_table <- topTable(fit_results_contrasted, 
                           sort.by = "logFC", 
                           n = Inf, 
                           adjust.method="BH",
                           confint=0.95, #note that these are not adjusted for multiple testing 
                           #p.value=0.05
                           )

#create column that shows logFoldChange as the Fold Change
full_top_table["FC"] <- sign(full_top_table["logFC"])*2^abs(full_top_table["logFC"])

#save list
#save(full_top_table, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/full_top_table_CPFT3IOPvsDMSO.rds")
#load(file = "C://Users/Doctor/Desktop/RNAseq_analyses/Aocellaris_gut_metamorphosis_liver/Saved_objects/full_top_table_S4vsS1.rds")
```

```{r, echo=FALSE}
#find genes with adjusted pvalue
significant <- full_top_table$adj.P.Val < 0.05
#subset genes that are significantly upregulated
upregulated <- significant & sign(full_top_table$FC) == 1
#subest gene that are significantly downregulated
downregulated <- significant & sign(full_top_table$FC) == -1
#find genes that change more than 2x (log2(FC)>=1 or -1)
changing <- (sign(full_top_table$FC)*log2(abs(full_top_table$FC)) > 1 | (sign(full_top_table$FC)*log2(abs(full_top_table$FC))) < -1)


#genes that are neither significant nor changing
neither <- !significant & !changing
#genes that are changing but not significant
notsignificant_high <- !significant & changing
#genes that are significant but not changing
significant_low <- significant & !changing
#find genes that are both significant and changing
both <- significant & changing
```

```{r, echo=FALSE}
#adjust confidence intervals if we are to only select a subset of genes (in our case, significant genes)
#see https://monashbioinformaticsplatform.github.io/r-linear-abacbs2018/topics/linear_models_abacbs2018.html
#find genes which we consider "selected" (significant, or significant AND log2 changing)

prop_both <- mean(changing) #"significant is a 0/1 boolean so the mean is the proportion 
#double check here on why using mean(both) gives non-significant CIs though the adj.p.value is significant.
fcr_confint <- 1 - 0.05*prop_both
#so now replace the confidence interval values

full_top_table <- topTable(fit_results_contrasted, 
                           sort.by = "logFC", 
                           n = Inf, 
                           adjust.method="BH",
                           confint=fcr_confint, #these are now adjusted, when we are just considering the significant genes
                           #p.value=0.05
                           )

#only keep row past p.value threshold
#top.table <- top.table[top.table$adj.P.Val <= 0.5, ]
#create column that shows logFoldChange as the Fold Change
full_top_table["FC"] <- sign(full_top_table["logFC"])*2^abs(full_top_table["logFC"])


#only keep columns we are interested in
top_table <- full_top_table[c("logFC", "FC", "P.Value","adj.P.Val","entrez_ID", "merged_symbol","merged_description","ensembl_description", "AveExpr", "CI.L", "CI.R","t")]

#remove rownames (now redundant)
rownames(top_table) <- NULL

formattable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][1:20,], 
             caption ="Top20 genes upregulated genes (CPF); FC>2, adj.p <0.05; ranked by logFC",
            #align =c("c","l", "l", "c"), 
            list(#`entrez_ID` = formatter("span", 
                #                      style = x ~ style(
                #                        color = "#A9A9A9", font.weight = "bold")
                #                      ), 
                 `logFC`= color_tile(NA,"dodgerblue")

                 )
            )


# list top genes higher in Gut tube
#kable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:20,], caption = "Top20 downregulated genes (CPF); FC<1/2, adj.p <0.05; ranked by logFC")


formattable(top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][1:20,], 
             caption ="Top20 downregulated genes (CPF); FC<1/2, adj.p <0.05; ranked by logFC",
            #align =c("c","l", "l", "c"), 
            list(#`entrez_ID` = formatter("span", 
                #                      style = x ~ style(
                #                        color = "#A9A9A9", font.weight = "bold")
                #                      ), 
                 `logFC`= color_tile("lightcoral", NA)

                 )
            )


#remove unused variables
rm(prop_both, fcr_confint )
```

```{r, echo=FALSE}
CPF.T3IOP_upregulated <- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & upregulated], ][,5]
CPF.T3IOP_downregulated<- top_table[top_table$entrez_ID %in% top_table$entrez_ID[both & downregulated], ][,5]
#save(CPF.T3IOP_upregulated, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/CPFT3IOP_upregulated_genes.rds")
#save(CPF.T3IOP_downregulated, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/CPFT3IOP_downregulated_genes.rds")
```

```{r, echo=FALSE}
#Let us print a summary representation of the differentially expressed genes
paste0(summary(changing & significant)[3] ," differentially expressed genes (P <0.05, FC<1/2 OR FC>2):")
paste0(summary(changing & upregulated)[3] ," genes upregulated by CPF+T3")
paste0(summary(changing & downregulated)[3] ," genes downregulated by CPF+T3")
```
```{r, echo=FALSE, fig.width=4, fig.height=4}
#and the corresponding plot

ggplot(top_table, aes(x=AveExpr, y=sign(FC)*log2(abs(FC)))) + 
  geom_point(data=top_table[neither,], size=0.5, color="gray60", alpha=0.1) +
  geom_point(data=top_table[notsignificant_high,], size=0.8, color="gray60", alpha=0.5)+
  geom_point(data=top_table[significant_low,], size=0.8, color="gray40", alpha=0.5)+
  geom_point(data=top_table[both,], size=1, color=ifelse(top_table[both, "logFC"]>0,"dodgerblue2","lightcoral"), alpha=0.5)+
   theme_bw()+theme(panel.border = element_rect(color="orchid2", fill=NA, linewidth= 2))+
   ylim(-15,15)+
  ylab("log2(CPF+T3/DMSO)")+
  xlab("Average Expression")+ 
  geom_hline(yintercept=1, color = "dodgerblue2", linewidth=0.1)+ # can add linetype="dashed"
  geom_hline(yintercept=-1, color = "lightcoral", linewidth=0.1)

```




#### {-} 

### Comparisons between differentially expressed genes
Venn intersection between CPF, T3, and MPI

```{r, echo=FALSE, fig.width=12, fig.height=6}
#load all the lists of upregulated and downregulated genes in each treatment condition
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_upregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/T3IOP_upregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/MPI_upregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPFT3IOP_upregulated_genes.rds")


load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/T3IOP_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/MPI_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPFT3IOP_downregulated_genes.rds")

load("D://Aocellaris_CPF_MPI_T3/Saved_objects/top_table_CPF.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/top_table_MPI.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/top_table_T3IOP.rds")

x <- list(T3=T3IOP_upregulated,
          MPI=MPI_upregulated,
          CPF=CPF_upregulated
          #CPFT3IOP_up=CPF.T3IOP_upregulated
          )
plot1 <- ggVennDiagram(x) + scale_color_brewer(palette = "Paired")+ggtitle("Upregulated genes")


y <- list(T3=T3IOP_downregulated,
          MPI=MPI_downregulated,
          CPF=CPF_downregulated
          #CPFT3IOP_up=CPF.T3IOP_upregulated
          )
plot2 <- ggVennDiagram(y) + scale_color_brewer(palette = "Paired")+ggtitle("Downregulated genes")

grid.arrange(plot1, plot2, ncol=2, nrow=1)
```
Venn intersection between CPF, T3, and CPFT3IOP

```{r, echo=FALSE, fig.width=12, fig.height=6}
#load all the lists of upregulated and downregulated genes in each treatment condition
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_upregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/T3IOP_upregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/MPI_upregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPFT3IOP_upregulated_genes.rds")


load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPF_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/T3IOP_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/MPI_downregulated_genes.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/CPFT3IOP_downregulated_genes.rds")

load("D://Aocellaris_CPF_MPI_T3/Saved_objects/top_table_CPF.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/top_table_MPI.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/top_table_T3IOP.rds")

x <- list(T3=T3IOP_upregulated,
          CPFT3IOP=CPF.T3IOP_upregulated,
          CPF=CPF_upregulated
          #CPFT3IOP_up=CPF.T3IOP_upregulated
          )
plot1 <- ggVennDiagram(x) + scale_color_brewer(palette = "Paired")+ggtitle("Upregulated genes")


y <- list(T3=T3IOP_downregulated,
          CPFT3IOP=CPF.T3IOP_downregulated,
          CPF=CPF_downregulated
          #CPFT3IOP_up=CPF.T3IOP_upregulated
          )
plot2 <- ggVennDiagram(y) + scale_color_brewer(palette = "Paired")+ggtitle("Downregulated genes")

grid.arrange(plot1, plot2, ncol=2, nrow=1)
```


```{r, echo=FALSE}
#find genes in each intersection (treatment-independent)
upregulated_all <- Reduce(intersect, list(T3IOP_upregulated,MPI_upregulated,CPF_upregulated))
annotation_info[annotation_info$entrez_ID %in% upregulated_all,c("entrez_ID", "merged_symbol", "merged_description")]

upregulated_HPT <- setdiff(Reduce(intersect, list(T3IOP_upregulated,MPI_upregulated)), upregulated_all)
annotation_info[annotation_info$entrez_ID %in% upregulated_HPT,c("entrez_ID", "merged_symbol", "merged_description")]

downregulated_all <- Reduce(intersect, list(T3IOP_downregulated,MPI_downregulated,CPF_downregulated))
annotation_info[annotation_info$entrez_ID %in% downregulated_all,c("entrez_ID", "merged_symbol", "merged_description")]

downregulated_HPT <- setdiff(Reduce(intersect, list(T3IOP_downregulated,MPI_downregulated)), downregulated_all)
annotation_info[annotation_info$entrez_ID %in% downregulated_HPT,c("entrez_ID", "merged_symbol", "merged_description")]
```

Find genes in every intersection (CPF, T3IOP, MPI)

```{r, echo=FALSE}
#find genes in each intersection (upregulated)
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/merged_top_table_T3IOP_CPF.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/merged_top_table_MPI_CPF.rds")

upregulated_CPFandT3IOP <- setdiff(Reduce(intersect, list(T3IOP_upregulated,CPF_upregulated)), upregulated_all)
upregulated_CPFandT3IOP_df <- merged_top_table_CPF_T3IOP[merged_top_table_CPF_T3IOP$entrez_ID %in% upregulated_CPFandT3IOP,]
#create a global ranking method
upregulated_CPFandT3IOP_df <- upregulated_CPFandT3IOP_df[order(abs(upregulated_CPFandT3IOP_df$FC_T3IOP), decreasing = TRUE),]
upregulated_CPFandT3IOP_df$rank_T3IOP <- seq(1:nrow(upregulated_CPFandT3IOP_df))
upregulated_CPFandT3IOP_df <- upregulated_CPFandT3IOP_df[order(abs(upregulated_CPFandT3IOP_df$FC_CPF), decreasing = TRUE),]
upregulated_CPFandT3IOP_df$rank_CPF <- seq(1:nrow(upregulated_CPFandT3IOP_df))
upregulated_CPFandT3IOP_df$rank <- upregulated_CPFandT3IOP_df$rank_T3IOP+upregulated_CPFandT3IOP_df$rank_CPF
upregulated_CPFandT3IOP_df <- upregulated_CPFandT3IOP_df[order(upregulated_CPFandT3IOP_df$rank),]
upregulated_CPFandT3IOP_df <- upregulated_CPFandT3IOP_df[,c("entrez_ID", "ensembl_ID_CPF","merged_symbol_CPF", "merged_description_CPF", "logFC_CPF", "logFC_T3IOP", "FC_CPF", "FC_T3IOP", "rank")]

#write.csv(upregulated_CPFandT3IOP_df,"D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/upregulated_CPFandT3IOP_clean.csv",row.names = FALSE)



upregulated_CPFandMPI <- setdiff(Reduce(intersect, list(MPI_upregulated,CPF_upregulated)), upregulated_all)
upregulated_CPFandMPI_df <- merged_top_table_CPF_MPI[merged_top_table_CPF_MPI$entrez_ID %in% upregulated_CPFandMPI, ]
#create a global ranking method
upregulated_CPFandMPI_df <- upregulated_CPFandMPI_df[order(abs(upregulated_CPFandMPI_df$FC_MPI), decreasing = TRUE),]
upregulated_CPFandMPI_df$rank_MPI <- seq(1:nrow(upregulated_CPFandMPI_df))
upregulated_CPFandMPI_df <- upregulated_CPFandMPI_df[order(abs(upregulated_CPFandMPI_df$FC_CPF), decreasing = TRUE),]
upregulated_CPFandMPI_df$rank_CPF <- seq(1:nrow(upregulated_CPFandMPI_df))
upregulated_CPFandMPI_df$rank <- upregulated_CPFandMPI_df$rank_MPI+upregulated_CPFandMPI_df$rank_CPF
upregulated_CPFandMPI_df <- upregulated_CPFandMPI_df[order(upregulated_CPFandMPI_df$rank),]
upregulated_CPFandMPI_df <- upregulated_CPFandMPI_df[,c("entrez_ID", "ensembl_ID_CPF","merged_symbol_CPF", "merged_description_CPF", "logFC_CPF", "logFC_MPI", "FC_CPF", "FC_MPI", "rank")]

#write.csv(upregulated_CPFandMPI_df,"D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/upregulated_CPFandMPI_clean.csv",row.names = FALSE)


#find genes uniquely upregulated in CPF
upregulated_CPFonly <- setdiff(CPF_upregulated, upregulated_all)
upregulated_CPFonly <- setdiff(upregulated_CPFonly, upregulated_CPFandT3IOP)
upregulated_CPFonly <- setdiff(upregulated_CPFonly, upregulated_CPFandMPI)
upregulated_CPFonly_df <- top_table_CPF[top_table_CPF$entrez_ID %in% upregulated_CPFonly, ]

#write.csv(upregulated_CPFonly_df,"D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/upregulated_CPFonly_clean.csv",row.names = FALSE)


#find genes uniquely upregulated in T3
upregulated_T3only <- setdiff(T3IOP_upregulated, upregulated_all)
upregulated_T3only <- setdiff(upregulated_T3only, upregulated_CPFandT3IOP)
upregulated_T3only <- setdiff(upregulated_T3only, upregulated_HPT) #remove upregulated in T3 and MPI
upregulated_T3only_df <- top_table_T3IOP[top_table_T3IOP$entrez_ID %in% upregulated_T3only, ]

#write.csv(upregulated_T3only_df,"D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/upregulated_T3IOPonly_clean.csv",row.names = FALSE)

#find genes uniquely upregulated in MPI
upregulated_MPIonly <- setdiff(MPI_upregulated, upregulated_all)
upregulated_MPIonly <- setdiff(upregulated_MPIonly, upregulated_CPFandMPI)
upregulated_MPIonly <- setdiff(upregulated_MPIonly, upregulated_HPT) #remove upregulated in T3 and MPI
upregulated_MPIonly_df <- top_table_MPI[top_table_MPI$entrez_ID %in% upregulated_MPIonly, ]

#write.csv(upregulated_MPIonly_df,"D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/upregulated_MPIonly_clean.csv",row.names = FALSE)
```

Find genes in every intersection (CPF, T3IOP, CPFT3IOP)
```{r, echo=FALSE}
#find genes in each intersection (downregulated)
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/merged_top_table_T3IOP_CPF.rds")
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/merged_top_table_MPI_CPF.rds")

downregulated_CPFandT3IOP <- setdiff(Reduce(intersect, list(T3IOP_downregulated,CPF_downregulated)), downregulated_all)
downregulated_CPFandT3IOP_df <- merged_top_table_CPF_T3IOP[merged_top_table_CPF_T3IOP$entrez_ID %in% downregulated_CPFandT3IOP,]
 #create a global ranking method
downregulated_CPFandT3IOP_df <- downregulated_CPFandT3IOP_df[order(abs(downregulated_CPFandT3IOP_df$FC_T3IOP), decreasing = TRUE),]
downregulated_CPFandT3IOP_df$rank_T3IOP <- seq(1:nrow(downregulated_CPFandT3IOP_df))
downregulated_CPFandT3IOP_df <- downregulated_CPFandT3IOP_df[order(abs(downregulated_CPFandT3IOP_df$FC_CPF), decreasing = TRUE),]
downregulated_CPFandT3IOP_df$rank_CPF <- seq(1:nrow(downregulated_CPFandT3IOP_df))
downregulated_CPFandT3IOP_df$rank <- downregulated_CPFandT3IOP_df$rank_T3IOP+downregulated_CPFandT3IOP_df$rank_CPF
downregulated_CPFandT3IOP_df <- downregulated_CPFandT3IOP_df[order(downregulated_CPFandT3IOP_df$rank),]
downregulated_CPFandT3IOP_df <- downregulated_CPFandT3IOP_df[,c("entrez_ID", "ensembl_ID_CPF","merged_symbol_CPF", "merged_description_CPF", "logFC_CPF", "logFC_T3IOP", "FC_CPF", "FC_T3IOP", "rank")]

#write.csv(downregulated_CPFandT3IOP_df,"D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/downregulated_CPFandT3IOP_clean.csv",row.names = FALSE)


downregulated_CPFandMPI <- setdiff(Reduce(intersect, list(MPI_downregulated,CPF_downregulated)), downregulated_all)
downregulated_CPFandMPI_df <- merged_top_table_CPF_MPI[merged_top_table_CPF_MPI$entrez_ID %in% downregulated_CPFandMPI,]
#create a global ranking method
downregulated_CPFandMPI_df <- downregulated_CPFandMPI_df[order(abs(downregulated_CPFandMPI_df$FC_MPI), decreasing = TRUE),]
downregulated_CPFandMPI_df$rank_MPI <- seq(1:nrow(downregulated_CPFandMPI_df))
downregulated_CPFandMPI_df <- downregulated_CPFandMPI_df[order(abs(downregulated_CPFandMPI_df$FC_CPF), decreasing = TRUE),]
downregulated_CPFandMPI_df$rank_CPF <- seq(1:nrow(downregulated_CPFandMPI_df))
downregulated_CPFandMPI_df$rank <- downregulated_CPFandMPI_df$rank_MPI+downregulated_CPFandMPI_df$rank_CPF
downregulated_CPFandMPI_df <- downregulated_CPFandMPI_df[order(downregulated_CPFandMPI_df$rank),]
downregulated_CPFandMPI_df <- downregulated_CPFandMPI_df[,c("entrez_ID", "ensembl_ID_CPF","merged_symbol_CPF", "merged_description_CPF", "logFC_CPF", "logFC_MPI", "FC_CPF", "FC_MPI", "rank")]

#write.csv(downregulated_CPFandMPI_df,"D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/downregulated_CPFandMPI_clean.csv",row.names = FALSE)



#find genes uniquely downregulated in CPF
downregulated_CPFonly <- setdiff(CPF_downregulated, downregulated_all)
downregulated_CPFonly <- setdiff(downregulated_CPFonly, downregulated_CPFandT3IOP)
downregulated_CPFonly <- setdiff(downregulated_CPFonly, downregulated_CPFandMPI)
downregulated_CPFonly_df <- top_table_CPF[top_table_CPF$entrez_ID %in% downregulated_CPFonly, ]

#write.csv(downregulated_CPFonly_df,"D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/downregulated_CPFonly_clean.csv",row.names = FALSE)

#find genes uniquely downregulated in T3
downregulated_T3only <- setdiff(T3IOP_downregulated, downregulated_all)
downregulated_T3only <- setdiff(downregulated_T3only, downregulated_CPFandT3IOP)
downregulated_T3only <- setdiff(downregulated_T3only, downregulated_HPT) #i.e. remove downregulated in T3 and MPI
downregulated_T3only_df <- top_table_T3IOP[top_table_T3IOP$entrez_ID %in% downregulated_T3only, ]

#write.csv(downregulated_T3only_df,"D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/downregulated_T3IOPonly_clean.csv",row.names = FALSE)

#find genes uniquely downregulated in MPI
downregulated_MPIonly <- setdiff(MPI_downregulated, downregulated_all)
downregulated_MPIonly <- setdiff(downregulated_MPIonly, downregulated_CPFandMPI)
downregulated_MPIonly <- setdiff(downregulated_MPIonly, downregulated_HPT) #i.e. remove downregulated in T3 and MPI
downregulated_MPIonly_df <- top_table_MPI[top_table_MPI$entrez_ID %in% downregulated_MPIonly, ]

#write.csv(downregulated_MPIonly_df,"D://Aocellaris_CPF_MPI_T3/Saved_objects/Venn/downregulated_MPIonly_clean.csv",row.names = FALSE)
```




### Comparing CPF and CPF+T3IOP

```{r, echo=FALSE}
## Let us import the TopTables (tables of differentially expressed genes) from each dataset
#load list of DE genes in the T3+CPF treatment
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/full_top_table_CPFT3IOPvsDMSO.rds")
full_top_table_CPFT3IOPvsDMSO <- full_top_table
#reload list of DE genes in the CPF treatment
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/full_top_table_CPFvsDMSO.rds")
full_top_table_CPFvsDMSO <- full_top_table
rm(full_top_table)
#prepare combined table


## Let us load the manual annotation 
#the table with the annotation information of each gene (with manual curation of the description), was made in a separate notebook (cfr "Aocellaris_annotationinfo_maker.Rmd) and saved as a R object which we will load here. #annotation_info_NCBIEnsembl
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated.rds") 

#rename the dataframe as "annotation_info"
annotation_info <- annotation_info_NCBIEnsembl
#remove the column with the original description
#annotation_info <- subset(annotation_info, select = -c(original_description))

#remove unused variables
rm(annotation_info_NCBIEnsembl)

##Let us update the gene descriptions with the latest annotation, just in case the toptables had been generated under the older annotation
#full_top_table_MPIcontrol$description<-annotation_info[match(full_top_table_MPIcontrol$ensembl_gene_id, annotation_info$ensembl_gene_id),"description"]
#full_top_table_T3control$description<-annotation_info[match(full_top_table_T3control$ensembl_gene_id, annotation_info$ensembl_gene_id),"description"]

```


```{r, echo=FALSE}
kable(full_top_table_CPFT3IOPvsDMSO[1:20,], caption = "Top20 differentially expressed genes in CPFT3IOP vs control (all FC and pvalues; ranked by FC)") #from how we defined the contrasts, a positive FC here == higher in MPI
kable(full_top_table_CPFvsDMSO[1:20,], caption = "Top20 differentially expressed genes in CPF vs control (all FC and pvalues; ranked by FC)") #from how we defined the contrasts, a negative FC here == higher in T3

#In this case, the two toptable come from the same dataset, so all genes in one will also be present in the other one, ad they underwent the same filtering. No need to remove excess genes in either table

##let us create a "merged toptable" where genes have the FC for both contrasts
#(notice that now both toptables have the same length)
merged_top_table <- merge(full_top_table_CPFT3IOPvsDMSO,
                          full_top_table_CPFvsDMSO,
                          by="entrez_ID",
                          suffixes = c("_CPFT3IOP","_CPF"))

#show first entries of merged toptable
#kable(merged_top_table[1:20,])
``` 


```{r, echo=FALSE}
#let us add a column with the MPI status
merged_top_table$MPI_status <- "neither"

for (i in seq(1:nrow(merged_top_table))) {
  if (merged_top_table$entrez_ID[i] %in% MPI_upregulated) {
    merged_top_table$MPI_status[i] <- "UP"
  }
  
  if (merged_top_table$entrez_ID[i] %in% MPI_downregulated){
    merged_top_table$MPI_status[i] <- "DOWN"
  }
  
  
}
```

```{r,fig.height=5, fig.width=6, echo=FALSE}
#plot
plot1 <- ggplot(merged_top_table, aes(x=sign(FC_CPFT3IOP)*log2(abs(FC_CPFT3IOP)), 
                                      y=sign(FC_CPF)*log2(abs(FC_CPF)))) +
  geom_point(data=merged_top_table, size=0.1, color="gray60", alpha=0.1)+
  #contrast X specific (i.e. were not DE in contrast Y)
  geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& abs(merged_top_table$logFC_CPFT3IOP) > 1 & abs(merged_top_table$logFC_CPF) < 1,], size=1, color="palegreen3", alpha=0.3) + #differentially expressed genes in MPI only
  #contrast Y specific (i.e. were not DE in contrast X)
  geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPF < 0.05& abs(merged_top_table$logFC_CPF) > 1 & abs(merged_top_table$logFC_CPFT3IOP) < 1,], size=1, color="lightskyblue", alpha=0.1) + #differentially expressed genes in CPF only
  # were DE for both contrast X and Y
      geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$logFC_CPFT3IOP > 1 & merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$logFC_CPF > 1,], size=1.2, 
             color="orchid", 
             alpha=0.8) +
        geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$logFC_CPFT3IOP < (0-1) & merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$logFC_CPF < (0-1),], size=1.2, 
             color="orchid", 
             alpha=0.8) +
    geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$logFC_CPFT3IOP < -1 & merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$logFC_CPF > 1,], size=1.2, 
             color="sandybrown", 
             alpha=0.8) +
      geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$logFC_CPFT3IOP > 1 & merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$logFC_CPF < (0-1),], size=1.2, 
             color="sandybrown", 
             alpha=0.8) +
  #now add the same categories, but those that did not pass foldchange threshold
  #contrast X specific (i.e. were not DE in contrast Y)
  geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& abs(merged_top_table$logFC_CPFT3IOP) <= 1,], size=1, color="gray40", alpha=0.1) + 
  #contrast Y specific (i.e. were not DE in contrast X)
  geom_point(data=merged_top_table[merged_top_table$adj.P.Val_T3 < 0.05& abs(merged_top_table$logFC_CPF) <= 1,], size=1, color="gray40", alpha=0.1) +
  # were DE for both contrat X and Y
  geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& abs(merged_top_table$logFC_CPFT3IOP) <= 1 & merged_top_table$adj.P.Val_CPF < 0.05 & abs(merged_top_table$logFC_CPF) <= 1,], size=1.2, color="gray40", alpha=0.1) +

  xlim(-11,11)+
  ylim(-11,11)+
  xlab('<span style = "color:gray60">Higher in DMSO<-</span> log2(CPFT3IOP/DMSO Fold Change) <span style = "color:gray60">-> Higher in CPFT3IOP</span>')+
  ylab('<span style = "color:gray60">Higher in DMSO <-</span> log2(CPF/DMSO Fold Change) <span style = "color:gray60">-> Higher in CPF</span>')+ 
  geom_hline(yintercept=1, color = "gray40", linewidth=0.1)+ # can add linetype="dashed"
  geom_hline(yintercept=-1, color = "gray40", linewidth=0.1)+
  geom_vline(xintercept=1, color = "gray40", linewidth=0.1)+
  geom_vline(xintercept=-1, color = "gray40", linewidth=0.1)+
  geom_hline(yintercept=0, color = "gray85", size=0.1)+ 
  geom_vline(xintercept=0, color = "gray85", size=0.1)+
  ggtitle('Differentially expressed genes in **CPFT3IOP** vs **CPF**')+
  labs(subtitle = '<span style = "color:dodgerblue2"> DE in CPF only</span>, 
       <span style = "color:palegreen3">DE in CPFT3IOP only</span>, <br/>
       <span style = "color:orchid">DE in same direction</span>,
       <span style = "color:sandybrown">DE in opposite direction</span>')+
  theme_bw()+theme(plot.title = ggtext::element_markdown(),
                   plot.subtitle = ggtext::element_markdown(),
                   axis.title.x = ggtext::element_markdown(),
                   axis.title.y = ggtext::element_markdown())
  NULL

plot1


#bottomleft: genes that are higher in control (lowered) under any intervention. I.e. genes downregulated to experimental e.g. stress
#topright: genes that increased by either treatment. i.e. genes upregulated due to e.g. experimental stress?

#topleft: genes that are under positive regulation by T3 (higher than control under T3, and lower than control (lowered) under MPI)
#bottomright: genes that are repressed by T3 (higher in MPI than control, and higher in control (lowered) in T3)
```


```{r,fig.height=5, fig.width=6, echo=FALSE}
plot1
plot1 + geom_point(data=merged_top_table[merged_top_table$entrez_ID %in% selected_genes,], size=2, color="lightcoral", alpha=1) 
plot1 + geom_point(data=merged_top_table[merged_top_table$MPI_status == "DOWN",], size=1, color="lightcoral", alpha=1) 
```


Attenuation plot
```{r,fig.height=5, fig.width=6, echo=FALSE}
#plot
plot1 <- ggplot(merged_top_table, aes(y=sign(FC_CPFT3IOP)*log2(abs(FC_CPFT3IOP)), 
                                      x=sign(FC_CPF)*log2(abs(FC_CPF)))) +
  geom_point(data=merged_top_table, size=0.5, color="gray60", alpha=0.1) +
geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$FC_CPFT3IOP > 0 & merged_top_table$FC_CPF > 0,], size=1, color="orchid", alpha=0.3) +
geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$FC_CPFT3IOP < 0 & merged_top_table$FC_CPF < 0,], size=1, color="orchid", alpha=0.3) +
geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$adj.P.Val_CPF < 0.05 & abs(merged_top_table$FC_CPFT3IOP) < 1*abs(merged_top_table$FC_CPF),], size=1, color="lightskyblue", alpha=1) +
geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$FC_CPFT3IOP < 0 & merged_top_table$FC_CPF > 0,], size=1, color="dodgerblue", alpha=1) +
geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$FC_CPFT3IOP > 0 & merged_top_table$FC_CPF < 0,], size=1, color="dodgerblue", alpha=1) +
  xlim(-11,11)+
  ylim(-11,11)+
  ylab('<span style = "color:gray60">Higher in DMSO<-</span> log2(CPFT3IOP/DMSO Fold Change) <span style = "color:gray60">-> Higher in CPFT3IOP</span>')+
  xlab('<span style = "color:gray60">Higher in DMSO <-</span> log2(CPF/DMSO Fold Change) <span style = "color:gray60">-> Higher in CPF</span>')+ 
  geom_hline(yintercept=1, color = "gray85", linewidth=0.1)+ # can add linetype="dashed"
  geom_hline(yintercept=-1, color = "gray85", linewidth=0.1)+
  geom_vline(xintercept=1, color = "gray85", linewidth=0.1)+
  geom_vline(xintercept=-1, color = "gray85", linewidth=0.1)+
  geom_hline(yintercept=0, color = "gray40", size=0.1)+ 
  geom_vline(xintercept=0, color = "gray40", size=0.1)+
  ggtitle('Differentially expressed genes in **CPF+T3IOP** vs **CPF**')+
  labs(subtitle = '<span style = "color:orchid">change in same direction</span>,
       <span style = "color:sandybrown">change in opposite direction</span>')+
  theme_bw()+theme(plot.title = ggtext::element_markdown(),
                   plot.subtitle = ggtext::element_markdown(),
                   axis.title.x = ggtext::element_markdown(),
                   axis.title.y = ggtext::element_markdown(),
                   panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  geom_abline(intercept = 0, slope = 1, linetype="dashed")+
  #geom_abline(intercept = 0, slope = 0.7, linetype="dashed")+
  NULL

plot1



```

```{r,fig.height=5, fig.width=6, echo=FALSE}

plot1 + geom_point(data=merged_top_table[merged_top_table$entrez_ID %in% selected_genes,], size=2, color="lightcoral", alpha=1) 

```
Alluvial plot

```{r, echo=FALSE}
#prepare table for alluvial plot
alluvial_df <- merged_top_table

#dim(alluvial_df[((alluvial_df$adj.P.Val_CPF <= 0.05) & alluvial_df$logFC_CPF >= 1) | ((alluvial_df$adj.P.Val_CPF <= 0.05) & alluvial_df$logFC_CPF < -1),])

alluvial_df <- alluvial_df[alluvial_df$adj.P.Val_CPF < 0.05,]
alluvial_df$DE_CPF[alluvial_df$logFC_CPF >= 1 | alluvial_df$logFC_CPF < -1] <- "DE"
alluvial_df <- alluvial_df[!is.na(alluvial_df$DE_CPF),]


#alluvial_df$DE_CPF <- "no"
alluvial_df$DE_CPF[alluvial_df$logFC_CPF >= 1] <- "1.upregulated"
alluvial_df$DE_CPF[alluvial_df$logFC_CPF <= -1] <- "2.downregulated"

alluvial_df$direction <- "1.same"
alluvial_df$direction[sign(alluvial_df$FC_CPF) != sign(alluvial_df$FC_CPFT3IOP)] <- "2.opposite"

alluvial_df$magnitutde_of_change <- "1.increased"
alluvial_df$magnitutde_of_change[abs(alluvial_df$FC_CPFT3IOP) < abs(alluvial_df$FC_CPF)] <- "2.attenuated"
alluvial_df$magnitutde_of_change[alluvial_df$direction == "2.opposite"] <- "3.reversed"

```


```{r, warning=FALSE, echo=FALSE}
#plot alluvial plot
library(ggalluvial)


#palette_Pdum <- c("palegreen4","palegreen3","palegreen2",  "lightcoral", "lightpink","mistyrose", "dodgerblue3","lightskyblue", "lightskyblue1", "lightskyblue2")

ggplot(alluvial_df,
       aes(axis1 = as.factor(DE_CPF) ,
           #axis2 = as.factor(direction), 
           axis2 = as.factor(magnitutde_of_change))) +
  #geom_stratum(width = 1/12, fill = hue_pal()(11), color = "grey") +
  geom_stratum(width = 1/12, fill = c("lightcoral", "forestgreen", "dodgerblue", "lightskyblue", "orchid"), color = "black") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum)), aes.bind = TRUE) +
  geom_flow(aes(fill = factor(magnitutde_of_change)))+
  scale_x_discrete(limits = c("CPF_DE","Magnitute_of_change"), expand = c(.05, .05)) +
  #scale_fill_brewer(type = "qual", palette = "Set1") +
  scale_fill_manual(values = c("orchid", "lightskyblue", "dodgerblue"))+
  ggtitle("Effects of T3IOP-ddition to CPF")+
  theme_bw()+theme(legend.position = "none")+
  theme(#panel.border = element_rect(color="lightskyblue", fill=NA, linewidth= 2),
                   plot.title = ggtext::element_markdown(),
                   plot.subtitle = ggtext::element_markdown())+
  NULL



```

```{r, echo=FALSE}
alluvial_df[alluvial_df$DE_CPF == "upregulated" & alluvial_df$direction == "opposite",]
alluvial_df[alluvial_df$DE_CPF == "2.downregulated" & alluvial_df$direction == "2.opposite",]
```


```{r,fig.height=5, fig.width=6, echo=FALSE}
plot1
plot1 + geom_point(data=merged_top_table[merged_top_table$MPI_status == "UP",], size=1, color="lightcoral", alpha=1) 
plot1 + geom_point(data=merged_top_table[merged_top_table$MPI_status == "DOWN",], size=1, color="lightcoral", alpha=1) 
```


```{r, echo=FALSE}
#list genes downregulated by CPFT3IOP, but upregulated by CPF, topleft
activated <- merged_top_table[merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$logFC_CPF > 1 & merged_top_table$adj.P.Val_CPFT3IOP < 0.05 & merged_top_table$logFC_CPFT3IOP < -1,]
#create a global ranking method
activated <- activated[order(abs(activated$FC_CPFT3IOP), decreasing = TRUE),]
activated$rank_CPFT3IOP <- seq(1:nrow(activated))
activated <- activated[order(abs(activated$FC_CPF), decreasing = TRUE),]
activated$rank_CPF <- seq(1:nrow(activated))
activated$rank <- activated$rank_CPFT3IOP+activated$rank_CPF
activated <- activated[order(activated$rank),]
activated <- activated[,c("entrez_ID", "ensembl_ID_CPFT3IOP","merged_symbol_CPFT3IOP", "merged_description_CPFT3IOP", "logFC_CPFT3IOP", "logFC_CPF", "FC_CPFT3IOP", "FC_CPF", "rank")]

kable(activated, caption = "Differentially Expressed genes (p < 0.5, FC>2 or FC<1/2) downregulated by CPFT3IOP but upregulated by CPF")

#list genes upregulated by CPFT3IOP, but downregulated by CPF, bottomright
repressed <- merged_top_table[merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$logFC_CPF < -1 & merged_top_table$adj.P.Val_CPFT3IOP < 0.05 & merged_top_table$logFC_CPFT3IOP > 1,]
#create a global ranking method
repressed <- repressed[order(abs(repressed$FC_CPFT3IOP), decreasing = TRUE),]
repressed$rank_CPFT3IOP <- seq(1:nrow(repressed))
repressed <- repressed[order(abs(repressed$FC_CPF), decreasing = TRUE),]
repressed$rank_CPF <- seq(1:nrow(repressed))
repressed$rank <- repressed$rank_CPFT3IOP+repressed$rank_CPF
repressed <- repressed[order(repressed$rank),]
repressed <- repressed[,c("entrez_ID", "ensembl_ID_CPFT3IOP","merged_symbol_CPFT3IOP", "merged_description_CPFT3IOP", "logFC_CPFT3IOP", "logFC_CPF", "FC_CPFT3IOP", "FC_CPF", "rank")]

kable(repressed, caption = "Differentially Expressed genes (p < 0.5, FC>2 or FC<1/2) upregulated by CPFT3IOP but downregulated by CPF")

#list stress genes upregulated, topright
#up_both <- merged_top_table[merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$logFC_CPF > 1 & merged_top_table$adj.P.Val_T3IOP < 0.05 & merged_top_table$logFC_T3IOP >1,]
#create a global ranking method
#up_both <- up_both[order(abs(up_both$FC_T3IOP), decreasing = TRUE),]
#up_both$rank_T3IOP <- seq(1:nrow(up_both))
#up_both <- up_both[order(abs(up_both$FC_CPF), decreasing = TRUE),]
#up_both$rank_CPF <- seq(1:nrow(up_both))
#up_both$rank <- up_both$rank_T3IOP+up_both$rank_CPF
#up_both <- up_both[order(up_both$rank),]
#up_both <- up_both[,c("entrez_ID", "ensembl_ID_CPFT3IOP","merged_symbol_CPFT3IOP", "merged_description_CPFT3IOP", "logFC_CPFT3IOP", "logFC_CPF", "FC_CPFT3IOP", "FC_CPF", "rank")]

#kable(up_both, caption = "Differentially Expressed genes (p < 0.5, FC>2 or FC<1/2) activated by CPF and T3IOP")

#list stress genes downregulated, bottomleft
#down_both <- merged_top_table[merged_top_table$adj.P.Val_CPF < 0.05 & merged_top_table$logFC_CPF < -1 & merged_top_table$adj.P.Val_T3IOP < 0.05 & merged_top_table$logFC_T3IOP < -1,]
#create a global ranking method
#down_both <- down_both[order(abs(down_both$FC_T3IOP), decreasing = TRUE),]
#down_both$rank_T3IOP <- seq(1:nrow(down_both))
#down_both <- down_both[order(abs(down_both$FC_CPF), decreasing = TRUE),]
#down_both$rank_CPF <- seq(1:nrow(down_both))
#down_both$rank <- down_both$rank_T3IOP+down_both$rank_CPF
#down_both <- down_both[order(down_both$rank),]
#down_both <- down_both[,c("entrez_ID", "ensembl_ID_CPFT3IOP","merged_symbol_CPFT3IOP", "merged_description_CPFT3IOP", "logFC_CPFT3IOP", "logFC_CPF", "FC_CPFT3IOP", "FC_CPF", "rank")]

#kable(down_both, caption = "Differentially Expressed genes (p < 0.5, FC>2 or FC<1/2) downregulated by CPF and T3IOP")

#remove unused variables
#rm(activated, repressed, up_both, down_both)
```


```{r, echo=FALSE, include=FALSE}
#list genes downregulated or upregulated by MPI, but unaffected by CPF
T3IOP_only <- merged_top_table[merged_top_table$adj.P.Val_T3IOP < 0.05& abs(merged_top_table$logFC_T3IOP) > 1 & abs(merged_top_table$logFC_CPF) < 1,]
#create a global ranking method
T3IOP_only <- T3IOP_only[order(abs(T3IOP_only$FC_T3IOP), decreasing = TRUE),]
T3IOP_only$rank_T3IOP <- seq(1:nrow(T3IOP_only))
T3IOP_only <- T3IOP_only[order(abs(T3IOP_only$FC_CPF), decreasing = TRUE),]
T3IOP_only$rank_CPF <- seq(1:nrow(T3IOP_only))
T3IOP_only$rank <- T3IOP_only$rank_T3IOP+T3IOP_only$rank_CPF
T3IOP_only <- T3IOP_only[order(T3IOP_only$rank),]
T3IOP_only <- T3IOP_only[,c("entrez_ID", "ensembl_ID_T3IOP","merged_symbol_T3IOP", "merged_description_T3IOP", "logFC_T3IOP", "logFC_CPF", "FC_T3IOP", "FC_CPF", "rank")]


#list genes downregulated or upregulated by CPF, but unaffected by MPI
CPF_only <- merged_top_table[merged_top_table$adj.P.Val_CPF < 0.05& abs(merged_top_table$logFC_CPF) > 1 & abs(merged_top_table$logFC_T3IOP) < 1,]
#create a global ranking method
CPF_only <- CPF_only[order(abs(CPF_only$FC_T3IOP), decreasing = TRUE),]
CPF_only$rank_T3IOP <- seq(1:nrow(CPF_only))
CPF_only <- CPF_only[order(abs(CPF_only$FC_CPF), decreasing = TRUE),]
CPF_only$rank_CPF <- seq(1:nrow(CPF_only))
CPF_only$rank <- CPF_only$rank_T3IOP+CPF_only$rank_CPF
CPF_only <- CPF_only[order(CPF_only$rank),]
CPF_only <- CPF_only[,c("entrez_ID", "ensembl_ID_T3IOP","merged_symbol_T3IOP", "merged_description_T3IOP", "logFC_T3IOP", "logFC_CPF", "FC_T3IOP", "FC_CPF", "rank")]
```


```{r, echo=FALSE}
#Let us print a summary representation of the differentially expressed genes
paste0(dim(up_both)[1] ,"  differentially expressed genes upregulated by both CPF and T3IOP")
paste0(dim(down_both)[1] ,"  differentially expressed genes downregulated by both CPF and T3IOP")
paste0(dim(activated)[1]," differentially expressed genes downregulated by T3IOP but upregulated by CPF")
paste0(dim(repressed)[1] ," differentially expressed genes upregulated by T3IOP but downreegulated by CPF")

#in this case, it is also interesting to list genes that are upregulated by CPF but are not affected (do not significantly change) under T3IOP; and viceversa
paste0(dim(T3IOP_only)[1] ,"  differentially expressed genes under T3IOP, unaffected by CPF")
paste0(dim(CPF_only)[1] ,"  differentially expressed genes under CPF, unaffected by T3IOP")
```

```{r, echo=FALSE}
#let us save lists of these genes for dedicated analysis
write.csv(up_both,"D://Aocellaris_CPF_MPI_T3/Saved_objects/upregulated_CPFandT3IOP.csv",row.names = FALSE)
write.csv(down_both,"D://Aocellaris_CPF_MPI_T3/Saved_objects/downregulated_CPFandT3IOP.csv",row.names = FALSE)
write.csv(MPI_only,"D://Aocellaris_CPF_MPI_T3/Saved_objects/regulated_by_T3IOPnotCPF.csv",row.names = FALSE)
write.csv(CPF_only,"D://Aocellaris_CPF_MPI_T3/Saved_objects/regulated_by_CPFnotT3IOP.csv",row.names = FALSE)
write.csv(activated,"D://Aocellaris_CPF_MPI_T3/Saved_objects/upCPF_downT3IOP.csv",row.names = FALSE)
write.csv(repressed,"D://Aocellaris_CPF_MPI_T3/Saved_objects/upT3IOP_downCPF.csv",row.names = FALSE)
```

```{r, echo=FALSE}
#to use this as a reference for the genes signled out frm the venn diagram, save as object,
activated_CPF_T3IOP <- activated
merged_top_table_CPF_T3IOP <- merged_top_table
save(merged_top_table_CPF_T3IOP, file = "D://Aocellaris_CPF_MPI_T3/Saved_objects/merged_top_table_T3IOP_CPF.rds")
```



### Comparing T3IOP and CPF+T3IOP

```{r, echo=FALSE}
## Let us import the TopTables (tables of differentially expressed genes) from each dataset
#load list of DE genes in the T3+CPF treatment
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/full_top_table_CPFT3IOPvsDMSO.rds")
full_top_table_CPFT3IOPvsDMSO <- full_top_table
#reload list of DE genes in the T3IOP treatment
load("D://Aocellaris_CPF_MPI_T3/Saved_objects/full_top_table_T3IOPvsDMSO.rds")
full_top_table_T3IOPvsDMSO <- full_top_table
rm(full_top_table)
#prepare combined table

```


```{r, echo=FALSE}
kable(full_top_table_CPFT3IOPvsDMSO[1:20,], caption = "Top20 differentially expressed genes in CPFT3IOP vs control (all FC and pvalues; ranked by FC)") #from how we defined the contrasts, a positive FC here == higher in MPI
kable(full_top_table_T3IOPvsDMSO[1:20,], caption = "Top20 differentially expressed genes in CPF vs control (all FC and pvalues; ranked by FC)") #from how we defined the contrasts, a negative FC here == higher in T3

#In this case, the two toptable come from the same dataset, so all genes in one will also be present in the other one, ad they underwent the same filtering. No need to remove excess genes in either table

##let us create a "merged toptable" where genes have the FC for both contrasts
#(notice that now both toptables have the same length)
merged_top_table <- merge(full_top_table_CPFT3IOPvsDMSO,
                          full_top_table_T3IOPvsDMSO,
                          by="entrez_ID",
                          suffixes = c("_CPFT3IOP","_T3IOP"))

#show first entries of merged toptable
#kable(merged_top_table[1:20,])
``` 

Attenuation plot

```{r,fig.height=5, fig.width=6, echo=FALSE}
#plot
plot1 <- ggplot(merged_top_table, aes(y=sign(FC_CPFT3IOP)*log2(abs(FC_CPFT3IOP)), 
                                      x=sign(FC_T3IOP)*log2(abs(FC_T3IOP)))) +
  geom_point(data=merged_top_table, size=0.5, color="gray60", alpha=0.1) +
geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$adj.P.Val_T3IOP < 0.05 & merged_top_table$FC_CPFT3IOP > 0 & merged_top_table$FC_T3IOP > 0,], size=1, color="orchid", alpha=0.3) +
geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$adj.P.Val_T3IOP < 0.05 & merged_top_table$FC_CPFT3IOP < 0 & merged_top_table$FC_T3IOP < 0,], size=1, color="orchid", alpha=0.3) +
geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$adj.P.Val_T3IOP < 0.05 & abs(merged_top_table$FC_CPFT3IOP) < 1*abs(merged_top_table$FC_T3IOP),], size=1, color="lightskyblue", alpha=1) +
geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$adj.P.Val_T3IOP < 0.05 & merged_top_table$FC_CPFT3IOP < 0 & merged_top_table$FC_T3IOP > 0,], size=1, color="dodgerblue", alpha=0.3) +
geom_point(data=merged_top_table[merged_top_table$adj.P.Val_CPFT3IOP < 0.05& merged_top_table$adj.P.Val_T3IOP < 0.05 & merged_top_table$FC_CPFT3IOP > 0 & merged_top_table$FC_T3IOP < 0,], size=1, color="dodgerblue", alpha=0.3) +
  xlim(-11,11)+
  ylim(-11,11)+
  ylab('<span style = "color:gray60">Higher in DMSO<-</span> log2(CPFT3IOP/DMSO Fold Change) <span style = "color:gray60">-> Higher in CPFT3IOP</span>')+
  xlab('<span style = "color:gray60">Higher in DMSO <-</span> log2(T3IOP/DMSO Fold Change) <span style = "color:gray60">-> Higher in T3IOP</span>')+ 
  geom_hline(yintercept=1, color = "gray85", linewidth=0.1)+ # can add linetype="dashed"
  geom_hline(yintercept=-1, color = "gray85", linewidth=0.1)+
  geom_vline(xintercept=1, color = "gray85", linewidth=0.1)+
  geom_vline(xintercept=-1, color = "gray85", linewidth=0.1)+
  geom_hline(yintercept=0, color = "gray40", size=0.1)+ 
  geom_vline(xintercept=0, color = "gray40", size=0.1)+
  ggtitle('Differentially expressed genes in **CPF+T3IOP** vs **T3IOP**')+
  labs(subtitle = '<span style = "color:orchid">change in same direction</span>,
       <span style = "color:sandybrown">change in opposite direction</span>')+
  theme_bw()+theme(plot.title = ggtext::element_markdown(),
                   plot.subtitle = ggtext::element_markdown(),
                   axis.title.x = ggtext::element_markdown(),
                   axis.title.y = ggtext::element_markdown(),
                   panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  geom_abline(intercept = 0, slope = 1, linetype="dashed")+
  #geom_abline(intercept = 0, slope = 0.7, linetype="dashed")+
  NULL

plot1



```

```{r, echo=FALSE}
plot1 + geom_point(data=merged_top_table[merged_top_table$entrez_ID == "111572682",], size=1, color="lightcoral", alpha=1) 
```

Alluvial plot

```{r, echo=FALSE}
#prepare table for alluvial plot
alluvial_df <- merged_top_table

#dim(alluvial_df[((alluvial_df$adj.P.Val_T3IOP <= 0.05) & alluvial_df$logFC_T3IOP >= 1) | ((alluvial_df$adj.P.Val_T3IOP <= 0.05) & alluvial_df$logFC_T3IOP < -1),])

alluvial_df <- alluvial_df[alluvial_df$adj.P.Val_T3IOP < 0.05,]
alluvial_df$DE_T3IOP[alluvial_df$logFC_T3IOP >= 1 | alluvial_df$logFC_T3IOP < -1] <- "DE"
alluvial_df <- alluvial_df[!is.na(alluvial_df$DE_T3IOP),]


#alluvial_df$DE_T3IOP <- "no"
alluvial_df$DE_T3IOP[alluvial_df$logFC_T3IOP >= 1] <- "1.upregulated"
alluvial_df$DE_T3IOP[alluvial_df$logFC_T3IOP <= -1] <- "2.downregulated"

alluvial_df$direction <- "1.same"
alluvial_df$direction[sign(alluvial_df$FC_T3IOP) != sign(alluvial_df$FC_CPFT3IOP)] <- "2.opposite"

alluvial_df$magnitutde_of_change <- "1.increased"
alluvial_df$magnitutde_of_change[abs(alluvial_df$FC_CPFT3IOP) < abs(alluvial_df$FC_T3IOP)] <- "2.attenuated"
alluvial_df$magnitutde_of_change[alluvial_df$direction == "2.opposite"] <- "3.reversed"




```


```{r, warning=FALSE, echo=FALSE}
#plot alluvial plot
library(ggalluvial)


#palette_Pdum <- c("palegreen4","palegreen3","palegreen2",  "lightcoral", "lightpink","mistyrose", "dodgerblue3","lightskyblue", "lightskyblue1", "lightskyblue2")

ggplot(alluvial_df,
       aes(axis1 = as.factor(DE_T3IOP) ,
           #axis2 = as.factor(direction), 
           axis2 = as.factor(magnitutde_of_change))) +
  #geom_stratum(width = 1/12, fill = hue_pal()(11), color = "grey") +
  geom_stratum(width = 1/12, fill = c("lightcoral", "forestgreen", "dodgerblue", "lightskyblue", "orchid"), color = "black") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum)), aes.bind = TRUE) +
  geom_flow(aes(fill = factor(magnitutde_of_change)))+
  scale_x_discrete(limits = c("T3IOP_DE","Magnitute_of_change"), expand = c(.05, .05)) +
  #scale_fill_brewer(type = "qual", palette = "Set1") +
  scale_fill_manual(values = c("orchid", "lightskyblue", "dodgerblue"))+
  ggtitle("Effects of CPF-ddition to T3IOP")+
  theme_bw()+theme(legend.position = "none")+
  theme(#panel.border = element_rect(color="lightskyblue", fill=NA, linewidth= 2),
                   plot.title = ggtext::element_markdown(),
                   plot.subtitle = ggtext::element_markdown())+
  NULL



```
```{r, echo=FALSE}
alluvial_df[alluvial_df$DE_T3IOP == "1.upregulated" & alluvial_df$direction == "2.opposite",]
```

Venn diagrams
```{r, echo=FALSE}
#install.packages("venneuler")
#require(venneuler)
v <- venneuler(c(A=695, B=178, "A&B"=380))
v <- venneuler(c(A=267, B=80, "A&B"=165))
v <- venneuler(c(A=178, B=80, "A&B"=0))

v <- venneuler(c(A=558, B=715, "A&B"=179))
plot(v)
```

### Packages used

```{r, echo=FALSE}
sessionInfo()
```

## {-}

***
__Analysis Notebook__<br />
_Reynaud, Vianello, et al. "The multi-level effect of chlorpyrifos during clownfish metamorphosis"_<br /><br />
_RNotebook by Stefano Vianello, Marine Eco-Evo-Devo unit, Academia Sinica Marine Research Station_ <br />
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a> with the additional reservation of the rights to non-human text and data mining, AI training, and similar technologies, which are not granted. <br/><br />
<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a> <br />
